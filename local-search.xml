<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>今日计划-2024年7月25日</title>
    <link href="/2024/07/25/%E4%BB%8A%E6%97%A5%E8%AE%A1%E5%88%92-2024%E5%B9%B47%E6%9C%8825%E6%97%A5/"/>
    <url>/2024/07/25/%E4%BB%8A%E6%97%A5%E8%AE%A1%E5%88%92-2024%E5%B9%B47%E6%9C%8825%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="创建自己的在线博客"><a href="#创建自己的在线博客" class="headerlink" title="创建自己的在线博客"></a>创建自己的在线博客</h1><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>电脑已安装好 Git 和 Node.js ，Node 版本一定不要最新的22版本(会出现各种奇怪的问题)，建议16和18稳定版本。</p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>npm install hexo-cli -g</p><p>终端执行hexo -version出现 Hexo 版本号，说明安装成功</p><p>hexo -version</p><h3 id="本地搭建博客网站"><a href="#本地搭建博客网站" class="headerlink" title="本地搭建博客网站"></a>本地搭建博客网站</h3><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><p>在自己的博客目录下进入终端页面，执行</p><p> hexo init myblog<br> cd myblog<br> npm install</p><p>config.yml 存放的是博客配置信息， source&#x2F;_posts 是存放文章的地方</p><h4 id="预览项目"><a href="#预览项目" class="headerlink" title="预览项目"></a>预览项目</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs code">hexo clean  # 清除缓存文件，建议写完文章后执行一次<br>hexo g# 生成 public 文件夹，写完文章执行<br>hexo s# 启动 hexo 服务<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000/">http://localhost:4000/</a> 能正常显示网页就表示成功</p><h4 id="更换主题（需要的话）"><a href="#更换主题（需要的话）" class="headerlink" title="更换主题（需要的话）"></a>更换主题（需要的话）</h4><p>去主题官网，里面有上百种主题，这里选择 Fluid 主题，也是我个人在用的。<br>举例：使用fluid主题<br>将主题安装到myblog根目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs code">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 _config.fluid.yml，将 Fluid 主题的 _config.yml 内容复制进去(打开链接复制)。<br>后续修改博客的配置，例如标题，头像，评论等等只需要在 _config.fluid.yml文件中配置就行。</p><h4 id="指定主题"><a href="#指定主题" class="headerlink" title="指定主题"></a>指定主题</h4><pre><code class="hljs">修改myblog博客目录中的 _config.yml，内容如下：theme: fluid  # 指定主题language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改</code></pre><h4 id="创建关于页面"><a href="#创建关于页面" class="headerlink" title="创建关于页面"></a>创建关于页面</h4><pre><code class="hljs">首次使用主题的「关于页」需要手动创建：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs code">hexo new page about<br></code></pre></td></tr></table></figure></code></pre><p>创建成功后，编辑博客目录下 &#x2F;source&#x2F;about&#x2F;index.md，添加 layout 属性。内容如下：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">title: <span class="hljs-keyword">about</span><br><span class="hljs-keyword">layout</span>: <span class="hljs-keyword">about</span><br></code></pre></td></tr></table></figure><p>填写关于页面的内容</p><h4 id="检查主题是否更换成功"><a href="#检查主题是否更换成功" class="headerlink" title="检查主题是否更换成功"></a>检查主题是否更换成功</h4><p>再次启动项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs code">hexo clean # 清除缓存文件，建议写完文章后执行一次<br>hexo g# 生成 public 文件夹，写完文章执行<br>hexo s# 启动 hexo 服务<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000/">http://localhost:4000/</a> 出现下图说明主题启动成功<br><img src="/img/%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E5%90%8E%E5%86%8D%E6%AC%A1%E5%90%AF%E5%8A%A8.png" alt="更换主题后再次启动" title="更换主题后再次启动"></p><h3 id="将项目部署到-GitHub-Pages"><a href="#将项目部署到-GitHub-Pages" class="headerlink" title="将项目部署到 GitHub Pages"></a>将项目部署到 GitHub Pages</h3><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>前提:如果没有github账户的话，自己需要注册，一定要记住的登录账户名和登录密码，并且需要在github中创建自己的个人令牌（网上有教程）,后续的终端页面执行命令过程中会用到个人令牌<br>登录 GitHub，新建一个 Repository，Repository name一定要是你的用户名.github.io<br>进入刚创建好仓库主页，复制SSH后面的url</p><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>打开博客目录下的_config.yml，拉到最后，填写deploy模块：repository 填写刚才复制的链接，内容如下：<br>    <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># Deployment </span><br><span class="hljs-meta">## Docs: https:<span class="hljs-comment">//hexo.io/docs/one-command-deployment</span></span><br><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">type:</span> git<br><span class="hljs-symbol">repository:</span> <span class="hljs-params">&lt;此处填写SSH后面的url&gt;</span><br><span class="hljs-symbol">branch:</span> main<br></code></pre></td></tr></table></figure></p><h4 id="在项目路径下安装git"><a href="#在项目路径下安装git" class="headerlink" title="在项目路径下安装git"></a>在项目路径下安装git</h4><p>在项目路径下安装 Git 插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs code">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><h4 id="将项目部署到github"><a href="#将项目部署到github" class="headerlink" title="将项目部署到github"></a>将项目部署到github</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs code">hexo c <br>hexo g <br>hexo d  # hexo d 表示执行部署<br></code></pre></td></tr></table></figure><h4 id="生成访问链接"><a href="#生成访问链接" class="headerlink" title="生成访问链接"></a>生成访问链接</h4><p>执行成功后，在仓库中右侧点击 About 右侧的 设置符号<br><img src="/img/%E5%9C%A8%E4%BB%93%E5%BA%93%E9%A1%B5%E9%9D%A2%E7%82%B9%E5%87%BBabout%E5%8F%B3%E4%BE%A7%E7%9A%84%E7%9A%84%E8%AE%BE%E7%BD%AE.png" alt="在仓库页面点击about右侧的的设置" title="在仓库页面点击about右侧的的设置"><br>然后生成网址：<br><img src="/img/%E4%BB%93%E5%BA%93%E4%B8%AD%E7%94%9F%E6%88%90%E7%BD%91%E5%9D%80.png" alt="仓库中生成网址" title="仓库中生成网址"></p><h4 id="访问自己的在线博客"><a href="#访问自己的在线博客" class="headerlink" title="访问自己的在线博客"></a>访问自己的在线博客</h4><p>生成成功后，就可以访问自己的网站了,网站就是生成网址页面中的网址</p>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的主页</title>
    <link href="/2024/07/25/hello-world/"/>
    <url>/2024/07/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>今日计划-2024年7月24日</title>
    <link href="/2024/07/24/%E4%BB%8A%E6%97%A5%E8%AE%A1%E5%88%92-2024%E5%B9%B47%E6%9C%8824%E6%97%A5/"/>
    <url>/2024/07/24/%E4%BB%8A%E6%97%A5%E8%AE%A1%E5%88%92-2024%E5%B9%B47%E6%9C%8824%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="今日计划-2024年7月24日"><a href="#今日计划-2024年7月24日" class="headerlink" title="今日计划-2024年7月24日"></a>今日计划-2024年7月24日</h1><h2 id="看一个算法"><a href="#看一个算法" class="headerlink" title="看一个算法"></a>看一个算法</h2><h2 id="SUBSTRING-函数截取字符串"><a href="#SUBSTRING-函数截取字符串" class="headerlink" title="SUBSTRING() 函数截取字符串"></a>SUBSTRING() 函数截取字符串</h2><p>使用 <code>SUBSTRING()</code> 函数截取字符串中间的某个字符或部分，需要确定开始截取的位置和要截取的长度。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol><li><p><strong>截取从第6个字符开始的3个字符：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUBSTRING</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">AS</span> MiddlePart;<br></code></pre></td></tr></table></figure><p>结果：<code> Wor</code></p></li><li><p><strong>截取从第8个字符开始的直到字符串末尾的所有字符：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUBSTRING</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>, <span class="hljs-number">8</span>, LEN(<span class="hljs-string">&#x27;Hello World&#x27;</span>)) <span class="hljs-keyword">AS</span> EndPart;<br></code></pre></td></tr></table></figure><p>结果：<code>World</code></p></li><li><p><strong>截取从第4个字符开始的直到字符串末尾的所有字符：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUBSTRING</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>, <span class="hljs-number">4</span>, LEN(<span class="hljs-string">&#x27;Hello World&#x27;</span>) <span class="hljs-operator">-</span> <span class="hljs-number">3</span>) <span class="hljs-keyword">AS</span> FromFourthToEnd;<br></code></pre></td></tr></table></figure><p>结果：<code>lo World</code></p></li><li><p><strong>截取字符串的倒数第5个字符到末尾：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUBSTRING</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>, (LEN(<span class="hljs-string">&#x27;Hello World&#x27;</span>) <span class="hljs-operator">-</span> <span class="hljs-number">4</span>) <span class="hljs-operator">+</span> <span class="hljs-number">1</span>, LEN(<span class="hljs-string">&#x27;Hello World&#x27;</span>)) <span class="hljs-keyword">AS</span> LastFiveCharsToEnd;<br></code></pre></td></tr></table></figure><p>结果：<code>orld</code></p></li><li><p><strong>截取字符串的最后一个单词：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUBSTRING</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>, CHARINDEX(<span class="hljs-string">&#x27; &#x27;</span>, REVERSE(<span class="hljs-string">&#x27;Hello World&#x27;</span>)) <span class="hljs-operator">+</span> <span class="hljs-number">1</span>, LEN(<span class="hljs-string">&#x27;Hello World&#x27;</span>)) <span class="hljs-keyword">AS</span> LastWord;<br></code></pre></td></tr></table></figure><p>结果：<code>World</code></p></li><li><p><strong>截取字符串中某个特定字符之后的第一部分：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 假设我们要截取 &#x27;o&#x27; 之后的所有字符</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUBSTRING</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>, CHARINDEX(<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;Hello World&#x27;</span>) <span class="hljs-operator">+</span> <span class="hljs-number">1</span>, LEN(<span class="hljs-string">&#x27;Hello World&#x27;</span>)) <span class="hljs-keyword">AS</span> AfterSpecificChar;<br></code></pre></td></tr></table></figure><p>结果：<code>o World</code></p></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>SUBSTRING()</code> 函数的索引是从1开始的，所以当你想截取中间的字符时，你需要知道从哪个位置开始。</li><li>使用 <code>LEN()</code> 函数来获取字符串的总长度，这在确定截取长度时非常有用。</li><li>使用 <code>CHARINDEX()</code> 函数可以找到特定字符或子字符串在字符串中的位置，这对于截取特定字符之后的字符串部分非常有用。</li><li>负数索引（如示例4所示）可以从字符串的末尾开始计数，这在某些情况下非常有用。</li></ul><h2 id="将Localsite部署到github上"><a href="#将Localsite部署到github上" class="headerlink" title="将Localsite部署到github上"></a>将Localsite部署到github上</h2>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日计划-2024年7月23日</title>
    <link href="/2024/07/23/%E4%BB%8A%E6%97%A5%E8%AE%A1%E5%88%92-2024%E5%B9%B47%E6%9C%8823%E6%97%A5/"/>
    <url>/2024/07/23/%E4%BB%8A%E6%97%A5%E8%AE%A1%E5%88%92-2024%E5%B9%B47%E6%9C%8823%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="今日计划-2024年7月23日"><a href="#今日计划-2024年7月23日" class="headerlink" title="今日计划-2024年7月23日"></a>今日计划-2024年7月23日</h1><h2 id="下载几部电影"><a href="#下载几部电影" class="headerlink" title="下载几部电影"></a>下载几部电影</h2><pre><code class="hljs">《人类》</code></pre><h2 id="下载几首歌曲"><a href="#下载几首歌曲" class="headerlink" title="下载几首歌曲"></a>下载几首歌曲</h2><h2 id="优化sqlserver查询语句"><a href="#优化sqlserver查询语句" class="headerlink" title="优化sqlserver查询语句"></a>优化sqlserver查询语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><code class="hljs sqlserver">USE [YHWCS]<br>GO<br>/****** Object:  StoredProcedure [dbo].[P_时间统计报表]    Script Date: 2024/7/23 11:09:33 ******/<br>SET ANSI_NULLS ON<br>GO<br>SET QUOTED_IDENTIFIER ON<br>GO<br>-- =============================================<br>-- Author:xiaoxianghui<br>-- Create date: 2024年7月5日<br>-- Description:时间统计数据<br>-- =============================================<br>ALTER PROCEDURE [dbo].[P_时间统计报表] <br> @TaskNo nvarchar(50) = NULL, <br> @PalletId nvarchar(50) = NULL, <br> @PositionId nvarchar(50) = NULL, <br> @Tunner nvarchar(50) = NULL, <br> @PLCType nvarchar(50) = NULL,<br> @IoDate datetime = NULL<br><br>AS<br>BEGIN <br>SELECT <br>     --distinct tps.Cn, tps.Id, <br>tps.CreateTime as &quot;创建时间&quot;, <br>tps.Name as &quot;设备名称&quot;, <br>case tps.PLCType <br>when 1 then &#x27;入库&#x27; <br>when 2 then &#x27;出库&#x27; <br>when 4 then &#x27;移库&#x27; <br>end as &quot;指令类型&quot;, <br>tps.TaskNo as &quot;工作编号&quot;, <br>tps.BarCode as &quot;托盘编号&quot;, <br>tps.StartTime as &quot;开始时间&quot;, <br>tps.EndTime as &quot;结束时间&quot;,<br>    --DATEDIFF(SECOND, tps.StartTime, tps.EndTime) AS &quot;工作时间(秒)&quot;,<br>    CASE<br>WHEN tps.PLCType = 1 AND tps.Name = &#x27;一层输送线&#x27; THEN NewTimeSubQuery1.NewTime<br>WHEN tps.PLCType = 2 AND tps.Name = &#x27;一层输送线&#x27; THEN NewTimeSubQuery2.NewTime<br>WHEN tps.PLCType in (1, 2) AND tps.Name = &#x27;双工位RGV&#x27; THEN NewTimeSubQuery3.NewTime<br>WHEN tps.PLCType in (1, 2) AND tps.Name like &#x27;%堆垛机&#x27; THEN NewTimeSubQuery4.NewTime<br>--WHEN tps.PLCType = 2 AND tps.Name = &#x27;双工位RGV&#x27; THEN NewTimeSubQuery5.NewTime<br>--WHEN tps.PLCType = 2 AND tps.Name like &#x27;%堆垛机&#x27; THEN NewTimeSubQuery6.NewTime<br>WHEN tps.PLCType = 1 AND tps.Name not in ( &#x27;一层输送线&#x27;,&#x27;双工位RGV&#x27;, &#x27;%堆垛机&#x27;) THEN NewTimeSubQuery7.NewTime<br>WHEN tps.PLCType = 2 AND tps.Name not in ( &#x27;一层输送线&#x27;,&#x27;双工位RGV&#x27;, &#x27;%堆垛机&#x27;) THEN NewTimeSubQuery8.NewTime<br>WHEN tps.PLCType = 4 AND tps.Name like &#x27;%堆垛机&#x27; THEN NewTimeSubQuery9.NewTime<br>ELSE NULL<br> END AS &quot;流程时间(秒)&quot;,<br> --tps.StartDesign , <br> --tps.EndDesign , <br> --toh.ordIdNew as &quot;工作编号&quot;,<br> --toh.palletId as &quot;托盘编号&quot;, <br> --toh.srcPositionId as &quot;移出仓位&quot;, <br> --toh.positionId as &quot;仓位编号&quot;,  <br> case toh.optType <br> when 0 then &#x27;WMS错误&#x27; when 1 then &#x27;整入&#x27; when 2 then &#x27;补入&#x27; when 3 then &#x27;整出&#x27; when 4 then &#x27;分拣&#x27; when 5 then &#x27;空入&#x27; when 6 then &#x27;空出/补出&#x27; when 7 then &#x27;空盘移库&#x27; when 8 then &#x27;盘库&#x27; when 9 then &#x27;盘库返库&#x27; when 10 then &#x27;实盘移库&#x27; when 11 then &#x27;转移出库&#x27; when 12 then &#x27;转移入库&#x27;  when 13 then &#x27;移动穿梭车&#x27; <br> end as &quot;工控类型&quot;,  <br> toh.ioDate as &quot;工控日期&quot;,  <br> --toh.optStation as &quot;操作台&quot;,  <br> --toh.pHs as &quot;分配台位&quot;,  <br> case toh.design<br> when -2 then &#x27;被删除的指令&#x27; when -1 then &#x27;待执行&#x27; when 0 then &#x27;堆垛机待命&#x27; when 1 then &#x27;堆垛机工作&#x27; when 2 then &#x27;未过账&#x27; when 3 then &#x27;已过帐&#x27; when 5 then &#x27;分拣到达&#x27; when 6 then &#x27;分拣返回&#x27; when 7 then &#x27;执行入库&#x27; when 8 then &#x27;重入未过账&#x27; when 9 then &#x27;重入已过账&#x27; when 10 then &#x27;RGV待命&#x27; when 11 then &#x27;RGV工作&#x27; when 12 then &#x27;线体等待&#x27;<br>  end as &quot;工控进程&quot;,  <br> --toh.userId as &quot;操作员&quot;,  <br> case toh.sysType<br> when 0 then &#x27;wms&#x27; when 1 then &#x27;RF&#x27; when 2 then &#x27;DPS&#x27; when 3 then &#x27;其他&#x27;<br> end as &quot;系统下发&quot;,  <br> case toh.byHand<br> when 0 then &#x27;自动&#x27; when 1 then &#x27;手动&#x27;<br> end as &quot;指令方式&quot;,  <br> --case toh.mStatus<br> --when 0 then &#x27;已组盘&#x27; when 1 then &#x27;待执行&#x27; when 2 then &#x27;正在执行&#x27;<br> --end as &quot;生成状态&quot;,  <br> case toh.dStatus<br> when 0 then &#x27;正常&#x27; when 1 then &#x27;暂停&#x27;<br> end as &quot;执行状态&quot;, <br> --case toh.pltReturn<br> --when 0 then &#x27;线体上&#x27; when 1 then &#x27;线体下&#x27;<br> --end as &quot;运动状态&quot;, <br> --case toh.PlcType<br> --when 1 then &#x27;入库&#x27; when 2 then &#x27;出库&#x27; when 4 then &#x27;移库&#x27;<br> --end as &quot;指令类型&quot;,   <br> toh.tunner as &quot;巷道&quot;, <br> toh.mBillIds as &quot;订单主编号集合&quot;<br>    <br>FROM <br>    tPLCServerLog tps<br>LEFT JOIN <br>    tOrderHy toh ON tps.TaskNo = toh.ordIdNew AND tps.BarCode = toh.palletId <br>OUTER APPLY<br>(<br>    SELECT <br>        COALESCE(<br>DATEDIFF(SECOND, <br>MIN(CASE WHEN tps2.Name = &#x27;一层输送线&#x27; THEN tps2.StartTime ELSE NULL END),<br>MAX(CASE WHEN tps2.Name = &#x27;双工位RGV&#x27; THEN tps2.StartTime ELSE NULL END)),<br>DATEDIFF(SECOND,<br> MIN(CASE WHEN tps2.Name = &#x27;一层输送线&#x27; THEN tps2.StartTime END),<br> MAX(CASE WHEN tps2.Name = &#x27;一层输送线&#x27; THEN tps2.EndTime END)) <br>) AS NewTime<br>    FROM <br>        tPLCServerLog tps2<br>--left join tOrderHy toh2 ON tps2.TaskNo = toh2.ordIdNew AND tps2.BarCode = toh2.palletId<br>    WHERE <br>        tps2.TaskNo = tps.TaskNo AND <br>        tps2.BarCode = tps.BarCode AND <br>        tps2.PLCType = 1 <br>--DATEDIFF(SECOND, tps2.StartTime, tps2.EndTime) &lt; 86400 and<br>--tps2.StartTime &lt;  tps2.EndTime and<br>--tps2.EndTime &lt; toh2.ioDate and<br>--toh2.ordIdNew is not NULL and toh2.palletId is not NULL<br>) NewTimeSubQuery1<br>OUTER APPLY<br>(<br>    SELECT <br>         COALESCE(<br>DATEDIFF(SECOND, <br>MIN(CASE WHEN tps3.Name = &#x27;双工位RGV&#x27; THEN tps3.EndTime ELSE NULL END), <br>MAX(CASE WHEN tps3.Name = &#x27;一层输送线&#x27; THEN tps3.EndTime ELSE NULL END)<br>),<br>DATEDIFF(SECOND, <br>MAX(CASE WHEN tps3.Name = &#x27;一层输送线&#x27; THEN tps3.StartTime ELSE NULL END), <br>MAX(CASE WHEN tps3.Name = &#x27;一层输送线&#x27; THEN tps3.EndTime ELSE NULL END)<br>))  AS NewTime<br>    FROM <br>        tPLCServerLog tps3<br>--left join tOrderHy toh3 ON tps3.TaskNo = toh3.ordIdNew AND tps3.BarCode = toh3.palletId<br>    WHERE <br>        tps3.TaskNo = tps.TaskNo AND <br>        tps3.BarCode = tps.BarCode AND <br>        tps3.PLCType = 2 <br>        --DATEDIFF(SECOND, tps3.StartTime, tps3.EndTime) &lt; 86400 and<br>--tps3.StartTime &lt;  tps3.EndTime and<br>----tps3.EndTime &lt; toh3.ioDate and<br>--toh3.ordIdNew is not NULL and toh3.palletId is not NULL<br>) NewTimeSubQuery2<br>OUTER APPLY<br>(<br>    SELECT <br>        MIN(DATEDIFF(SECOND, <br>            (CASE WHEN tps4.Name = &#x27;双工位RGV&#x27; THEN tps4.StartTime ELSE NULL END), <br>            (CASE WHEN tps4.Name = &#x27;双工位RGV&#x27; THEN tps4.EndTime ELSE NULL END)<br>        )) AS NewTime<br>    FROM <br>        tPLCServerLog tps4<br>--left join tOrderHy toh4 ON tps4.TaskNo = toh4.ordIdNew AND tps4.BarCode = toh4.palletId<br>    WHERE <br>        tps4.TaskNo = tps.TaskNo AND <br>        tps4.BarCode = tps.BarCode AND <br>        tps4.PLCType in (1, 2) <br>        --DATEDIFF(SECOND, tps4.StartTime, tps4.EndTime) &lt; 86400 and<br>--tps4.StartTime &lt;  tps4.EndTime and<br>--tps4.EndTime &lt; toh4.ioDate and<br>--toh4.ordIdNew is not NULL and toh4.palletId is not NULL<br>) NewTimeSubQuery3<br>OUTER APPLY<br>(<br>    SELECT<br>COALESCE( <br>DATEDIFF(SECOND, <br>MAX(CASE WHEN tps5.Name like &#x27;%堆垛机&#x27; THEN tps5.StartTime ELSE NULL END), <br>MAX(CASE WHEN tps5.Name like &#x27;%堆垛机&#x27; THEN tps5.EndTime ELSE NULL END)),<br>DATEDIFF(SECOND, <br>MAX(CASE WHEN tps5.Name like &#x27;%堆垛机&#x27; THEN tps5.StartTime ELSE NULL END), <br>MAX(CASE WHEN tps5.Name like &#x27;%堆垛机&#x27; THEN toh5.ioDate ELSE NULL END))<br>) AS NewTime<br>    FROM <br>        tPLCServerLog tps5<br>left join tOrderHy toh5 ON tps5.TaskNo = toh5.ordIdNew AND tps5.BarCode = toh5.palletId<br>    WHERE <br>        tps5.TaskNo = tps.TaskNo AND <br>        tps5.BarCode = tps.BarCode AND <br>        tps5.PLCType in (1, 2) <br>        --DATEDIFF(SECOND, tps5.StartTime, tps5.EndTime) &lt; 86400 and<br>--tps5.StartTime &lt;  tps5.EndTime and<br>--toh5.ordIdNew is not NULL and toh5.palletId is not NULL<br>----tps5.EndTime &lt; toh5.ioDate<br>) NewTimeSubQuery4<br>--OUTER APPLY<br>--(<br>--    SELECT <br>--        MIN(DATEDIFF(SECOND, <br>--            (CASE WHEN tps6.Name = &#x27;双工位RGV&#x27; THEN tps6.StartTime ELSE NULL END), <br>--            (CASE WHEN tps6.Name = &#x27;双工位RGV&#x27; THEN tps6.EndTime ELSE NULL END)<br>--        )) AS NewTime<br>--    FROM <br>--        tPLCServerLog tps6<br>----left join tOrderHy toh6 ON tps6.TaskNo = toh6.ordIdNew AND tps6.BarCode = toh6.palletId<br>--    WHERE <br>--        tps6.TaskNo = tps.TaskNo AND <br>--        tps6.BarCode = tps.BarCode AND <br>--        tps6.PLCType = 2 <br>--        --DATEDIFF(SECOND, tps6.StartTime, tps6.EndTime) &lt; 86400 and<br>----tps6.StartTime &lt;  tps6.EndTime and<br>----tps6.EndTime &lt; toh6.ioDate and<br>----toh6.ordIdNew is not NULL and toh6.palletId is not NULL<br>--) NewTimeSubQuery5<br>--OUTER APPLY<br>--(<br>--    SELECT <br>--        DATEDIFF(SECOND, <br>--            MAX(CASE WHEN tps7.Name like &#x27;%堆垛机&#x27; THEN tps7.StartTime ELSE NULL END), <br>--            MAX(CASE WHEN tps7.Name like &#x27;%堆垛机&#x27; THEN tps7.EndTime ELSE NULL END)<br>--        ) AS NewTime<br>--    FROM <br>--        tPLCServerLog tps7<br>----left join tOrderHy toh7 ON tps7.TaskNo = toh7.ordIdNew AND tps7.BarCode = toh7.palletId<br>--    WHERE <br>--        tps7.TaskNo = tps.TaskNo AND <br>--        tps7.BarCode = tps.BarCode AND <br>--        tps7.PLCType = 2 <br>--        --DATEDIFF(SECOND, tps7.StartTime, tps7.EndTime) &lt; 86400 and<br>----tps7.StartTime &lt;  tps7.EndTime and<br>----tps7.EndTime &lt; toh7.ioDate and<br>----toh7.ordIdNew is not NULL and toh7.palletId is not NULL<br>--) NewTimeSubQuery6<br>OUTER APPLY<br>(<br>    SELECT <br>        DATEDIFF(SECOND, <br>            MAX(CASE WHEN tps8.Name not in ( &#x27;一层输送线&#x27;,&#x27;双工位RGV&#x27;, &#x27;%堆垛机&#x27;) THEN tps8.StartTime ELSE NULL END), <br>            MAX(CASE WHEN tps8.Name not in ( &#x27;一层输送线&#x27;,&#x27;双工位RGV&#x27;, &#x27;%堆垛机&#x27;) THEN tps8.EndTime ELSE NULL END)<br>        ) AS NewTime<br>    FROM <br>        tPLCServerLog tps8<br>--left join tOrderHy toh8 ON tps8.TaskNo = toh8.ordIdNew AND tps8.BarCode = toh8.palletId<br>    WHERE <br>        tps8.TaskNo = tps.TaskNo AND <br>        tps8.BarCode = tps.BarCode AND <br>        tps8.PLCType = 1 <br>        --DATEDIFF(SECOND, tps8.StartTime, tps8.EndTime) &lt; 86400 and<br>--tps8.StartTime &lt;  tps8.EndTime and<br>--tps8.EndTime &lt; toh8.ioDate and<br>--toh8.ordIdNew is not NULL and toh8.palletId is not NULL<br>) NewTimeSubQuery7<br>OUTER APPLY<br>(<br>    SELECT <br>        DATEDIFF(SECOND, <br>            MAX(CASE WHEN tps9.Name not in ( &#x27;一层输送线&#x27;,&#x27;双工位RGV&#x27;, &#x27;%堆垛机&#x27;) THEN tps9.StartTime ELSE NULL END), <br>            MAX(CASE WHEN tps9.Name not in ( &#x27;一层输送线&#x27;,&#x27;双工位RGV&#x27;, &#x27;%堆垛机&#x27;) THEN tps9.EndTime ELSE NULL END)<br>        ) AS NewTime<br>    FROM <br>        tPLCServerLog tps9<br>--left join tOrderHy toh9 ON tps9.TaskNo = toh9.ordIdNew AND tps9.BarCode = toh9.palletId<br>    WHERE <br>        tps9.TaskNo = tps.TaskNo AND <br>        tps9.BarCode = tps.BarCode AND <br>        tps9.PLCType = 2 <br>        --DATEDIFF(SECOND, tps9.StartTime, tps9.EndTime) &lt; 86400 and<br>--tps9.StartTime &lt;  tps9.EndTime and<br>--tps9.EndTime &lt; toh9.ioDate and<br>--toh9.ordIdNew is not NULL and toh9.palletId is not NULL<br>) NewTimeSubQuery8<br>OUTER APPLY<br>(<br>    SELECT <br>        DATEDIFF(SECOND, <br>            MAX(CASE WHEN tps10.Name like &#x27;%堆垛机&#x27; THEN tps10.StartTime ELSE NULL END), <br>            MAX(CASE WHEN tps10.Name like &#x27;%堆垛机&#x27; THEN tps10.EndTime ELSE NULL END)<br>        ) AS NewTime<br>    FROM <br>        tPLCServerLog tps10<br>--left join tOrderHy toh10 ON tps10.TaskNo = toh10.ordIdNew AND tps10.BarCode = toh10.palletId<br>    WHERE <br>        tps10.TaskNo = tps.TaskNo AND <br>        tps10.BarCode = tps.BarCode AND <br>        tps10.PLCType = 4 <br>        --DATEDIFF(SECOND, tps10.StartTime, tps10.EndTime) &lt; 86400 and<br>--tps10.StartTime &lt;  tps10.EndTime and<br>--toh10.ordIdNew is not NULL and toh10.palletId is not NULL<br>--tps10.EndTime &lt; toh10.ioDate<br>) NewTimeSubQuery9<br>where<br>----DATEDIFF(SECOND, tps.StartTime, tps.EndTime) &lt; 86400 and<br>--tps.Cn &lt;&gt; 0 AND<br>--tps.StartTime IS NOT NULL AND <br>--tps.EndTime IS NOT NULL AND<br>----tps.StartTime &lt; tps.EndTime AND<br>--toh.ordIdNew is not NULL and toh.palletId is not NULL <br>----DATEDIFF(SECOND, tps.StartTime, tps.EndTime) &gt; 5  <br>----AND tps.TaskNo = &#x27;17731&#x27; and tps.BarCode = &#x27;T03452&#x27;<br>(@Tunner IS NULL OR @Tunner = &#x27;&#x27; OR toh.tunner = @Tunner)<br>AND (@TaskNo IS NULL OR @TaskNo = &#x27;&#x27; OR tps.TaskNo = @TaskNo)<br>AND (@PalletId IS NULL OR @PalletId = &#x27;&#x27; OR toh.palletId = @PalletId)<br>        AND (@PositionId IS NULL OR @PositionId = &#x27;&#x27; OR toh.positionId = @PositionId OR srcpositionid=@PositionId)<br>        AND (@PLCType IS NULL OR @PLCType = &#x27;&#x27; OR tps.PLCType = @PLCType)<br>        AND (@IoDate IS NULL OR @IoDate = &#x27;&#x27; OR convert(varchar(10),toh.ioDate,21) = convert(varchar(10),@IoDate,21))<br>--order by tps.TaskNo, tps.BarCode<br><br>END<br><br></code></pre></td></tr></table></figure><h2 id="学习sqlserver"><a href="#学习sqlserver" class="headerlink" title="学习sqlserver"></a>学习sqlserver</h2><p><a href="https://www.cnblogs.com/xjnotxj/p/12372807.html">看了《SQL基础教程》+《SQL进阶教程》学习笔记</a><br>个人总结：<br>        1.sql里面用到的是声明式思维和面向集合对象思维<br>        2.sql谓词<br>        3.一阶谓词（输入是行数据）、二阶谓词（输入是集合）、三阶谓词（输入是集合的集合）…</p><h2 id="看一个算法"><a href="#看一个算法" class="headerlink" title="看一个算法"></a>看一个算法</h2><p><img src="/img/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%88%E5%88%97-%E8%88%AA%E8%BF%90%E8%B7%AF%E5%8A%B2%E4%BC%98%E5%8C%96.gif" alt="遗传算法的应用案列-航运路径优化" title="遗传算法的应用案列-航运路径优化"><br><a href="https://www.jiqizhixin.com/articles/2017-08-05-2">正在看：一文读懂遗传算法基础知识与实际应用</a>    </p>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日计划-2024年7月22日</title>
    <link href="/2024/07/22/%E4%BB%8A%E6%97%A5%E8%AE%A1%E5%88%92-2024%E5%B9%B47%E6%9C%8822%E6%97%A5/"/>
    <url>/2024/07/22/%E4%BB%8A%E6%97%A5%E8%AE%A1%E5%88%92-2024%E5%B9%B47%E6%9C%8822%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="今日计划-2024年7月22日"><a href="#今日计划-2024年7月22日" class="headerlink" title="今日计划-2024年7月22日"></a>今日计划-2024年7月22日</h1><h2 id="下载几部电影"><a href="#下载几部电影" class="headerlink" title="下载几部电影"></a>下载几部电影</h2><pre><code class="hljs">《肖申克的救赎》《阿甘正传》《海上钢琴师》</code></pre><h2 id="下载几首歌曲"><a href="#下载几首歌曲" class="headerlink" title="下载几首歌曲"></a>下载几首歌曲</h2><h2 id="下载几部书籍"><a href="#下载几部书籍" class="headerlink" title="下载几部书籍"></a>下载几部书籍</h2><h2 id="学习几个算法"><a href="#学习几个算法" class="headerlink" title="学习几个算法"></a>学习几个算法</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><img src="/img/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%A4%BA%E4%BE%8B.gif" alt="插入排序示例" title="插入排序示例"></p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><pre><code class="hljs">Z插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</code></pre><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>  一般来说，插入排序都采用in-place在数组上实现。具体如下：</p><pre><code class="hljs">第一步: 从第一个元素开始，该元素可以认为已经被排序；第二步: 取出下一个元素，在已经排序的元素序列中从后向前扫描；第三步: 如果该元素（已排序）大于新元素，将该元素移到下一位置；第四步: 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；第五步: 将新元素插入到该位置后。 重复第二步到第五步。</code></pre><h4 id="算法示例代码"><a href="#算法示例代码" class="headerlink" title="算法示例代码"></a>算法示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs code">function insertionSort(arr) &#123;<br>        if (arr == null || arr.length &lt; 2) &#123;<br>            return arr;<br>        &#125;<br>        for (let i = 1; i &lt; arr.length; i++) &#123;<br>            for (let j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123;<br>                let temp = arr[j];<br>                arr[j] = arr[j + 1];<br>                arr[j + 1] = temp;<br>            &#125;<br>        &#125;<br>        return arr;<br>    &#125;<br>    var arr = [3, 4, 2, 1, 6, 7, 8, 4];<br>    console.log(arr); // [3, 4, 2, 1, 6, 7, 8, 4]<br>    insertionSort(arr);<br>    console.log(arr); // [1, 2, 3, 4, 4, 6, 7, 8]<br></code></pre></td></tr></table></figure><h4 id="相关语法"><a href="#相关语法" class="headerlink" title="相关语法"></a>相关语法</h4><pre><code class="hljs">for 循环语句    for (表达式1; 表达式2; 表达式3)    &#123;        语句;    &#125;执行过程    求解表达式1。    求解表达式2。若其值为真，则执行 for 语句中指定的内嵌语句，然后执行第3步；若表达式2值为假，则结束循环，转到第5步。    求解表达式3。    转回上面第2步继续执行。    循环结束，执行 for 语句下面的语句。for循环嵌套    在 Java 中，for 循环可以嵌套使用。这意味着在一个 for 循环内部可以再定义一个 for 循环。    这样做的好处是，当我们需要在循环内部重复执行多次操作时，可以使用嵌套的 for 循环来实现。    举个例子，假设我们要在控制台输出从 1 到 9 的乘法表，我们可以使用两个嵌套的 for 循环来实现：    for (int i = 1; i &lt;= 9; i++) &#123;        for (int j = 1; j &lt;= i; j++) &#123;            System.out.print(j + &quot;*&quot; + i + &quot;=&quot; + i * j + &quot; &quot;);        &#125;    System.out.println();    &#125;    在这段代码中，我们定义了两个 for 循环，其中外层循环控制行数，内层循环控制列数。    在内层循环中，我们输出每一行的每一个数字，并在每一行结束后换行。    这样，我们就使用了 for 循环的嵌套来实现了乘法表的输出。for循环的嵌套使用方法：    在外层 for 循环中定义内层 for 循环。    在内层 for 循环中，重复执行所需的操作。    在内层 for 循环结束后，继续执行外层 for 循环。</code></pre><h2 id="学习sql-Server"><a href="#学习sql-Server" class="headerlink" title="学习sql Server"></a>学习sql Server</h2>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日事项-2024年7月20日</title>
    <link href="/2024/07/20/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%8820%E6%97%A5/"/>
    <url>/2024/07/20/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%8820%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="今日事项-2024年7月20日"><a href="#今日事项-2024年7月20日" class="headerlink" title="今日事项-2024年7月20日"></a>今日事项-2024年7月20日</h1><h2 id="事项一-吃透一个算法"><a href="#事项一-吃透一个算法" class="headerlink" title="事项一 吃透一个算法"></a>事项一 吃透一个算法</h2><h3 id="希尔排序："><a href="#希尔排序：" class="headerlink" title="希尔排序："></a>希尔排序：</h3><p>概念：1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　</p><p>算法描述:</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><p>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；</p><p>按增量序列个数k，对序列进行k 趟排序；</p><p>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><p>动画演示：<br><img src="/img/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="希尔排序" title="希尔排序"></p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs code">function shellSort(arr) &#123;<br>var len = arr.length;<br>for (var gap = Math.floor(len / 2); gap &gt; 0; gap = Math.floor(gap /2)) &#123;<br>for (var i = gap; i &lt; len; i++) &#123;<br>for (var j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[gap + j]; j -= gap) &#123;<br>var temp = arr[j];<br>arr[j] = arr[gap + j];<br>arr[gap + j] = temp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 04];<br>console.log(arr); // [49, 38, 65, 97, 76, 13, 27, 49, 55, 4]<br>shellSort(arr);<br>console.log(arr); // [4, 13, 27, 38, 49, 49, 55, 65, 76, 97]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日事项-2024年7月19日</title>
    <link href="/2024/07/19/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%8819%E6%97%A5/"/>
    <url>/2024/07/19/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%8819%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="今日事项-2024年7月19日"><a href="#今日事项-2024年7月19日" class="headerlink" title="今日事项-2024年7月19日"></a>今日事项-2024年7月19日</h1><h2 id="吃透一个算法-堆排序"><a href="#吃透一个算法-堆排序" class="headerlink" title="吃透一个算法-堆排序"></a>吃透一个算法-堆排序</h2><p><img src="/img/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%A4%BA%E4%BE%8B.gif" alt="堆排序示例" title="堆排序示例"></p><h3 id="代码、代码注释与详细解释："><a href="#代码、代码注释与详细解释：" class="headerlink" title="代码、代码注释与详细解释："></a>代码、代码注释与详细解释：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">arr, n, i</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    调整堆的函数，确保堆的性质。</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">    arr (list): 待排序的数组。</span><br><span class="hljs-string">    n (int): 数组的长度。</span><br><span class="hljs-string">    i (int): 当前节点的索引。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    largest = i  <span class="hljs-comment"># 初始时假设当前节点是最大的</span><br>    left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>  <span class="hljs-comment"># 左子节点的索引</span><br>    right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>  <span class="hljs-comment"># 右子节点的索引</span><br><br>    <span class="hljs-comment"># 检查左子节点是否存在，并与当前节点比较</span><br>    <span class="hljs-keyword">if</span> left &lt; n <span class="hljs-keyword">and</span> arr[i] &lt; arr[left]:<br>        largest = left  <span class="hljs-comment"># 如果左子节点更大，则更新最大值的索引</span><br><br>    <span class="hljs-comment"># 检查右子节点是否存在，并与当前节点比较</span><br>    <span class="hljs-keyword">if</span> right &lt; n <span class="hljs-keyword">and</span> arr[largest] &lt; arr[right]:<br>        largest = right  <span class="hljs-comment"># 如果右子节点更大，则更新最大值的索引</span><br><br>    <span class="hljs-comment"># 如果最大值的索引不是当前节点，则交换它们，并递归调整最大值节点的子堆</span><br>    <span class="hljs-keyword">if</span> largest != i:<br>        arr[i], arr[largest] = arr[largest], arr[i]  <span class="hljs-comment"># 交换当前节点和最大值节点</span><br>        heapify(arr, n, largest)  <span class="hljs-comment"># 递归调整最大值节点的子堆</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">heap_sort</span>(<span class="hljs-params">arr</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    堆排序算法实现。</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">    arr (list): 待排序的数组。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    n = <span class="hljs-built_in">len</span>(arr)  <span class="hljs-comment"># 获取数组长度</span><br><br>    <span class="hljs-comment"># 构建最大堆</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n // <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        heapify(arr, n, i)  <span class="hljs-comment"># 从最后一个非叶子节点开始，向上调整堆</span><br><br>    <span class="hljs-comment"># 交换堆顶元素与最后一个元素，然后重新调整堆</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>        arr[i], arr[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>], arr[i]  <span class="hljs-comment"># 将堆顶元素（最大值）与最后一个元素交换</span><br>        heapify(arr, i, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 重新调整堆，确保堆的性质</span><br><br>    <span class="hljs-keyword">return</span> arr  <span class="hljs-comment"># 返回排序后的数组</span><br></code></pre></td></tr></table></figure><h3 id="实际数字带入代码："><a href="#实际数字带入代码：" class="headerlink" title="实际数字带入代码："></a>实际数字带入代码：</h3><p>假设我们有一个数组<code>arr = [4, 10, 3, 5, 1]</code>，我们使用堆排序对其进行排序。</p><ol><li><p><strong>构建最大堆</strong>：</p><ul><li>初始数组：<code>[4, 10, 3, 5, 1]</code></li><li>调整后：<code>[10, 4, 3, 5, 1]</code>（将前四个元素调整为最大堆）</li><li>继续调整：<code>[10, 5, 3, 4, 1]</code>（继续调整前三个元素）</li></ul></li><li><p><strong>交换堆顶元素与最后一个元素</strong>：</p><ul><li>交换后：<code>[1, 5, 3, 4, 10]</code></li><li>重新调整堆：<code>[5, 1, 3, 4, 10]</code></li></ul></li><li><p><strong>重复步骤2</strong>：</p><ul><li>交换后：<code>[4, 1, 3, 5, 10]</code></li><li>重新调整堆：<code>[4, 1, 3, 5, 10]</code>（已经是有序的）</li></ul></li><li><p><strong>最终结果</strong>：</p><ul><li>排序后的数组：<code>[1, 3, 4, 5, 10]</code></li></ul></li></ol><h3 id="中间涉及到的语法知识点："><a href="#中间涉及到的语法知识点：" class="headerlink" title="中间涉及到的语法知识点："></a>中间涉及到的语法知识点：</h3><ol><li><p><strong>函数定义</strong>：</p><ul><li>使用<code>def</code>关键字定义函数。</li><li>函数名和参数列表。</li></ul></li><li><p><strong>参数传递</strong>：</p><ul><li>函数参数<code>arr</code>, <code>n</code>, <code>i</code>的传递。</li></ul></li><li><p><strong>条件判断</strong>：</p><ul><li>使用<code>if</code>语句进行条件判断。</li></ul></li><li><p><strong>索引计算</strong>：</p><ul><li>计算左子节点和右子节点的索引。</li></ul></li><li><p><strong>变量赋值</strong>：</p><ul><li>使用赋值语句更新变量值。</li></ul></li><li><p><strong>交换元素</strong>：</p><ul><li>使用元组解包进行元素交换：<code>arr[i], arr[largest] = arr[largest], arr[i]</code>。</li></ul></li><li><p><strong>递归调用</strong>：</p><ul><li>函数<code>heapify</code>的递归调用。</li></ul></li><li><p><strong>循环结构</strong>：</p><ul><li>使用<code>for</code>循环进行迭代。</li></ul></li><li><p><strong>数组长度获取</strong>：</p><ul><li>使用<code>len(arr)</code>获取数组长度。</li></ul></li><li><p><strong>数组元素访问</strong>：</p><ul><li>使用索引访问数组元素。</li></ul></li><li><p><strong>数组元素修改</strong>：</p><ul><li>直接通过索引对数组元素进行修改。</li></ul></li><li><p><strong>注释</strong>：</p><ul><li>使用<code>#</code>进行单行注释，使用<code>&quot;&quot;&quot;</code>进行多行注释。</li></ul></li></ol><p>详细讲解可以参考：<a href="https://blog.csdn.net/m0_73096566/article/details/128418046?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172134883916800175788232%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172134883916800175788232&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-128418046-null-null.142%5Ev100%5Epc_search_result_base4&utm_term=%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">姬如祎-十大经典排序算法—-堆排序（超详细）</a></p><h2 id="看抓包方面的资讯"><a href="#看抓包方面的资讯" class="headerlink" title="看抓包方面的资讯"></a>看抓包方面的资讯</h2><h2 id="看SQL-server-2014中sql语句的执行过程"><a href="#看SQL-server-2014中sql语句的执行过程" class="headerlink" title="看SQL server 2014中sql语句的执行过程"></a>看SQL server 2014中sql语句的执行过程</h2>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日事项-2024年7月18日</title>
    <link href="/2024/07/18/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%8818%E6%97%A5/"/>
    <url>/2024/07/18/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%8818%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="今日事项-2024年7月18日"><a href="#今日事项-2024年7月18日" class="headerlink" title="今日事项-2024年7月18日"></a>今日事项-2024年7月18日</h1><h2 id="事项一-看3个实用的算法"><a href="#事项一-看3个实用的算法" class="headerlink" title="事项一 看3个实用的算法"></a>事项一 看3个实用的算法</h2><h3 id="1-单源最短路径（Bellman-Ford-Algorithm）"><a href="#1-单源最短路径（Bellman-Ford-Algorithm）" class="headerlink" title="1. 单源最短路径（Bellman-Ford Algorithm）"></a>1. 单源最短路径（Bellman-Ford Algorithm）</h3><p><img src="/img/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%A4%BA%E4%BE%8B%E5%9B%BE%E7%89%87.png" alt="单源最短路径示例图片" title="单源最短路径示例图片"></p><h4 id="产生原因与背景："><a href="#产生原因与背景：" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你是一名邮递员，需要从邮局出发，递送包裹到城市中的各个角落。单源最短路径算法就像你规划的路线，它帮助你找到从邮局到每个目的地的最短路径，即使有些道路可能会因为修路而暂时封闭。</p><h4 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h4><p>单源最短路径算法就像是一位旅行者在探索一个未知的岛屿，他从起点出发，逐步探索每一条可能的路径，直到确定没有更短的路径可以到达目的地。</p><h4 id="代码案列："><a href="#代码案列：" class="headerlink" title="代码案列："></a>代码案列：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bellman_ford</span>(<span class="hljs-params">graph, source</span>):<br>    <span class="hljs-comment"># 初始化距离数组，所有节点到源点的距离为无穷大，除了源点自身</span><br>    distances = &#123;node: <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>) <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph&#125;<br>    distances[source] = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 重复|V|-1次，其中|V|是顶点数</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph) - <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph:<br>            <span class="hljs-keyword">for</span> neighbor, weight <span class="hljs-keyword">in</span> graph[node].items():<br>                <span class="hljs-comment"># 如果通过当前节点到邻居节点的距离更短，则更新距离</span><br>                new_distance = distances[node] + weight<br>                <span class="hljs-keyword">if</span> new_distance &lt; distances[neighbor]:<br>                    distances[neighbor] = new_distance<br><br>    <span class="hljs-comment"># 检查是否存在负权环</span><br>    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph:<br>        <span class="hljs-keyword">for</span> neighbor, weight <span class="hljs-keyword">in</span> graph[node].items():<br>            <span class="hljs-keyword">if</span> distances[node] + weight &lt; distances[neighbor]:<br>                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Graph contains a negative-weight cycle&quot;</span>)<br><br>    <span class="hljs-keyword">return</span> distances<br><br><span class="hljs-comment"># 使用示例</span><br>graph = &#123;<br>    <span class="hljs-string">&#x27;A&#x27;</span>: &#123;<span class="hljs-string">&#x27;B&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">4</span>&#125;,<br>    <span class="hljs-string">&#x27;B&#x27;</span>: &#123;<span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-number">3</span>&#125;,<br>    <span class="hljs-string">&#x27;C&#x27;</span>: &#123;<span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;E&#x27;</span>: <span class="hljs-number">2</span>&#125;,<br>    <span class="hljs-string">&#x27;D&#x27;</span>: &#123;&#125;,<br>    <span class="hljs-string">&#x27;E&#x27;</span>: &#123;<span class="hljs-string">&#x27;D&#x27;</span>: -<span class="hljs-number">3</span>&#125;<br>&#125;<br>source = <span class="hljs-string">&#x27;A&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Shortest distances from&quot;</span>, source, <span class="hljs-string">&quot;:&quot;</span>, bellman_ford(graph, source))<br></code></pre></td></tr></table></figure><h4 id="算法优缺点："><a href="#算法优缺点：" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：Bellman-Ford算法能够处理图中的负权边，并且能够检测负权环。<br>缺点：算法的时间复杂度为O(|V| * |E|)，在|E|接近|V|^2的稠密图中效率较低。</p><h4 id="解决缺点的方法："><a href="#解决缺点的方法：" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>对于不包含负权边的图，可以使用更高效的算法，如Dijkstra算法。</p><h4 id="解决缺点后的代码案例："><a href="#解决缺点后的代码案例：" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（Dijkstra算法已经在上文中给出）</p><h4 id="算法的3个实际应用案例："><a href="#算法的3个实际应用案例：" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>路网导航</strong>：在存在临时道路施工或通行费变更的情况下，计算最短路径。</li><li><strong>金融分析</strong>：在金融市场中，评估不同投资组合的风险和回报。</li><li><strong>供应链优化</strong>：在存在多种运输成本和时间的情况下，找到成本最低的运输路径。</li></ul><h3 id="2-长路径问题（Longest-Path-Problem）"><a href="#2-长路径问题（Longest-Path-Problem）" class="headerlink" title="2. 长路径问题（Longest Path Problem）"></a>2. 长路径问题（Longest Path Problem）</h3><h4 id="产生原因与背景：-1"><a href="#产生原因与背景：-1" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你是一名探险家，正在探索一个未知的森林，你需要找到一条最长的路径，以便尽可能多地探索森林的每一个角落。长路径问题就像你的探险地图，帮你找到森林中最长的路径。</p><h4 id="算法思路：-1"><a href="#算法思路：-1" class="headerlink" title="算法思路："></a>算法思路：</h4><p>长路径问题就像是一位旅行者在规划他的旅程，他需要考虑所有可能的路线，并选择一条能够覆盖最远距离的路线。</p><h4 id="代码案列：-1"><a href="#代码案列：-1" class="headerlink" title="代码案列："></a>代码案列：</h4><p>略（长路径问题的实现较为复杂，通常涉及图的遍历）</p><h4 id="算法优缺点：-1"><a href="#算法优缺点：-1" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：长路径问题在某些应用中非常有用，如在网络设计中找到最长的通信路径。<br>缺点：长路径问题在某些图中可能非常难以解决，特别是图中存在很多环和交叉路径时。</p><h4 id="解决缺点的方法：-1"><a href="#解决缺点的方法：-1" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>可以通过使用动态规划或图的拓扑排序来解决长路径问题，这些方法可以避免在环中无限循环。</p><h4 id="解决缺点后的代码案例：-1"><a href="#解决缺点后的代码案例：-1" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（实现通常需要特定的图结构和算法）</p><h4 id="算法的3个实际应用案例：-1"><a href="#算法的3个实际应用案例：-1" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>网络设计</strong>：在设计通信网络时，找到最长的通信路径。</li><li><strong>物流规划</strong>：在物流配送中，规划最长的配送路线以覆盖更多的客户。</li><li><strong>游戏设计</strong>：在游戏关卡设计中，找到最长的探索路径以增加游戏的挑战性。</li></ul><h3 id="3-斐波那契数列（Fibonacci-Sequence）"><a href="#3-斐波那契数列（Fibonacci-Sequence）" class="headerlink" title="3. 斐波那契数列（Fibonacci Sequence）"></a>3. 斐波那契数列（Fibonacci Sequence）</h3><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(0)&#x3D;0，F(1)&#x3D;1, F(n)&#x3D;F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）</p><h4 id="产生原因与背景：-2"><a href="#产生原因与背景：-2" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你是一名生物学家，正在研究兔子的繁殖问题。斐波那契数列描述了一对兔子每个月繁殖的后代数量，每个月新生的兔子下个月开始繁殖，直到无穷。</p><h4 id="算法思路：-2"><a href="#算法思路：-2" class="headerlink" title="算法思路："></a>算法思路：</h4><p>斐波那契数列就像是一位园丁在计算植物的生长，每一代植物的数量是前两代植物数量的和。</p><h4 id="代码案列：-2"><a href="#代码案列：-2" class="headerlink" title="代码案列："></a>代码案列：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> n<br>    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>        a, b = b, a + b<br>    <span class="hljs-keyword">return</span> b<br><br><span class="hljs-comment"># 使用示例</span><br>n = <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The 10th Fibonacci number is:&quot;</span>, fibonacci(n))<br></code></pre></td></tr></table></figure><h4 id="算法优缺点：-2"><a href="#算法优缺点：-2" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：斐波那契数列的递归实现非常直观，易于理解。<br>缺点：递归实现在计算大的n时效率较低，因为有很多重复计算。</p><h4 id="解决缺点的方法：-2"><a href="#解决缺点的方法：-2" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>使用动态规划方法，通过存储已经计算过的斐波那契数来避免重复计算。</p><h4 id="解决缺点后的代码案例：-2"><a href="#解决缺点后的代码案例：-2" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci_dp</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> n<br>    fib_numbers = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>] + [<span class="hljs-number">0</span>] * (n - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>        fib_numbers[i] = fib_numbers[i - <span class="hljs-number">1</span>] + fib_numbers[i - <span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">return</span> fib_numbers[n]<br><br><span class="hljs-comment"># 使用示例</span><br>n = <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The 10th Fibonacci number is:&quot;</span>, fibonacci_dp(n))<br></code></pre></td></tr></table></figure><h4 id="算法的3个实际应用案例：-2"><a href="#算法的3个实际应用案例：-2" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>计算机算法竞赛</strong>：在解决优化问题时，经常需要计算斐波那契数列。</li><li><strong>金融数学</strong>：在某些金融模型中，斐波那契数列用于预测市场趋势。</li><li><strong>生物信息学</strong>：在DNA序列分析中，斐波那契数列用于描述某些生物过程。</li></ul><h2 id="事项二-吃透-快速幂算法"><a href="#事项二-吃透-快速幂算法" class="headerlink" title="事项二 吃透 快速幂算法"></a>事项二 吃透 快速幂算法</h2><p>通过一个具体的例子来演示这个快速幂算法的代码是如何工作的。假设我们要计算[2^{10}]。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">Fast_Pow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>; <span class="hljs-comment">/* 初始化结果为1 */</span><br>    <span class="hljs-keyword">while</span> (b) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) &#123;       <span class="hljs-comment">/* 判断b是否为奇数 */</span><br>            result *= a;   <span class="hljs-comment">/* 如果b是奇数，将a乘以当前的结果 */</span><br>        &#125;<br>        a *= a;            <span class="hljs-comment">/* a的值是其自身的平方 */</span><br>        b &gt;&gt;= <span class="hljs-number">1</span>;           <span class="hljs-comment">/* 将b右移一位，相当于b = b / 2 */</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> result;        <span class="hljs-comment">/* 返回计算结果 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="计算过程："><a href="#计算过程：" class="headerlink" title="计算过程："></a>计算过程：</h3><ol><li><p><strong>初始状态</strong>：</p><ul><li>( a &#x3D; 2 )</li><li>( b &#x3D; 10 )</li><li>( result &#x3D; 1 )</li></ul></li><li><p><strong>第一次循环</strong>：</p><ul><li>( b &#x3D; 10 )（二进制为1010）</li><li>( b &amp; 1 &#x3D; 0 )（不是奇数，不执行乘法）</li><li>( a &#x3D; 2 * 2 &#x3D; 4 )</li><li>( b &#x3D; 10 )右移一位 &#x3D; ( 5 )（二进制为101）</li></ul></li><li><p><strong>第二次循环</strong>：</p><ul><li>( b &#x3D; 5 )（二进制为101）</li><li>( b &amp; 1 &#x3D; 1 )（是奇数，执行乘法）</li><li>( result &#x3D; 1 * 4 &#x3D; 4 )</li><li>( a &#x3D; 4 * 4 &#x3D; 16 )</li><li>( b &#x3D; 5 )右移一位 &#x3D; ( 2 )（二进制为10）</li></ul></li><li><p><strong>第三次循环</strong>：</p><ul><li>( b &#x3D; 2 )（二进制为10）</li><li>( b &amp; 1 &#x3D; 0 )（不是奇数，不执行乘法）</li><li>( a &#x3D; 16 * 16 &#x3D; 256 )</li><li>( b &#x3D; 2 )右移一位 &#x3D; ( 1 )（二进制为1）</li></ul></li><li><p><strong>第四次循环</strong>：</p><ul><li>( b &#x3D; 1 )（二进制为1）</li><li>( b &amp; 1 &#x3D; 1 )（是奇数，执行乘法）</li><li>( result &#x3D; 4 * 256 &#x3D; 1024 )</li><li>( a &#x3D; 256 * 256 )（这一步在循环结束后执行，不影响结果）</li><li>( b &#x3D; 1 )右移一位 &#x3D; ( 0 )（循环结束）</li></ul></li></ol><h3 id="最终结果："><a href="#最终结果：" class="headerlink" title="最终结果："></a>最终结果：</h3><ul><li>( result &#x3D; 1024 )，这就是[2^{10}]的结果。</li></ul><p>通过这种方式，快速幂算法有效地减少了乘法的次数，从而提高了计算的效率。</p><h3 id="涉及到的知识点"><a href="#涉及到的知识点" class="headerlink" title="涉及到的知识点"></a>涉及到的知识点</h3><p>这段代码中涉及到的语法知识点主要包括以下几点：</p><ol><li><p><strong>函数定义</strong>：</p><ul><li>使用<code>def</code>关键字定义函数。</li><li>函数名<code>Fast_Pow</code>，参数列表<code>(long long a, long long b)</code>。</li></ul></li><li><p><strong>数据类型</strong>：</p><ul><li><code>long long</code>：在C&#x2F;C++中，<code>long long</code>是一种64位整数类型，用于存储大整数。</li></ul></li><li><p><strong>变量声明与初始化</strong>：</p><ul><li><code>long long result = 1;</code>：声明并初始化一个<code>long long</code>类型的变量<code>result</code>，初始值为1。</li></ul></li><li><p><strong>循环结构</strong>：</p><ul><li><code>while (b)</code>：一个无限循环，条件是<code>b</code>非零。当<code>b</code>为零时，循环结束。</li></ul></li><li><p><strong>位运算</strong>：</p><ul><li><code>b &amp; 1</code>：位与运算，用于判断<code>b</code>的最后一位是否为1，即判断<code>b</code>是否为奇数。</li><li><code>b &gt;&gt;= 1</code>：位右移运算，将<code>b</code>的二进制表示向右移动一位，相当于将<code>b</code>除以2。</li></ul></li><li><p><strong>条件判断</strong>：</p><ul><li><code>if</code>语句：用于条件判断。如果条件为真，则执行<code>if</code>块内的代码。</li></ul></li><li><p><strong>乘法运算</strong>：</p><ul><li><code>result *= a;</code>：乘法赋值运算符，相当于<code>result = result * a;</code>。</li></ul></li><li><p><strong>赋值运算</strong>：</p><ul><li><code>a *= a;</code>：赋值运算符，用于将<code>a</code>的平方赋值给<code>a</code>。</li></ul></li><li><p><strong>递归调用</strong>：</p><ul><li>尽管这段代码本身不是递归实现的，但快速幂算法的递归实现会涉及递归调用，即函数调用自身。</li></ul></li><li><p><strong>返回值</strong>：</p><ul><li><code>return result;</code>：结束函数，并将结果返回给调用者。</li></ul></li><li><p><strong>注释</strong>：</p><ul><li>使用<code>/*</code>和<code>*/</code>进行多行注释，或者使用<code>//</code>进行单行注释。</li></ul></li></ol><p>这些知识点是理解和实现快速幂算法的基础，也是C&#x2F;C++编程中常用的语法和概念。</p>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日事项-2024年7月17日</title>
    <link href="/2024/07/17/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%8817%E6%97%A5/"/>
    <url>/2024/07/17/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%8817%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="今日事项-2024年7月17日"><a href="#今日事项-2024年7月17日" class="headerlink" title="今日事项-2024年7月17日"></a>今日事项-2024年7月17日</h1><h2 id="事项一-看三个实用的算法"><a href="#事项一-看三个实用的算法" class="headerlink" title="事项一 看三个实用的算法"></a>事项一 看三个实用的算法</h2><h3 id="1-快速幂（Fast-Exponentiation）"><a href="#1-快速幂（Fast-Exponentiation）" class="headerlink" title="1. 快速幂（Fast Exponentiation）"></a>1. 快速幂（Fast Exponentiation）</h3><h4 id="产生原因与背景："><a href="#产生原因与背景：" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你需要计算一个非常大的数的幂，如果直接计算，可能会非常耗时。快速幂算法通过将指数分解为更小的乘积，然后逐步计算，大大提高了计算效率。</p><h4 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h4><p>快速幂就像是一位数学家在计算大数的幂，他发现可以将一个大任务分解为几个小任务，然后并行计算这些小任务的结果，最后将结果组合起来。</p><h4 id="代码案列："><a href="#代码案列：" class="headerlink" title="代码案列："></a>代码案列：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fast_exponentiation</span>(<span class="hljs-params">base, exponent</span>):<br>    <span class="hljs-comment"># 初始化结果为1</span><br>    result = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> exponent &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 如果指数是奇数，将底数乘到结果中</span><br>        <span class="hljs-keyword">if</span> exponent % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>            result *= base<br>        <span class="hljs-comment"># 将底数平方</span><br>        base *= base<br>        <span class="hljs-comment"># 指数除以2</span><br>        exponent //= <span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-comment"># 使用示例</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;2 raised to the power of 10 is:&quot;</span>, fast_exponentiation(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><h4 id="算法优缺点："><a href="#算法优缺点：" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：快速幂算法可以将大数幂的计算时间从O(n)降低到O(log n)。<br>缺点：快速幂算法在处理非常大的指数时，仍然需要较多的计算步骤。</p><h4 id="解决缺点的方法："><a href="#解决缺点的方法：" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>可以通过进一步的优化，如使用矩阵快速幂或分治法来减少计算步骤。</p><h4 id="解决缺点后的代码案例："><a href="#解决缺点后的代码案例：" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（快速幂的优化实现较为复杂）</p><h4 id="算法的3个实际应用案例："><a href="#算法的3个实际应用案例：" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>密码学</strong>：在公钥密码学中，快速计算大数幂用于加密和解密。</li><li><strong>计算机图形学</strong>：在图形变换中，快速计算矩阵的幂用于实现复杂的变换。</li><li><strong>科学计算</strong>：在物理学或工程学中，快速计算大数幂用于模拟和预测。</li></ul><h3 id="2-贝叶斯推断（Bayesian-Inference）"><a href="#2-贝叶斯推断（Bayesian-Inference）" class="headerlink" title="2. 贝叶斯推断（Bayesian Inference）"></a>2. 贝叶斯推断（Bayesian Inference）</h3><h4 id="产生原因与背景：-1"><a href="#产生原因与背景：-1" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你是一位医生，根据病人的症状来推断可能的疾病。贝叶斯推断就像你根据先验知识（疾病的普遍性）和新证据（病人的症状）来更新对疾病可能性的估计。</p><h4 id="算法思路：-1"><a href="#算法思路：-1" class="headerlink" title="算法思路："></a>算法思路：</h4><p>贝叶斯推断就像是一位侦探，他根据已有的线索（先验概率）和新发现的证据（数据），不断更新对嫌疑人的怀疑程度。</p><h4 id="代码案列：-1"><a href="#代码案列：-1" class="headerlink" title="代码案列："></a>代码案列：</h4><p>略（贝叶斯推断的实现较为复杂，通常涉及概率论和统计学）</p><h4 id="算法优缺点：-1"><a href="#算法优缺点：-1" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：贝叶斯推断能够利用先验知识和新证据来更新对未知参数的估计，适用于各种不确定性情况下的推理。<br>缺点：贝叶斯推断可能需要复杂的数学计算，特别是在先验分布和似然函数不简单的情况下。</p><h4 id="解决缺点的方法：-1"><a href="#解决缺点的方法：-1" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>使用简化的模型或近似方法来减少计算复杂度，或者利用现代计算工具和软件库来处理复杂的贝叶斯模型。</p><h4 id="解决缺点后的代码案例：-1"><a href="#解决缺点后的代码案例：-1" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（贝叶斯推断的实现通常需要特定的统计模型和计算方法）</p><h4 id="算法的3个实际应用案例：-1"><a href="#算法的3个实际应用案例：-1" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>医疗诊断</strong>：根据病人的症状和历史数据，推断最可能的疾病。</li><li><strong>垃圾邮件过滤</strong>：根据邮件的内容和特征，判断邮件是否为垃圾邮件。</li><li><strong>机器故障预测</strong>：根据机器的运行数据和历史故障记录，预测机器的故障概率。</li></ul><h3 id="3-遗传算法（Genetic-Algorithm）"><a href="#3-遗传算法（Genetic-Algorithm）" class="headerlink" title="3. 遗传算法（Genetic Algorithm）"></a>3. 遗传算法（Genetic Algorithm）</h3><h4 id="产生原因与背景：-2"><a href="#产生原因与背景：-2" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你是一位农场主，想要培育出最佳的作物品种，你选择那些具有最佳特性的作物进行繁殖，同时引入一些变异，希望得到更好的后代。</p><h4 id="算法思路：-2"><a href="#算法思路：-2" class="headerlink" title="算法思路："></a>算法思路：</h4><p>遗传算法就像是一位园丁，他通过选择、交叉和变异等操作，不断优化植物的品种，以期望培育出具有理想特性的新品种。</p><h4 id="代码案列：-2"><a href="#代码案列：-2" class="headerlink" title="代码案列："></a>代码案列：</h4><p>略（遗传算法的实现较为复杂，通常涉及模拟进化过程）</p><h4 id="算法优缺点：-2"><a href="#算法优缺点：-2" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：遗传算法是一种启发式搜索算法，适用于解决复杂的优化问题，特别是那些难以用传统方法解决的问题。<br>缺点：遗传算法可能需要较长的时间来找到最优解，且结果可能依赖于初始种群的选择和算法参数的设置。</p><h4 id="解决缺点的方法：-2"><a href="#解决缺点的方法：-2" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>可以通过调整遗传算法的参数，如交叉率、变异率和选择策略，来优化算法性能。此外，使用并行计算或分布式计算可以加快搜索过程。</p><h4 id="解决缺点后的代码案例：-2"><a href="#解决缺点后的代码案例：-2" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（遗传算法的实现通常需要特定的优化问题和搜索策略）</p><h4 id="算法的3个实际应用案例：-2"><a href="#算法的3个实际应用案例：-2" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>调度问题</strong>：在资源和时间受限的情况下，优化任务的调度顺序。</li><li><strong>电路设计</strong>：在电路板设计中，优化组件的布局以减少制造成本。</li><li><strong>机器学习</strong>：在特征选择和模型优化中，搜索最优的特征组合或模型参数。</li></ul><h2 id="事项二-更新培训计划文档、跟进需求调研进度"><a href="#事项二-更新培训计划文档、跟进需求调研进度" class="headerlink" title="事项二 更新培训计划文档、跟进需求调研进度"></a>事项二 更新培训计划文档、跟进需求调研进度</h2><h2 id="事项三-更新WMS使用手册"><a href="#事项三-更新WMS使用手册" class="headerlink" title="事项三 更新WMS使用手册"></a>事项三 更新WMS使用手册</h2>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日事项-2024年7月16日</title>
    <link href="/2024/07/16/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%8816%E6%97%A5/"/>
    <url>/2024/07/16/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%8816%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="今日事项-2024年7月16日"><a href="#今日事项-2024年7月16日" class="headerlink" title="今日事项-2024年7月16日"></a>今日事项-2024年7月16日</h1><h2 id="事项一-RESTful-接口设计"><a href="#事项一-RESTful-接口设计" class="headerlink" title="事项一 RESTful 接口设计"></a>事项一 RESTful 接口设计</h2><p>RESTful 接口设计是一种基于 REST（Representational State Transfer，表现层状态转移）原则的网络服务设计方法。RESTful API 允许客户端通过网络与服务器进行交互，获取或发送数据。以下是 RESTful 接口设计的一些关键概念和最佳实践：</p><h3 id="1-资源（Resources）"><a href="#1-资源（Resources）" class="headerlink" title="1. 资源（Resources）"></a>1. 资源（Resources）</h3><ul><li><strong>定义</strong>：RESTful 接口中的资源是服务器上可被识别的任何东西，通常是数据对象，如用户、文章、图片等。</li><li><strong>URI</strong>：每个资源都有一个唯一的标识符，通常是一个 URI（统一资源标识符）。</li></ul><h3 id="2-资源的表述（Representations）"><a href="#2-资源的表述（Representations）" class="headerlink" title="2. 资源的表述（Representations）"></a>2. 资源的表述（Representations）</h3><ul><li><strong>定义</strong>：资源的表述是资源的序列化形式，如 JSON、XML 等。客户端通过表述来读取或修改资源的状态。</li><li><strong>标准</strong>：表述应遵循一定的媒体类型标准，如 <code>application/json</code>。</li></ul><h3 id="3-HTTP-方法"><a href="#3-HTTP-方法" class="headerlink" title="3. HTTP 方法"></a>3. HTTP 方法</h3><ul><li><strong>GET</strong>：读取资源。</li><li><strong>POST</strong>：创建新资源。</li><li><strong>PUT</strong>：更新现有资源或创建新资源。</li><li><strong>DELETE</strong>：删除资源。</li><li><strong>PATCH</strong>：部分更新资源。</li><li><strong>HEAD</strong>：获取资源的元数据（如 HTTP 头信息）。</li></ul><h3 id="4-无状态（Stateless）"><a href="#4-无状态（Stateless）" class="headerlink" title="4. 无状态（Stateless）"></a>4. 无状态（Stateless）</h3><ul><li><strong>定义</strong>：每个请求从客户端到服务器必须是自包含的，服务器不会存储任何会话状态。</li><li><strong>好处</strong>：提高了可伸缩性和简化了服务器设计。</li></ul><h3 id="5-统一接口（Uniform-Interface）"><a href="#5-统一接口（Uniform-Interface）" class="headerlink" title="5. 统一接口（Uniform Interface）"></a>5. 统一接口（Uniform Interface）</h3><ul><li><strong>定义</strong>：统一接口是 REST 的核心约束之一，要求接口在操作资源时使用统一的方法。</li><li><strong>组成</strong>：资源的标识、对资源的操作（HTTP 方法）、自描述的表述、超媒体驱动的应用程序状态（HATEOAS）。</li></ul><h3 id="6-代码重用（Code-On-Demand，可选）"><a href="#6-代码重用（Code-On-Demand，可选）" class="headerlink" title="6. 代码重用（Code On Demand，可选）"></a>6. 代码重用（Code On Demand，可选）</h3><ul><li><strong>定义</strong>：服务器可以按需向客户端提供执行代码，以便客户端执行一些处理逻辑。</li><li><strong>使用</strong>：不常用，但在某些情况下可以提高效率。</li></ul><h3 id="7-超媒体即应用状态（HATEOAS）"><a href="#7-超媒体即应用状态（HATEOAS）" class="headerlink" title="7. 超媒体即应用状态（HATEOAS）"></a>7. 超媒体即应用状态（HATEOAS）</h3><ul><li><strong>定义</strong>：客户端通过服务器提供的超媒体链接来发现所有可用的动作。</li><li><strong>实现</strong>：响应中应包含链接到其他资源的 URI，允许客户端在无需预设知识的情况下导航。</li></ul><h3 id="8-错误处理"><a href="#8-错误处理" class="headerlink" title="8. 错误处理"></a>8. 错误处理</h3><ul><li><strong>定义</strong>：服务器应返回适当的 HTTP 状态码来表示请求的结果。</li><li><strong>实现</strong>：使用 4xx 状态码表示客户端错误，5xx 状态码表示服务器错误。</li></ul><h3 id="9-安全性"><a href="#9-安全性" class="headerlink" title="9. 安全性"></a>9. 安全性</h3><ul><li><strong>定义</strong>：RESTful 接口应考虑安全性，使用 HTTPS、认证和授权机制来保护数据。</li><li><strong>实现</strong>：常见的认证机制包括 Basic Auth、OAuth、JWT（JSON Web Tokens）等。</li></ul><h3 id="10-版本控制"><a href="#10-版本控制" class="headerlink" title="10. 版本控制"></a>10. 版本控制</h3><ul><li><strong>定义</strong>：随着 API 的发展，可能需要引入新版本。</li><li><strong>实现</strong>：通常通过 URI、请求头或媒体类型来区分不同版本的 API。</li></ul><h3 id="11-性能"><a href="#11-性能" class="headerlink" title="11. 性能"></a>11. 性能</h3><ul><li><strong>定义</strong>：设计 RESTful 接口时，应考虑性能和响应时间。</li><li><strong>实现</strong>：使用缓存、压缩和分页等技术来提高性能。</li></ul><h3 id="12-文档和示例"><a href="#12-文档和示例" class="headerlink" title="12. 文档和示例"></a>12. 文档和示例</h3><ul><li><strong>定义</strong>：提供清晰的 API 文档和使用示例，帮助开发者理解和使用 API。</li><li><strong>工具</strong>：可以使用 Swagger（OpenAPI）或 Postman 等工具来生成和维护文档。</li></ul><p>通过遵循这些原则和最佳实践，你可以设计出易于使用、可维护和可扩展的 RESTful 接口。这不仅提高了 API 的用户体验，而且有助于构建健壮的应用程序和服务。</p>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日事项-2024年7月15日</title>
    <link href="/2024/07/15/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%8815%E6%97%A5/"/>
    <url>/2024/07/15/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%8815%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="今日事项-2024年7月15日"><a href="#今日事项-2024年7月15日" class="headerlink" title="今日事项-2024年7月15日"></a>今日事项-2024年7月15日</h1><h2 id="事项一-学习3个实用的算法"><a href="#事项一-学习3个实用的算法" class="headerlink" title="事项一 学习3个实用的算法"></a>事项一 学习3个实用的算法</h2><h3 id="1-桶排序（Bucket-Sort）"><a href="#1-桶排序（Bucket-Sort）" class="headerlink" title="1. 桶排序（Bucket Sort）"></a>1. 桶排序（Bucket Sort）</h3><p><img src="/img/%E6%A1%B6%E6%8E%92%E5%BA%8F.png" alt="桶排序的图片" title="桶排序示例图片"></p><h4 id="产生原因与背景："><a href="#产生原因与背景：" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你是一位酒吧老板，在晚上高峰时段，顾客点了很多不同种类的鸡尾酒。为了快速服务，你根据酒的种类将订单分开处理，每种酒一个桶，这样可以同时准备多种酒，提高效率。</p><h4 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h4><p>桶排序就像是一位DJ在组织音乐派对，他根据音乐的节奏和风格将歌曲分类，然后按顺序播放每个类别的歌曲，确保派对的流畅进行。</p><h4 id="代码案列："><a href="#代码案列：" class="headerlink" title="代码案列："></a>代码案列：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bucket_sort</span>(<span class="hljs-params">arr</span>):<br>    <span class="hljs-comment"># 创建桶，数量为数组长度</span><br>    buckets = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr))]<br>    <br>    <span class="hljs-comment"># 将每个元素分配到对应的桶中</span><br>    <span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> arr:<br>        index = number * <span class="hljs-built_in">len</span>(arr) // (<span class="hljs-built_in">max</span>(arr) + <span class="hljs-number">1</span>)<br>        buckets[index].append(number)<br>    <br>    <span class="hljs-comment"># 对每个桶进行排序（这里使用内置的sorted函数）</span><br>    <span class="hljs-keyword">for</span> bucket <span class="hljs-keyword">in</span> buckets:<br>        sorted_bucket = <span class="hljs-built_in">sorted</span>(bucket)<br>    <br>    <span class="hljs-comment"># 合并桶中的元素</span><br>    sorted_array = []<br>    <span class="hljs-keyword">for</span> bucket <span class="hljs-keyword">in</span> buckets:<br>        sorted_array.extend(sorted_bucket)<br>    <br>    <span class="hljs-keyword">return</span> sorted_array<br><br><span class="hljs-comment"># 使用示例</span><br>arr = [<span class="hljs-number">0.3</span>, <span class="hljs-number">2.9</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">2.2</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Sorted array:&quot;</span>, bucket_sort(arr))<br></code></pre></td></tr></table></figure><h4 id="算法优缺点："><a href="#算法优缺点：" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：桶排序在元素分布均匀时非常高效，时间复杂度可以达到线性级别，O(n+k)。<br>缺点：如果元素分布不均匀，某些桶可能会非常拥挤，导致排序效率降低。</p><h4 id="解决缺点的方法："><a href="#解决缺点的方法：" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>可以通过优化桶的分配策略或使用其他排序算法（如快速排序）来对每个桶内元素进行排序。</p><h4 id="解决缺点后的代码案例："><a href="#解决缺点后的代码案例：" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（代码示例已经展示了桶排序的基本思想）</p><h4 id="算法的3个实际应用案例："><a href="#算法的3个实际应用案例：" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>数据处理</strong>：在处理大量数据时，根据数据的特征快速分类。</li><li><strong>股票市场分析</strong>：根据股票的价格范围快速排序。</li><li><strong>文件系统</strong>：在文件系统中，根据文件的类型或大小快速排序。</li></ul><h3 id="2-RANSAC-算法（Random-Sample-Consensus）随机抽样共识"><a href="#2-RANSAC-算法（Random-Sample-Consensus）随机抽样共识" class="headerlink" title="2. RANSAC 算法（Random Sample Consensus）随机抽样共识"></a>2. RANSAC 算法（Random Sample Consensus）随机抽样共识</h3><p><img src="/img/%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7%E4%B8%80%E8%87%B4%E7%AE%97%E6%B3%95.png" alt="随机抽样一致算法的图片" title="随机抽样一致算法示例图片"></p><h4 id="产生原因与背景：-1"><a href="#产生原因与背景：-1" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你是一位考古学家，正在分析一组数据，这些数据中包含了真实考古发现的测量值和一些由于人为错误或自然变异产生的异常值。RANSAC 算法就是用来从这些数据中估计出最佳模型参数，同时忽略那些异常值。</p><h4 id="算法思路：-1"><a href="#算法思路：-1" class="headerlink" title="算法思路："></a>算法思路：</h4><p>RANSAC 算法就像是一位侦探，在一系列证据中识别出真实的线索，忽略那些伪造或无关的证据。它随机选择一些数据点作为模型的初始估计，然后不断迭代，每次都选择与当前模型最吻合的数据子集。</p><h4 id="代码案列：-1"><a href="#代码案列：-1" class="headerlink" title="代码案列："></a>代码案列：</h4><p>略（RANSAC 算法的实现较为复杂，通常涉及迭代模型拟合和异常值检测）</p><h4 id="算法优缺点：-1"><a href="#算法优缺点：-1" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：RANSAC 算法非常适合于存在异常值的数据集，能够鲁棒地估计出模型参数。<br>缺点：RANSAC 算法可能需要多次迭代才能找到最佳模型，且在某些情况下可能收敛到局部最优解。</p><h4 id="解决缺点的方法：-1"><a href="#解决缺点的方法：-1" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>可以通过设置合理的迭代次数和阈值来提高算法的稳定性和准确性。此外，与其他算法（如LMS或TLS）结合使用，以提高模型估计的鲁棒性。</p><h4 id="解决缺点后的代码案例：-1"><a href="#解决缺点后的代码案例：-1" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（RANSAC 算法的实现通常需要特定的模型拟合和异常值检测方法）</p><h4 id="算法的3个实际应用案例：-1"><a href="#算法的3个实际应用案例：-1" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><p>计算机视觉：在图像中检测直线或曲线，忽略图像噪声和遮挡。<br>信号处理：在信号中估计趋势线或周期性，忽略随机噪声。<br>机器学习：在训练数据集中存在异常值时，估计模型参数。</p><h3 id="3-字符串匹配的KMP算法（Knuth-Morris-Pratt-Algorithm）"><a href="#3-字符串匹配的KMP算法（Knuth-Morris-Pratt-Algorithm）" class="headerlink" title="3. 字符串匹配的KMP算法（Knuth-Morris-Pratt Algorithm）"></a>3. 字符串匹配的KMP算法（Knuth-Morris-Pratt Algorithm）</h3><p><img src="/img/%E7%9C%9F%E5%89%8D%E7%BC%80%E7%9C%9F%E5%90%8E%E7%BC%80.png" alt="真前缀真后缀的图片" title="真前缀真后缀的图片"></p><h4 id="产生原因与背景：-2"><a href="#产生原因与背景：-2" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你是一位侦探，需要在一份长文本中查找特定的关键词。如果逐个字符比较，效率会很低。KMP算法通过预处理模式字符串，构建一个部分匹配表，从而在主字符串中快速定位模式字符串的位置。</p><h4 id="算法思路：-2"><a href="#算法思路：-2" class="headerlink" title="算法思路："></a>算法思路：</h4><p>KMP算法就像是一位熟练的打字员，他能够记住自己打的每个词，一旦发现错误，他可以直接跳到下一个可能正确的位置，而不是从错误的地方重新开始。</p><h4 id="代码案列：-2"><a href="#代码案列：-2" class="headerlink" title="代码案列："></a>代码案列：</h4><p>略（KMP算法的实现较为复杂，通常涉及前缀函数的构建）</p><h4 id="算法优缺点：-2"><a href="#算法优缺点：-2" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：KMP算法在字符串匹配中非常高效，特别是对于长文本和重复模式，其时间复杂度为O(n+m)，其中n是主字符串长度，m是模式字符串长度。<br>缺点：KMP算法的预处理步骤需要额外的时间和空间来构建部分匹配表。</p><h4 id="解决缺点的方法：-2"><a href="#解决缺点的方法：-2" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>预处理步骤是必要的，但可以通过优化数据结构和算法来减少资源消耗。</p><h4 id="解决缺点后的代码案例：-2"><a href="#解决缺点后的代码案例：-2" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（KMP算法的实现通常需要特定的数据结构）</p><h4 id="算法的3个实际应用案例：-2"><a href="#算法的3个实际应用案例：-2" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>文本编辑器</strong>：在文本编辑器中，快速查找和替换文本。</li><li><strong>搜索引擎</strong>：在海量数据中快速定位关键词。</li><li><strong>网络安全</strong>：检测网络流量中的恶意模式或代码。</li></ul><h2 id="事项二-Net-8-0-新的变化"><a href="#事项二-Net-8-0-新的变化" class="headerlink" title="事项二 .Net 8.0 新的变化"></a>事项二 .Net 8.0 新的变化</h2><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><p> .NET 8 是微软于2021年8月24日宣布的下一代编程语言和框架，它是 .NET 宇宙的一部分，与 C# (Common Language Infrastructure) 紧密集成。.NET 8 引入了许多新功能，如原生编译、值类型 (Value Types)、结构化并发 (structured concurrency) 和快速数组 (RapidArray)。.NET 8 还支持本机 (native) AOT (Ahead-Of-Time) 编译，以提高性能和启动速度。</p><pre><code class="hljs">    .NET 8 是 Microsoft 发布的最新一代 .NET 框架，它引入了许多新功能和改进，旨在提高性能、可扩展性和开发效率。</code></pre><h3 id="NET-8-的主要亮点："><a href="#NET-8-的主要亮点：" class="headerlink" title=".NET 8 的主要亮点："></a>.NET 8 的主要亮点：</h3><pre><code class="hljs">    1、性能提升：.NET 8 引入了名为“性能计数器”的新功能，可帮助开发人员了解应用程序的性能瓶颈，并采取相应的优化措施。此外，.NET 8 还对许多现有的组件和库进行了优化，以提高应用程序的整体性能。    2、新的异步编程模型：.NET 8 引入了名为“协程”的新的异步编程模型，它可以更自然地处理异步操作和长时间运行的任务。协程可以在同一个线程上执行多个异步操作，从而避免了线程切换和上下文切换的开销。    3、云原生支持：.NET 8 提供了更好的云原生支持，可以更轻松地将应用程序部署到 Kubernetes 等容器化平台中。.NET 8 还支持使用 Docker 等容器化工具打包和分发应用程序。    4、新的开发工具：.NET 8 引入了新的开发工具，如 R#”、Visual Studio Code“ 和 Visual Studio IDE 等，这些工具可以帮助开发人员更高效地编写、调试和测试代码。    5、跨平台支持：.NET 8 可以在多个平台上运行，包括 Windows、macOS 和 Linux 等操作系统。此外，.NET 8 还支持在移动设备、Web 应用程序和游戏开发等领域中使用。    6、人工智能和机器学习：.NET 8 内置了对人工智能和机器学习的支持，可以更轻松地使用这些技术来构建智能应用程序。    7、安全性改进：.NET 8 对安全性进行了改进，包括更好的代码签名和加密技术、对 .NET 反射的限制、对代码访问控制的改进等。    .NET 8 为开发人员提供了许多新功能和改进，可以帮助他们更高效地编写高质量的应用程序。</code></pre><h3 id="NET-8-中引入的一些主要功能和改进："><a href="#NET-8-中引入的一些主要功能和改进：" class="headerlink" title=".NET 8 中引入的一些主要功能和改进："></a>.NET 8 中引入的一些主要功能和改进：</h3><pre><code class="hljs">    1、性能优化：.NET 8 引入了名为“JIT-Chains”的全新技术，它可以将多个热点方法组合在一起，以减少 JIT 编译的开销。此外，.NET 8 还优化了垃圾回收器的性能，提高了堆内存的压缩速度和效率。    2、容器化：.NET 8 支持容器化应用，可以将应用打包成 Docker 镜像并在任何支持 Docker 的平台上运行。这使得应用更容易部署和扩展，并且可以与其他容器化应用集成。    3、多平台支持：.NET 8 可以在 Linux、macOS 和 Windows 平台上运行，并且支持 ARM64 和 ARMv7 架构，这意味着可以在各种设备和应用程序中使用 .NET 8。    4、新增语言功能：.NET 8 支持 C# 10 和 VB.NET 16，这些语言版本引入了许多新功能和改进，如记录模式、switch表达式、模式匹配、记录类型、可变性和局部类型参数等。    5、云原生应用支持：.NET 8 支持 Kubernetes 和云原生应用的其他组件，如服务网格、StatefulSet 等，这使得 .NET 8 更适合构建云原生应用。    6、数据库连接：.NET 8 引入了新的数据库连接 API，可以更轻松地连接各种数据库，如 MySQL、PostgreSQL 和 SQL Server 等。    7、Web API 改进：.NET 8 对 Web API 进行了改进，可以更轻松地创建 RESTful API，并且支持异步和同步请求处理。    总之，.NET 8 引入了许多新功能和改进，旨在提高性能、可扩展性和开发效率，使其成为构建现代应用程序的一个强大框架。</code></pre><h4 id="NET-8-与-NET-7-相比："><a href="#NET-8-与-NET-7-相比：" class="headerlink" title=".NET 8 与.NET 7 相比："></a>.NET 8 与.NET 7 相比：</h4><pre><code class="hljs">    主要区别在于性能优化、容器化、多平台支持、语言功能、云原生应用支持、数据库连接和 Web API 改进等方面。.NET 8 在这些方面进行了升级和改进，旨在提高性能、可扩展性和开发效率。</code></pre><h3 id="NET8对比-NET："><a href="#NET8对比-NET：" class="headerlink" title=".NET8对比.NET："></a>.NET8对比.NET：</h3><pre><code class="hljs">    性能优化：.NET 8 引入了 JIT-Chains 技术，将多个热点方法组合在一起，以减少 JIT 编译的开销。此外，.NET 8 还优化了垃圾回收器的性能，提高了堆内存的压缩速度和效率。    容器化：.NET 8 支持容器化应用，可以将应用打包成 Docker 镜像并在任何支持 Docker 的平台上运行。这使得应用更容易部署和扩展，并且可以与其他容器化应用集成。    多平台支持：.NET 8 可以在 Linux、macOS 和 Windows 平台上运行，并且支持 ARM64 和 ARMv7 架构，这意味着可以在各种设备和应用程序中使用 .NET 8。    语言功能：.NET 8 支持 C# 10 和 VB.NET 16，这些语言版本引入了许多新功能和改进，如记录模式、switch 表达式、模式匹配、记录类型、可变性和局部类型参数等。    云原生应用支持：.NET 8 支持 Kubernetes 和云原生应用的其他组件，如服务网格、StatefulSet 等，这使得 .NET 8 更适合构建云原生应用。    数据库连接：.NET 8 引入了新的数据库连接 API，可以更轻松地连接各种数据库，如 MySQL、PostgreSQL 和 SQL Server 等。</code></pre><h3 id="新功能："><a href="#新功能：" class="headerlink" title="新功能："></a>新功能：</h3><h4 id="1-本机-AOT"><a href="#1-本机-AOT" class="headerlink" title="1.本机 AOT"></a>1.本机 AOT</h4><pre><code class="hljs">    发布为本机AOT的选项最初是在.NET 7中引入的。使用本机AOT发布应用会创建一个完全独立的应用版本，该版本不需要运行时，所有内容都包含在一个文件中。    .NET8 添加了对 macOS 上的 x64 和 Arm64 体系结构的支持。此外，Linux 上本机 AOT 应用的大小现在最多可缩小 50%。</code></pre><h4 id="2-代码生成"><a href="#2-代码生成" class="headerlink" title="2.代码生成"></a>2.代码生成</h4><pre><code class="hljs">.NET 8 包括对代码生成和实时 (JIT) 编译的改进：Arm64 性能改进SIMD 改进云原生改进按配置优化 (PGO) 改进支持 AVX-512 ISA 扩展JIT 吞吐量改进循环和常规优化</code></pre><h4 id="3-在-Linux-上生成你自己的-NET"><a href="#3-在-Linux-上生成你自己的-NET" class="headerlink" title="3.在 Linux 上生成你自己的 .NET"></a>3.在 Linux 上生成你自己的 .NET</h4><pre><code class="hljs">    在以前的 .NET 版本中，可以从源生成 .NET，但需要从与发布相对应的 dotnet/installer 存储库提交创建“源 tarball”。在 .NET 8 中，不再需要这样操作，你可以直接从 dotnet/dotnet 存储库在 Linux 上生成 .NET。该存储库使用 dotnet/source-build 生成 .NET 运行时、工具和 SDK。这是 Red Hat 和 Canonical 用于生成 .NET 的同一内部版本。    对于大多数人来说，在容器中生成是最简单的方法，因为 dotnet-buildtools/prereqs 容器映像包含所有必需的依赖项。</code></pre><h4 id="4-Linux-的最低支持版本"><a href="#4-Linux-的最低支持版本" class="headerlink" title="4. Linux 的最低支持版本"></a>4. Linux 的最低支持版本</h4><p>适用于 .NET 8 的 Linux 最低支持基线已更新：</p><pre><code class="hljs">    .NET 将面向 Ubuntu 16.04 生成，适用于所有体系结构。这对于定义 .NET 8 的最低 glibc 版本非常重要。例如，.NET 8 甚至无法在 Ubuntu 14.04 上启动。    对于 Red Hat Enterprise Linux (RHEL)，.NET 支持 RHEL 8+，删除 RHEL 7。</code></pre><h2 id="事项三-RESTful-API实践详解"><a href="#事项三-RESTful-API实践详解" class="headerlink" title="事项三 RESTful API实践详解"></a>事项三 RESTful API实践详解</h2><h3 id="什么是RESTful"><a href="#什么是RESTful" class="headerlink" title="什么是RESTful"></a>什么是RESTful</h3><pre><code class="hljs">    REST 是面向资源的，这个概念非常重要，而资源是通过 URI 进行暴露，URI 的设计只要负责把资源通过合理方式暴露出来就可以了，对资源的操作与它无关，操作是通过 HTTP动词来体现。所以REST 通过 URI 暴露资源时，会强调不要在 URI 中出现动词，而是对一类资源只提供一个url，通过GET、POST、PUT、DELETE请求来指定要执行的操作。   非RESTful 用法（多个url且url中存在动词）    <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><span class="hljs-regexp">/order/</span>query/<span class="hljs-number">1</span> GET  根据订单id查询订单数据<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><span class="hljs-regexp">/order/</span>save POST 新增订单<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><span class="hljs-regexp">/order/u</span>pdate POST 修改订单信息<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><span class="hljs-regexp">/order/</span><span class="hljs-keyword">delete</span> GET/POST 删除订单信息<br></code></pre></td></tr></table></figure>    RESTful 用法（同一个url，具体的操作通过HTTP请求方式来指定）    <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">http://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/order/<span class="hljs-number">1</span> GET  根据订单id查询订单数据<br>http://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/<span class="hljs-keyword">order</span>  <span class="hljs-title">POST</span> 新增订单<br>http://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/<span class="hljs-keyword">order</span>  <span class="hljs-title">PUT</span> 修改订单信息<br>http://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/<span class="hljs-keyword">order</span>  <span class="hljs-title">DELETE</span> 删除订单信息<br></code></pre></td></tr></table></figure>    REST很好地利用了HTTP本身就有的一些特征，如HTTP动词、HTTP状态码、HTTP报头等等。    REST API 是基于 HTTP的，所以你的API应该去使用 HTTP的一些标准。这样所有的HTTP客户端（如浏览器）才能够直接理解你的API。    REST返回值是标准的，我们不用单独定义和封装返回的状态码，而是直接使用HTTP的状态码，非RESTful 返回举例：    &#123;      &quot;code&quot;: &quot;0&quot;,      &quot;msg&quot;: &quot;成功&quot;    &#125;    &#123;      &quot;code&quot;: &quot;1&quot;,      &quot;msg&quot;: &quot;失败&quot;    &#125;    这种方式还要我们自己去解析，还要前端和后端去协商你返回的0是啥意思。    </code></pre><h4 id="RESTful-的关键"><a href="#RESTful-的关键" class="headerlink" title="RESTful 的关键"></a>RESTful 的关键</h4><pre><code class="hljs">    RESTful的关键是定义可表示流程元素/资源的对象。在REST中，每一个对象都是通过URL来表示的，对象用户负责将状态信息打包进每一条消息内，以便对象的处理总是无状态的。前后端分离的项目基本上就是无状态的，我们经常通过签名判断当前的请求是否合法。    所谓无状态的，即所有的资源，都可以通过URI定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而改变。    举个简单的例子说明一下有状态和无状态的区别，如查询员工的工资，如果查询工资是需要登录系统，进入查询工资的页面，执行相关操作后，获取工资的多少，则这种情况是有状态的，因为查询工资的每一步操作都依赖于前一步操作，只要前置操作不成功，后续操作就无法执行；如果输入一个url即可得到指定员工的工资，则这种情况是无状态的，因为获取工资不依赖于其他资源或状态，且这种情况下，员工工资是一个资源，由一个url与之对应，可以通过HTTP中的GET方法得到资源，这是典型的RESTful风格。    ![有状态的图片](/img/有状态.png &quot;有状态的图片&quot;)    ![无状态的图片](/img/无状态.png &quot;无状态的图片&quot;)</code></pre><h4 id="RESTful-API代码示例"><a href="#RESTful-API代码示例" class="headerlink" title="RESTful API代码示例"></a>RESTful API代码示例</h4><pre><code class="hljs"><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.ldy.sboot.demo.controller;<br> <br><span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.http.HttpStatus;<br><span class="hljs-keyword">import</span> org.springframework.http.ResponseEntity;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.DeleteMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.PathVariable;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.PostMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.PutMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RequestParam;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;<br> <br><span class="hljs-keyword">import</span> com.ldy.sboot.demo.entity.OrderEntity;<br><span class="hljs-keyword">import</span> com.ldy.sboot.demo.service.OrderService;<br> <br><span class="hljs-meta">@RequestMapping(<span class="hljs-string">&quot;restful/order&quot;</span>)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br> <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderService orderService;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @描述: 根据ID查询&lt;br&gt;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(value = <span class="hljs-string">&quot;&#123;id&#125;&quot;</span>)</span><br>    <span class="hljs-comment">//@RequestMapping(method = RequestMethod.GET)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;OrderEntity&gt; queryOrderById(<span class="hljs-meta">@PathVariable(<span class="hljs-string">&quot;id&quot;</span>)</span> <span class="hljs-built_in">Long</span> id) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            OrderEntity entity = orderService.queryOrderById(id);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == entity) &#123;<br>                <span class="hljs-comment">// 资源不存在，响应404</span><br>                <span class="hljs-keyword">return</span> ResponseEntity.status(HttpStatus.NOT_FOUND).body(<span class="hljs-literal">null</span>);<br>            &#125;<br>            <span class="hljs-comment">// 200</span><br>            <span class="hljs-comment">// return ResponseEntity.status(HttpStatus.OK).body(entity);</span><br>            <span class="hljs-keyword">return</span> ResponseEntity.ok(entity);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">// 500</span><br>        <span class="hljs-keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(<span class="hljs-literal">null</span>);<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @描述: 新增&lt;br&gt;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> entity</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-comment">//@RequestMapping(method = RequestMethod.POST)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-built_in">Void</span>&gt; saveOrder(OrderEntity entity) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            orderService.saveOrder(entity);<br>            <span class="hljs-keyword">return</span> ResponseEntity.status(HttpStatus.CREATED).build();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">// 500</span><br>        <span class="hljs-keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(<span class="hljs-literal">null</span>);<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @描述: 修改&lt;br&gt;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> entity</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PutMapping</span><br>    <span class="hljs-comment">//@RequestMapping(method = RequestMethod.PUT)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-built_in">Void</span>&gt; updateOrder(OrderEntity entity) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            orderService.updateOrder(entity);<br>            <span class="hljs-keyword">return</span> ResponseEntity.status(HttpStatus.NO_CONTENT).build();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">// 500</span><br>        <span class="hljs-keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(<span class="hljs-literal">null</span>);<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @描述: 删除&lt;br&gt;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@DeleteMapping</span><br>    <span class="hljs-comment">//@RequestMapping(method = RequestMethod.DELETE)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-built_in">Void</span>&gt; deleteOrder(<span class="hljs-meta">@RequestParam(value = <span class="hljs-string">&quot;id&quot;</span>)</span> <span class="hljs-built_in">Long</span> id) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            OrderEntity entity = orderService.queryOrderById(id);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == entity) &#123;<br>                <span class="hljs-comment">// 不存在返回404</span><br>                <span class="hljs-keyword">return</span> ResponseEntity.status(HttpStatus.NOT_FOUND).build();<br>            &#125;<br>            orderService.deleteOrderById(id);<br>            <span class="hljs-comment">// 204</span><br>            <span class="hljs-keyword">return</span> ResponseEntity.status(HttpStatus.NO_CONTENT).build();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">// 500</span><br>        <span class="hljs-keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(<span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><h3 id="HTTP状态码说明"><a href="#HTTP状态码说明" class="headerlink" title="HTTP状态码说明"></a>HTTP状态码说明</h3><p> <img src="/img/http%E7%8A%B6%E6%80%81%E7%A0%811%E5%BC%80%E5%A4%B4%E5%92%8C2%E5%BC%80%E5%A4%B4%E7%9A%84.png" alt="http状态码图片" title="http状态码1开头和2开头的图片"><br> <img src="/img/http%E7%8A%B6%E6%80%81%E7%A0%813%E5%BC%80%E5%A4%B4%E7%9A%84.png" alt="http状态码图片" title="http状态码3开头的图片"><br> <img src="/img/http%E7%8A%B6%E6%80%81%E7%A0%814%E5%BC%80%E5%A4%B4%E7%9A%84.png" alt="http状态码图片" title="http状态码4开头的图片"><br> <img src="/img/http%E7%8A%B6%E6%80%81%E7%A0%815%E5%BC%80%E5%A4%B4%E7%9A%84.png" alt="http状态码图片" title="http状态码5开头的图片"></p><p> 注：.Net 8.0 新的变化 内容来自 csdn_aspnet csdn<br>     RESTful API实践详解 内容来自 咚咚阳 csdn</p>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日事项-2024年7月13日</title>
    <link href="/2024/07/13/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%8813%E6%97%A5/"/>
    <url>/2024/07/13/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%8813%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="今日事项-2024年7月13日"><a href="#今日事项-2024年7月13日" class="headerlink" title="今日事项-2024年7月13日"></a>今日事项-2024年7月13日</h1><h2 id="事项一-收集3个实用的经典算法"><a href="#事项一-收集3个实用的经典算法" class="headerlink" title="事项一 收集3个实用的经典算法"></a>事项一 收集3个实用的经典算法</h2><h3 id="1-Dijkstra-算法"><a href="#1-Dijkstra-算法" class="headerlink" title="1. Dijkstra 算法"></a>1. Dijkstra 算法</h3><p> <img src="/img/Dijkstra%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B%E5%9B%BE%E7%89%87.png" alt="Dijkstra算法示例图片" title="Dijkstra算法示例图片"></p><h4 id="产生原因与背景："><a href="#产生原因与背景：" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你要在一张地图上找到从一个城市到所有其他城市的最短路径，每条道路都有不同的距离，Dijkstra 算法就像是一位精明的旅行者，他总是选择当前看起来最短的路径，逐步找到到达所有目的地的最短路径。</p><h4 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h4><p>Dijkstra 算法就像是一位探险家在探索未知的岛屿，他从一个小岛出发，总是选择最近的岛屿去探索，然后标记这个岛屿和到达它的最短路径，再继续探索下一个最近的岛屿，直到所有的岛屿都被探索过。</p><h4 id="代码案列："><a href="#代码案列：" class="headerlink" title="代码案列："></a>代码案列：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dijkstra</span>(<span class="hljs-params">graph, start</span>):<br>    <span class="hljs-comment"># 初始化距离字典，所有距离设置为无穷大，除了起始点到自己的距离为0</span><br>    distances = &#123;node: <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;infinity&#x27;</span>) <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph&#125;<br>    distances[start] = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 使用优先队列保存节点和对应的距离</span><br>    priority_queue = [(<span class="hljs-number">0</span>, start)]<br><br>    <span class="hljs-keyword">while</span> priority_queue:<br>        <span class="hljs-comment"># 弹出当前距离最短的节点</span><br>        current_distance, current_node = heapq.heappop(priority_queue)<br><br>        <span class="hljs-comment"># 如果当前距离大于记录的距离，则跳过</span><br>        <span class="hljs-keyword">if</span> current_distance &gt; distances[current_node]:<br>            <span class="hljs-keyword">continue</span><br><br>        <span class="hljs-comment"># 遍历邻居节点</span><br>        <span class="hljs-keyword">for</span> neighbor, weight <span class="hljs-keyword">in</span> graph[current_node].items():<br>            <span class="hljs-comment"># 计算到达邻居节点的距离</span><br>            distance = current_distance + weight<br>            <span class="hljs-comment"># 如果找到了更短的路径，则更新距离并添加到优先队列</span><br>            <span class="hljs-keyword">if</span> distance &lt; distances[neighbor]:<br>                distances[neighbor] = distance<br>                heapq.heappush(priority_queue, (distance, neighbor))<br><br>    <span class="hljs-keyword">return</span> distances<br><br><span class="hljs-comment"># 使用示例</span><br>graph = &#123;<br>    <span class="hljs-string">&#x27;A&#x27;</span>: &#123;<span class="hljs-string">&#x27;B&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">4</span>&#125;,<br>    <span class="hljs-string">&#x27;B&#x27;</span>: &#123;<span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-number">3</span>&#125;,<br>    <span class="hljs-string">&#x27;C&#x27;</span>: &#123;<span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;E&#x27;</span>: <span class="hljs-number">2</span>&#125;,<br>    <span class="hljs-string">&#x27;D&#x27;</span>: &#123;&#125;,<br>    <span class="hljs-string">&#x27;E&#x27;</span>: &#123;<span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-number">1</span>&#125;<br>&#125;<br>start_node = <span class="hljs-string">&#x27;A&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Shortest distances from&quot;</span>, start_node, <span class="hljs-string">&quot;:&quot;</span>, dijkstra(graph, start_node))<br></code></pre></td></tr></table></figure><h4 id="算法优缺点："><a href="#算法优缺点：" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：Dijkstra 算法可以高效地找到单源最短路径，特别是在图的边权都是非负的情况下。<br>缺点：如果边权是负数，Dijkstra 算法可能无法正确工作，因为它不适用于包含负权边的图。</p><h4 id="解决缺点的方法："><a href="#解决缺点的方法：" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>对于有负权边的图，可以使用 Bellman-Ford 算法，它可以处理负权边，但时间复杂度较高。</p><h4 id="解决缺点后的代码案例："><a href="#解决缺点后的代码案例：" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（Bellman-Ford 算法已经在上文中给出）</p><h4 id="算法的3个实际应用案例："><a href="#算法的3个实际应用案例：" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>GPS 导航</strong>：计算从一个地点到多个目的地的最短行驶距离。</li><li><strong>网络路由</strong>：在网络中找到数据传输的最短路径。</li><li><strong>城市交通规划</strong>：优化公共交通路线，减少乘客的出行时间。</li></ul><h3 id="2-贝叶斯分类器（Naive-Bayes-Classifier）"><a href="#2-贝叶斯分类器（Naive-Bayes-Classifier）" class="headerlink" title="2. 贝叶斯分类器（Naive Bayes Classifier）"></a>2. 贝叶斯分类器（Naive Bayes Classifier）</h3><p> <img src="/img/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F.png" alt="贝叶斯公式图片" title="贝叶斯公式图片"></p><h4 id="产生原因与背景：-1"><a href="#产生原因与背景：-1" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你是一位侦探，需要根据一系列线索来判断犯罪嫌疑人。贝叶斯分类器就像是一位根据证据来做出判断的侦探，它使用贝叶斯定理来计算每个类别的后验概率，从而决定最可能的类别。</p><h4 id="算法思路：-1"><a href="#算法思路：-1" class="headerlink" title="算法思路："></a>算法思路：</h4><p>贝叶斯分类器就像是一位医生在诊断病人，根据病人的症状和已知的疾病概率，使用贝叶斯定理来确定最可能的疾病。</p><h4 id="代码案列：-1"><a href="#代码案列：-1" class="headerlink" title="代码案列："></a>代码案列：</h4><p>略（贝叶斯分类器的实现较为复杂，通常涉及概率论和统计学）</p><h4 id="算法优缺点：-1"><a href="#算法优缺点：-1" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：贝叶斯分类器在处理大量特征的数据集时非常高效，尤其是在文本分类和垃圾邮件检测等领域。<br>缺点：贝叶斯分类器假设特征之间相互独立，这在现实中很少成立，可能会影响分类的准确性。</p><h4 id="解决缺点的方法：-1"><a href="#解决缺点的方法：-1" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>可以通过特征选择或使用更复杂的模型来减少特征独立性的假设带来的影响。</p><h4 id="解决缺点后的代码案例：-1"><a href="#解决缺点后的代码案例：-1" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（特征选择和模型优化通常需要特定的数据集和领域知识）</p><h4 id="算法的3个实际应用案例：-1"><a href="#算法的3个实际应用案例：-1" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>垃圾邮件检测</strong>：根据邮件内容判断是否为垃圾邮件。</li><li><strong>情感分析</strong>：判断社交媒体上的评论是正面还是负面。</li><li><strong>疾病诊断</strong>：根据病人的症状和体征来辅助诊断疾病。</li></ul><h3 id="3-决策树（Decision-Tree）"><a href="#3-决策树（Decision-Tree）" class="headerlink" title="3. 决策树（Decision Tree）"></a>3. 决策树（Decision Tree）</h3><h4 id="产生原因与背景：-2"><a href="#产生原因与背景：-2" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你在决定是否要出门野餐，你会考虑天气、温度、是否有朋友同行等因素。决策树就像是一个帮助你做决定的流程图，它通过一系列的问题引导你做出最终的决定。</p><h4 id="算法思路：-2"><a href="#算法思路：-2" class="headerlink" title="算法思路："></a>算法思路：</h4><p>决策树就像是一位厨师在选择食谱，他根据现有的食材、客人的口味偏好和烹饪时间来决定做什么菜。</p><h4 id="代码案列：-2"><a href="#代码案列：-2" class="headerlink" title="代码案列："></a>代码案列：</h4><p>略（决策树的实现较为复杂，通常涉及机器学习库）</p><h4 id="算法优缺点：-2"><a href="#算法优缺点：-2" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：决策树直观易懂，可以处理数值和类别数据，且不需要太多预处理。<br>缺点：决策树容易过拟合，特别是树很深或数据集很复杂时。</p><h4 id="解决缺点的方法：-2"><a href="#解决缺点的方法：-2" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>可以通过剪枝来减少决策树的深度，或者使用集成方法如随机森林来提高泛化能力。</p><h4 id="解决缺点后的代码案例：-2"><a href="#解决缺点后的代码案例：-2" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（剪枝和随机森林的实现通常需要使用机器学习库）</p><h4 id="算法的3个实际应用案例：-2"><a href="#算法的3个实际应用案例：-2" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>医疗诊断</strong>：根据病人的症状、体检结果和历史记录来辅助诊断疾病。</li><li><strong>客户流失预测</strong>：根据客户的使用习惯和反馈来判断客户是否会流失。</li><li><strong>信用评分</strong>：根据申请人的财务信息和历史信用记录来评估信用风险。</li></ul><h2 id="事项二-重学OSI七层模型-TCP-IP四层模型"><a href="#事项二-重学OSI七层模型-TCP-IP四层模型" class="headerlink" title="事项二 重学OSI七层模型&amp;&amp;TCP&#x2F;IP四层模型"></a>事项二 重学OSI七层模型&amp;&amp;TCP&#x2F;IP四层模型</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p><img src="/img/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.jpg" alt="七层模型图片" title="七层模型图片"></p><p>OSI（Open System Interconnect）七层模型是一种将计算机网络通信协议划分为七个不同层次的标准化框架。每一层都负责不同的功能，从物理连接到应用程序的处理。这种模型有助于不同的系统之间进行通信时，更好地理解和管理网络通信的过程。<br>OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互连系统参考模型。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lasso">应用层（Application Layer）：这是网络体系结构中的最顶层，提供用户接口和应用程序之间的通信服务。在这一层，用户可以访问各种网络应用程序，如电子邮件、文件传输和远程登录。<br><br>表示层（Presentation Layer）：该层负责数据的格式化、加密和压缩，以确保数据在不同系统之间的交换是有效的和安全的。它还提供了数据格式转换和语法转换的功能。<br><br>会话层（Session Layer）：会话层管理应用程序之间的通信会话，负责建立、维护和终止会话。它还提供了数据的同步和检查点恢复功能，以确保通信的完整性和持续性。<br><br>传输层（Transport Layer）：传输层为应用程序提供端到端的数据传输服务，负责数据的分段、传输控制、错误恢复和流量控制。它主要使用 TCP（传输控制协议）和 UDP（用户数据报协议）来实现这些功能。<br><br>网络层（Network Layer）：网络层负责数据包的路由和转发，以及网络中的寻址和拥塞控制。它选择最佳的路径来传输数据包，以确保它们能够从源主机到目标主机进行传输。<br><br>数据链路层（<span class="hljs-built_in">Data</span> <span class="hljs-keyword">Link</span> Layer）：数据链路层提供点对点的数据传输服务，负责将原始比特流转换为数据帧，并检测和纠正传输中出现的错误。它还控制访问物理媒介的方式，以及数据帧的传输和接收。<br><br>物理层（Physical Layer）：物理层在物理媒介上传输原始比特流，定义了连接主机的硬件设备和传输媒介的规范。它确保比特流能够在网络中准确地传输，例如通过以太网、光纤和无线电波等媒介。<br></code></pre></td></tr></table></figure><h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h3><p><img src="/img/Network-TCPIP-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B.png" alt="TCPIP-四层模型图片" title="TCPIP-四层模型图片"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm">应用层（Application Layer）类似于 OSI 模型中的应用层，负责处理用户与网络应用程序之间的通信。它包括诸如 HTTP、FTP、SMTP 等协议，用于实现不同类型的网络服务和应用。<br><br>传输层（Transport Layer）：与 OSI 模型中的传输层相对应，提供端到端的数据传输服务。在 TCP/<span class="hljs-built_in">IP</span> 模型中，主要有两个协议：TCP（传输控制协议）和 UDP（用户数据报协议），用于确保可靠的数据传输和简单的数据传输。<br><br>网络层（Internet Layer）：相当于 OSI 模型中的网络层，负责数据包的路由和转发。它使用 <span class="hljs-built_in">IP</span>（Internet Protocol）协议来定义数据包的传输路径，并处理不同网络之间的通信。<br><br>网络接口层（Link Layer）：与 OSI 模型中的数据链路层和物理层相对应，负责管理网络硬件设备和物理媒介之间的通信。它包括以太网、Wi-Fi、蓝牙等各种物理层和数据链路层协议。<br></code></pre></td></tr></table></figure><h4 id="应用层常见协议"><a href="#应用层常见协议" class="headerlink" title="应用层常见协议"></a>应用层常见协议</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fortran">HTTP（HyperText <span class="hljs-built_in">Transfer</span> Protocol）：用于在客户端和服务器之间传输超文本数据，通常用于 Web 浏览器和 Web 服务器之间的通信。<br><br>FTP（<span class="hljs-keyword">File</span> <span class="hljs-built_in">Transfer</span> Protocol）：用于在客户端和服务器之间传输文件，支持上传和下载文件的功能。<br><br>SMTP（Simple Mail <span class="hljs-built_in">Transfer</span> Protocol）：用于在邮件服务器之间传输电子邮件，负责发送邮件。<br><br>POP3（Post Office Protocol version <span class="hljs-number">3</span>）：用于从邮件服务器上下载邮件到本地计算机，负责接收邮件。<br><br>IMAP（Internet Message <span class="hljs-keyword">Access</span> Protocol）：也是用于接收邮件的协议，与 POP3 类似，但提供了更丰富的功能，如在服务器上管理邮件等。<br><br>DNS（Domain <span class="hljs-keyword">Name</span> System）：用于将域名解析为对应的 IP 地址，从而实现域名和 IP 地址之间的映射。<br><br>HTTPS（HyperText <span class="hljs-built_in">Transfer</span> Protocol Secure）：是 HTTP 的安全版本，通过 SSL/TLS 加密传输数据，保证通信过程中的安全性。<br><br>SSH（Secure Shell）：用于远程登录和执行命令，提供了加密的网络连接，保证了通信的安全性。<br><br>SNMP（Simple Network Management Protocol）：用于网络设备之间的管理和监控，可以实现对网络设备的远程配置和监控。<br><br>Telnet：用于远程登录和执行命令，类似于 SSH，但不提供加密功能，通信数据不安全。<br></code></pre></td></tr></table></figure><h4 id="传输层常见协议"><a href="#传输层常见协议" class="headerlink" title="传输层常见协议"></a>传输层常见协议</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">TCP（Transmission Control Protocol）：提供可靠的、面向连接的数据传输服务，确保数据的可靠性、顺序性和完整性。TCP适用于对数据传输质量要求较高的场景，如文件传输、网页浏览等。<br><br>UDP（<span class="hljs-keyword">User</span> <span class="hljs-title">Datagram</span> Protocol）：提供无连接的数据传输服务，不保证数据的可靠性，也不保证数据的顺序性和完整性。UDP适用于实时性要求较高、对数据传输质量要求不那么严格的场景，如音视频传输、在线游戏等。<br></code></pre></td></tr></table></figure><h4 id="网络层常见协议"><a href="#网络层常见协议" class="headerlink" title="网络层常见协议"></a>网络层常见协议</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">IP</span>（Internet Protocol）：是互联网中最基本的协议，用于在网络中传输数据包。<span class="hljs-built_in">IP</span>协议定义了数据包的格式、寻址方式和路由选择等信息，是整个互联网的基础。<br><br>ICMP（Internet Control Message Protocol）：用于在<span class="hljs-built_in">IP</span>网络中传递控制消息和错误信息。ICMP通常用于网络设备之间的通信，如路由器和主机之间的通信，以及用于检测网络连通性和故障诊断。<br><br>ARP（Address Resolution Protocol）：用于将<span class="hljs-built_in">IP</span>地址映射为MAC地址（物理地址）。ARP协议在局域网内部使用，通过发送ARP请求获取目标设备的MAC地址，从而实现数据包的传输。<br><br>RARP（Reverse Address Resolution Protocol）：与ARP相反，用于将MAC地址映射为<span class="hljs-built_in">IP</span>地址。RARP协议通常用于无盘工作站等设备，可以根据MAC地址获取对应的<span class="hljs-built_in">IP</span>地址。<br><br>IPv6（Internet Protocol version <span class="hljs-number">6</span>）：是<span class="hljs-built_in">IP</span>协议的下一代版本，用于解决IPv4地址空间不足的问题。IPv6采用<span class="hljs-number">128</span>位地址长度，提供了更大的地址空间，支持更多的设备连接到互联网。<br></code></pre></td></tr></table></figure><h4 id="网络接口层常见协议"><a href="#网络接口层常见协议" class="headerlink" title="网络接口层常见协议"></a>网络接口层常见协议</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino">以太网协议（<span class="hljs-built_in">Ethernet</span>）：是一种常见的局域网技术，使用MAC地址进行帧的传输和接收。<br><br>无线局域网协议（Wi-Fi）：用于无线局域网的数据传输，通常基于IEEE <span class="hljs-number">802.11</span>标准。<br><br>点对点协议（PPP）：用于建立点对点连接的协议，通常用于拨号连接和虚拟专用网（VPN）等场景。<br><br>数据链路层交换协议（DLC）：用于在数据链路层进行数据交换和管理的协议，如HDLC、SLIP和PPP等。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日事项-2024年7月9日</title>
    <link href="/2024/07/09/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%889%E6%97%A5/"/>
    <url>/2024/07/09/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%889%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="今日事项-2024年7月9日"><a href="#今日事项-2024年7月9日" class="headerlink" title="今日事项-2024年7月9日"></a>今日事项-2024年7月9日</h1><h2 id="事项一-学习三个实用算法"><a href="#事项一-学习三个实用算法" class="headerlink" title="事项一 学习三个实用算法"></a>事项一 学习三个实用算法</h2><h3 id="贪心算法（Greedy-Algorithm）"><a href="#贪心算法（Greedy-Algorithm）" class="headerlink" title="贪心算法（Greedy Algorithm）"></a>贪心算法（Greedy Algorithm）</h3><h4 id="产生原因与背景："><a href="#产生原因与背景：" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你在一家超市里，想要用有限的钱买到尽可能多的糖果。你会一直挑选单价最低的糖果，直到钱用完。贪心算法就是这样，它在每一步选择中都采取当前看起来最好的选择，以期望获得全局最优解。</p><h4 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h4><p>贪心算法就像是一位精明的购物者，在购物时总是选择性价比最高的商品，希望通过这些局部最优的选择来获得最大的整体收益。</p><h4 id="代码案列："><a href="#代码案列：" class="headerlink" title="代码案列："></a>代码案列：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">min_coin_change</span>(<span class="hljs-params">coins, amount</span>):<br>    <span class="hljs-comment"># 贪心选择：按照硬币面额从大到小排列</span><br>    coins.sort(reverse=<span class="hljs-literal">True</span>)<br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> coin <span class="hljs-keyword">in</span> coins:<br>        <span class="hljs-comment"># 计算当前硬币面额可以兑换的个数</span><br>        <span class="hljs-keyword">while</span> amount &gt;= coin:<br>            amount -= coin<br>            count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> count<br><br><span class="hljs-comment"># 使用示例</span><br>coins = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]  <span class="hljs-comment"># 硬币面额</span><br>amount = <span class="hljs-number">11</span>  <span class="hljs-comment"># 总金额</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Minimum number of coins to make change for&quot;</span>, amount, <span class="hljs-string">&quot;:&quot;</span>, min_coin_change(coins, amount))<br></code></pre></td></tr></table></figure><h4 id="算法优缺点："><a href="#算法优缺点：" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：贪心算法在很多问题上都能给出一个足够好的解决方案，且实现简单。<br>缺点：贪心算法并不保证总是能得到全局最优解，因为它只关注当前的最优选择。</p><h4 id="解决缺点的方法："><a href="#解决缺点的方法：" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>在需要全局最优解的情况下，可以使用动态规划或其他全局最优算法。</p><h4 id="算法的3个实际应用案例："><a href="#算法的3个实际应用案例：" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>背包问题</strong>：如何将价值最大化的物品装入有限容量的背包。</li><li><strong>任务调度</strong>：在多个任务中选择当前优先级最高的任务执行。</li><li><strong>网络流问题</strong>：在网络中选择最短的路径传输数据包。</li></ul><h3 id="布隆过滤器（Bloom-Filter）"><a href="#布隆过滤器（Bloom-Filter）" class="headerlink" title="布隆过滤器（Bloom Filter）"></a>布隆过滤器（Bloom Filter）</h3><h4 id="产生原因与背景：-1"><a href="#产生原因与背景：-1" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你管理着一个巨大的图书馆，需要快速判断一本书是否在馆内，而不必真的去书架上查找。布隆过滤器是一种空间效率很高的数据结构，用于测试元素是否是一个集合的成员。</p><h4 id="算法思路：-1"><a href="#算法思路：-1" class="headerlink" title="算法思路："></a>算法思路：</h4><p>布隆过滤器就像是一位图书管理员使用的一种快速检查系统，他通过多个不同的标签系统来快速定位书籍，如果所有标签都指向某个位置，那么这本书很可能就在那里。</p><h4 id="代码案列：-1"><a href="#代码案列：-1" class="headerlink" title="代码案列："></a>代码案列：</h4><p>略（布隆过滤器的实现较为复杂，通常涉及位数组和哈希函数）</p><h4 id="算法优缺点：-1"><a href="#算法优缺点：-1" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：布隆过滤器在空间和时间效率上都很高效，特别是对于大规模数据集的快速查找。<br>缺点：布隆过滤器存在误判的可能性，即可能会告诉你一个元素存在，而实际上它并不存在。</p><h4 id="解决缺点的方法：-1"><a href="#解决缺点的方法：-1" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>通过增加位数组的大小或哈希函数的数量来降低误判率。</p><h4 id="算法的3个实际应用案例：-1"><a href="#算法的3个实际应用案例：-1" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>缓存系统</strong>：快速判断一个元素是否在缓存中。</li><li><strong>数据库索引</strong>：减少数据库查询中的误判，提高查询效率。</li><li><strong>信息检索</strong>：在大规模文档集合中快速排除不相关的文档。</li></ul><h3 id="编辑距离（Levenshtein-Distance）"><a href="#编辑距离（Levenshtein-Distance）" class="headerlink" title="编辑距离（Levenshtein Distance）"></a>编辑距离（Levenshtein Distance）</h3><h4 id="产生原因与背景：-2"><a href="#产生原因与背景：-2" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你在比较两个版本的软件代码，需要知道它们之间的差异有多大。编辑距离算法用于计算两个字符串之间，通过最少的插入、删除或替换操作，从一个字符串转换成另一个字符串的距离。</p><h4 id="算法思路：-2"><a href="#算法思路：-2" class="headerlink" title="算法思路："></a>算法思路：</h4><p>编辑距离算法就像是一位编辑在比较两份文稿，他需要找出最少的修改次数，以使两份文稿内容一致。</p><h4 id="代码案列：-2"><a href="#代码案列：-2" class="headerlink" title="代码案列："></a>代码案列：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">levenshtein_distance</span>(<span class="hljs-params">s1, s2</span>):<br>    len_s1, len_s2 = <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">len</span>(s2)<br>    <span class="hljs-comment"># 初始化二维数组存储编辑距离</span><br>    dp = [[<span class="hljs-number">0</span>] * (len_s2 + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len_s1 + <span class="hljs-number">1</span>)]<br><br>    <span class="hljs-comment"># 边界条件：空字符串到另一个字符串的距离是另一个字符串的长度</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len_s1 + <span class="hljs-number">1</span>):<br>        dp[i][<span class="hljs-number">0</span>] = i<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len_s2 + <span class="hljs-number">1</span>):<br>        dp[<span class="hljs-number">0</span>][j] = j<br><br>    <span class="hljs-comment"># 计算编辑距离</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, len_s1 + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, len_s2 + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> s1[i - <span class="hljs-number">1</span>] == s2[j - <span class="hljs-number">1</span>]:<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 字符相同，不需要操作</span><br>            <span class="hljs-keyword">else</span>:<br>                dp[i][j] = <span class="hljs-number">1</span> + <span class="hljs-built_in">min</span>(<br>                    dp[i - <span class="hljs-number">1</span>][j],    <span class="hljs-comment"># 删除s1的一个字符</span><br>                    dp[i][j - <span class="hljs-number">1</span>],    <span class="hljs-comment"># 在s2中插入一个字符</span><br>                    dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] <span class="hljs-comment"># 替换一个字符</span><br>                )<br>    <span class="hljs-keyword">return</span> dp[len_s1][len_s2]<br><br><span class="hljs-comment"># 使用示例</span><br>s1 = <span class="hljs-string">&quot;kitten&quot;</span><br>s2 = <span class="hljs-string">&quot;sitting&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Levenshtein distance:&quot;</span>, levenshtein_distance(s1, s2))<br></code></pre></td></tr></table></figure><h4 id="算法优缺点：-2"><a href="#算法优缺点：-2" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：编辑距离算法能够提供两个字符串之间差异的量化度量，对于字符串比较非常有用。<br>缺点：编辑距离算法的时间复杂度为O(m * n)，其中m和n是两个字符串的长度，对于长字符串效率较低。</p><h4 id="解决缺点的方法：-2"><a href="#解决缺点的方法：-2" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>对于长字符串，可以使用更高效的算法或启发式方法来近似计算编辑距离。</p><h4 id="算法的3个实际应用案例：-2"><a href="#算法的3个实际应用案例：-2" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>拼写检查器</strong>：检测和建议更正拼写错误。</li><li><strong>生物信息学</strong>：比较DNA序列或蛋白质序列的相似度。</li><li><strong>软件本地化</strong>：比较不同语言版本的软件字符串，以发现翻译不一致之处。</li></ul>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日事项-2024年7月4日</title>
    <link href="/2024/07/04/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%884%E6%97%A5/"/>
    <url>/2024/07/04/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%884%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="今日事项-2024年7月4日"><a href="#今日事项-2024年7月4日" class="headerlink" title="今日事项-2024年7月4日"></a>今日事项-2024年7月4日</h1><h2 id="事项一-收集3个实用的经典算法"><a href="#事项一-收集3个实用的经典算法" class="headerlink" title="事项一 收集3个实用的经典算法"></a>事项一 收集3个实用的经典算法</h2><h3 id="1-哈希表查找（Hash-Table-Lookup）"><a href="#1-哈希表查找（Hash-Table-Lookup）" class="headerlink" title="1. 哈希表查找（Hash Table Lookup）"></a>1. 哈希表查找（Hash Table Lookup）</h3><h4 id="产生原因与背景："><a href="#产生原因与背景：" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你管理着一个庞大的图书馆，需要快速地根据书名找到书籍的具体位置。哈希表提供了一种快速检索的方法，它通过一个函数（称为哈希函数）将书名映射到一个固定大小的数组索引上。</p><h4 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h4><p>哈希表查找就像是一位图书馔的管理员使用一套高效的分类系统，读者告诉他书名，他就能迅速地根据书名的首字母或者关键词快速定位到书架的区域。</p><h4 id="代码案列："><a href="#代码案列：" class="headerlink" title="代码案列："></a>代码案列：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, size=<span class="hljs-number">10</span></span>):<br>        self.size = size<br>        self.table = [<span class="hljs-literal">None</span>] * size<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hash_function</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-comment"># 简单的哈希函数，将字符串转换为数字并取模</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(key) % self.size<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, key, value</span>):<br>        index = self.hash_function(key)<br>        <span class="hljs-comment"># 如果索引位置为空，直接插入</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.table[index]:<br>            self.table[index] = [(key, value)]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果有冲突，将元素追加到链表中</span><br>            <span class="hljs-keyword">for</span> pair <span class="hljs-keyword">in</span> self.table[index]:<br>                <span class="hljs-keyword">if</span> pair[<span class="hljs-number">0</span>] == key:<br>                    pair[<span class="hljs-number">1</span>] = value  <span class="hljs-comment"># 更新值</span><br>                    <span class="hljs-keyword">return</span><br>            self.table[index].append((key, value))  <span class="hljs-comment"># 添加新的键值对</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key</span>):<br>        index = self.hash_function(key)<br>        <span class="hljs-keyword">if</span> self.table[index]:<br>            <span class="hljs-keyword">for</span> pair <span class="hljs-keyword">in</span> self.table[index]:<br>                <span class="hljs-keyword">if</span> pair[<span class="hljs-number">0</span>] == key:<br>                    <span class="hljs-keyword">return</span> pair[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 返回值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># 未找到返回None</span><br><br><span class="hljs-comment"># 使用示例</span><br>hash_table = HashTable()<br>hash_table.insert(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">100</span>)<br>hash_table.insert(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">200</span>)<br><span class="hljs-built_in">print</span>(hash_table.get(<span class="hljs-string">&quot;apple&quot;</span>))  <span class="hljs-comment"># 输出应该是100</span><br></code></pre></td></tr></table></figure><h4 id="算法优缺点："><a href="#算法优缺点：" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：哈希表提供了非常快速的平均时间复杂度为O(1)的查找、插入和删除操作。<br>缺点：哈希表的性能依赖于哈希函数的设计，如果设计不当，可能会产生大量冲突，导致性能下降。</p><h4 id="解决缺点的方法："><a href="#解决缺点的方法：" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>使用更优质的哈希函数来减少冲突，或者使用开放寻址法和链表法等冲突解决策略。</p><h4 id="解决缺点后的代码案例："><a href="#解决缺点后的代码案例：" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（上面的代码已经展示了使用链表法解决冲突）</p><h4 id="算法的3个实际应用案例："><a href="#算法的3个实际应用案例：" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>缓存实现</strong>：在Web缓存中，快速检索之前请求过的资源。</li><li><strong>唯一性检查</strong>：在处理大量数据时，快速检查数据是否已存在。</li><li><strong>数据库索引</strong>：在数据库中，加速数据检索操作。</li></ul><h3 id="2-最长公共子序列（Longest-Common-Subsequence-LCS）"><a href="#2-最长公共子序列（Longest-Common-Subsequence-LCS）" class="headerlink" title="2. 最长公共子序列（Longest Common Subsequence, LCS）"></a>2. 最长公共子序列（Longest Common Subsequence, LCS）</h3><h4 id="产生原因与背景：-1"><a href="#产生原因与背景：-1" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你在编写两个版本的软件，需要找出两个版本之间的公共功能模块，这样你可以重用这些模块而不必重新编写。</p><h4 id="算法思路：-1"><a href="#算法思路：-1" class="headerlink" title="算法思路："></a>算法思路：</h4><p>最长公共子序列就像是一位比较购物清单的专家，他找出两份清单中都存在的项目，并确定这些共有项目的最长连续序列。</p><h4 id="代码案列：-1"><a href="#代码案列：-1" class="headerlink" title="代码案列："></a>代码案列：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">longest_common_subsequence</span>(<span class="hljs-params">X, Y</span>):<br>    m, n = <span class="hljs-built_in">len</span>(X), <span class="hljs-built_in">len</span>(Y)<br>    <span class="hljs-comment"># 创建二维数组存储最长公共子序列的长度</span><br>    L = [[<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m + <span class="hljs-number">1</span>)]<br><br>    <span class="hljs-comment"># 填充数组</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> X[i - <span class="hljs-number">1</span>] == Y[j - <span class="hljs-number">1</span>]:<br>                L[i][j] = L[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                L[i][j] = <span class="hljs-built_in">max</span>(L[i - <span class="hljs-number">1</span>][j], L[i][j - <span class="hljs-number">1</span>])<br><br>    <span class="hljs-comment"># 构造LCS</span><br>    i, j = m, n<br>    lcs = []<br>    <span class="hljs-keyword">while</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">if</span> X[i - <span class="hljs-number">1</span>] == Y[j - <span class="hljs-number">1</span>]:<br>            lcs.append(X[i - <span class="hljs-number">1</span>])<br>            i -= <span class="hljs-number">1</span><br>            j -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> L[i - <span class="hljs-number">1</span>][j] &gt; L[i][j - <span class="hljs-number">1</span>]:<br>            i -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            j -= <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> lcs[::-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 反转列表，因为构造是反向的</span><br><br><span class="hljs-comment"># 使用示例</span><br>X = <span class="hljs-string">&quot;AGGTAB&quot;</span><br>Y = <span class="hljs-string">&quot;GXTXAYB&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Longest Common Subsequence:&quot;</span>, longest_common_subsequence(X, Y))<br></code></pre></td></tr></table></figure><h4 id="算法优缺点：-1"><a href="#算法优缺点：-1" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：LCS算法能够找出两个序列的最长公共子序列，这在许多比较和相似度计算的场景中非常有用。<br>缺点：LCS算法的时间复杂度为O(m * n)，其中m和n是两个序列的长度，对于很长的序列，性能可能不是很好。</p><h4 id="解决缺点的方法：-1"><a href="#解决缺点的方法：-1" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>对于更长的序列，可以考虑使用更高效的算法或数据结构，如后缀树或后缀数组。</p><h4 id="解决缺点后的代码案例：-1"><a href="#解决缺点后的代码案例：-1" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（后缀树或数组的实现较为复杂）</p><h4 id="算法的3个实际应用案例：-1"><a href="#算法的3个实际应用案例：-1" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>文本比较</strong>：在文档比较工具中，找出两个文本文件的相同部分。</li><li><strong>生物信息学</strong>：在DNA序列分析中，找出不同物种之间的相似基因序列。</li><li><strong>软件版本控制</strong>：在版本控制系统中，确定不同版本代码的共有部分。</li></ul><h3 id="3-欧拉路径和欧拉回路（Eulerian-Path-and-Circuit）"><a href="#3-欧拉路径和欧拉回路（Eulerian-Path-and-Circuit）" class="headerlink" title="3. 欧拉路径和欧拉回路（Eulerian Path and Circuit）"></a>3. 欧拉路径和欧拉回路（Eulerian Path and Circuit）</h3><h4 id="产生原因与背景：-2"><a href="#产生原因与背景：-2" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你是一位城市邮递员，需要设计一条路线，使得你可以恰好访问每个街道一次，然后返回到起点，这样的路线称为欧拉回路。</p><h4 id="算法思路：-2"><a href="#算法思路：-2" class="headerlink" title="算法思路："></a>算法思路：</h4><p>欧拉路径和回路就像是一位旅行者在探索一个由道路连接的城市网络，他尝试找出一条路径，可以访问每条道路一次，并且最终能够回到出发点。</p><h4 id="代码案列：-2"><a href="#代码案列：-2" class="headerlink" title="代码案列："></a>代码案列：</h4><p>略（欧拉路径和回路的算法实现较为复杂，通常涉及图的遍历）</p><h4 id="算法优缺点：-2"><a href="#算法优缺点：-2" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：欧拉路径和回路提供了一种高效访问图中所有边的方法，对于需要遍历所有连接的网络非常有用。<br>缺点：并非所有图都有欧拉路径或回路，这限制了算法的应用范围。</p><h4 id="解决缺点的方法：-2"><a href="#解决缺点的方法：-2" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>在没有欧拉路径或回路的图中，可以寻找接近的解决方案，如汉密尔顿路径或使用其他图遍历算法。</p><h4 id="解决缺点后的代码案例：-2"><a href="#解决缺点后的代码案例：-2" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（解决方案通常需要特定图的结构分析）</p><h4 id="算法的3个实际应用案例：-2"><a href="#算法的3个实际应用案例：-2" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>旅行商问题</strong>：在旅行商问题中，寻找访问每个城市一次并返回起点的最短路径。</li><li><strong>数据网络管理</strong>：在数据网络中，确保所有连接都得到适当的维护和检查。</li><li><strong>社交网络分析</strong>：在社交网络中，找出连接所有用户的路径，了解网络的连通性。</li></ul><h2 id="事项二-执行C-计划"><a href="#事项二-执行C-计划" class="headerlink" title="事项二 执行C#计划"></a>事项二 执行C#计划</h2><h3 id="第四阶段：应用开发（10-12个月）"><a href="#第四阶段：应用开发（10-12个月）" class="headerlink" title="第四阶段：应用开发（10-12个月）"></a>第四阶段：应用开发（10-12个月）</h3><h4 id="学习模块：应用开发技能"><a href="#学习模块：应用开发技能" class="headerlink" title="学习模块：应用开发技能"></a>学习模块：应用开发技能</h4><ol><li><p><strong>ASP.NET Core Web开发</strong></p><ul><li><strong>比喻</strong>：ASP.NET Core Web开发就像搭建一个大型购物中心，你需要规划不同的商店（页面）、通道（路由）和顾客服务点（服务端逻辑）。</li><li><strong>内容</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 定义一个控制器，就像购物中心的接待中心</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StoreController</span> : <span class="hljs-title">Controller</span> &#123;<br>    <span class="hljs-comment">// 定义一个动作，类似于接待中心的特定服务</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IActionResult <span class="hljs-title">Index</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> View(); <span class="hljs-comment">// 显示购物中心的主页面</span><br>    &#125;<br><br>    [<span class="hljs-meta">HttpGet</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IActionResult <span class="hljs-title">Checkout</span>()</span> &#123;<br>        <span class="hljs-comment">// 处理顾客结账的逻辑</span><br>        <span class="hljs-keyword">return</span> View(); <span class="hljs-comment">// 显示结账页面</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>异步编程（Asynchronous Programming）</strong></p><ul><li><strong>比喻</strong>：异步编程就像是在线购物，你下了订单（发起异步任务），然后可以继续浏览其他商品（继续执行其他代码），订单准备好了（任务完成），系统会通知你（回调）。</li><li><strong>内容</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 定义一个异步方法，模拟数据库查询</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">FetchDataAsync</span>()</span> &#123;<br>    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟数据库查询的延迟</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Data retrieved asynchronously&quot;</span>; <span class="hljs-comment">// 返回查询结果</span><br>&#125;<br><br><span class="hljs-comment">// 在控制器中使用异步方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;IActionResult&gt; <span class="hljs-title">DataAsync</span>()</span> &#123;<br>    <span class="hljs-keyword">var</span> data = <span class="hljs-keyword">await</span> FetchDataAsync(); <span class="hljs-comment">// 等待异步操作完成</span><br>    <span class="hljs-keyword">return</span> View(data); <span class="hljs-comment">// 将数据传递给视图</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>安全性（Security）</strong></p><ul><li><strong>比喻</strong>：Web应用的安全性就像购物中心的安保系统，保护顾客（用户）和商店（应用）不受盗窃（数据泄露）和其他威胁。</li><li><strong>内容</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 使用过滤器来要求认证，就像购物中心的入口安检</span><br>[<span class="hljs-meta">Authorize</span>] <span class="hljs-comment">// 确保只有认证用户可以访问</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> IActionResult <span class="hljs-title">SecureData</span>()</span> &#123;<br>    <span class="hljs-keyword">return</span> View(); <span class="hljs-comment">// 显示受保护的数据</span><br>&#125;<br><br><span class="hljs-comment">// 使用HTTPS，就像加密的通信线路，防止数据被窃听</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Configure</span>(<span class="hljs-params">IApplicationBuilder app</span>)</span> &#123;<br>    app.UseHttpsRedirection(); <span class="hljs-comment">// 重定向到HTTPS</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>性能优化（Performance Optimization）</strong></p><ul><li><strong>比喻</strong>：性能优化就像是购物中心的交通规划，确保顾客流动顺畅（减少页面加载时间），避免拥堵（提高响应速度）。</li><li><strong>内容</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 使用缓存来存储重复请求的结果，减少数据库访问</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> IActionResult <span class="hljs-title">CachedData</span>()</span> &#123;<br>    <span class="hljs-keyword">var</span> data = Cache.GetOrCreate(<span class="hljs-string">&quot;myCacheKey&quot;</span>, entry =&gt; &#123;<br>        entry.SetAbsoluteExpiration(TimeSpan.FromMinutes(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 设置缓存过期时间</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Expensive data&quot;</span>; <span class="hljs-comment">// 模拟获取昂贵的数据</span><br>    &#125;);<br>    <span class="hljs-keyword">return</span> Content(data); <span class="hljs-comment">// 返回缓存的数据</span><br>&#125;<br><br><span class="hljs-comment">// 使用异步I/O操作来提高性能</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;FileResult&gt; <span class="hljs-title">DownloadFileAsync</span>()</span> &#123;<br>    <span class="hljs-keyword">var</span> filePath = <span class="hljs-string">&quot;path/to/file&quot;</span>; <span class="hljs-comment">// 文件路径</span><br>    <span class="hljs-keyword">var</span> file = <span class="hljs-keyword">new</span> FileStream(filePath, FileMode.Open); <span class="hljs-comment">// 打开文件流</span><br>    <span class="hljs-keyword">return</span> File(file, <span class="hljs-string">&quot;application/octet-stream&quot;</span>); <span class="hljs-comment">// 异步发送文件</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>测试（Testing）</strong></p><ul><li><strong>比喻</strong>：测试就像是购物中心的消防演习，通过模拟各种情况来确保在真实情况下可以正常运行，及时发现并解决问题。</li><li><strong>内容</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 编写单元测试，确保方法按预期工作</span><br>[<span class="hljs-meta">Fact</span>] <span class="hljs-comment">// 表示这是一个测试用例</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add_TwoNumbers_ReturnsCorrectSum</span>()</span> &#123;<br>    <span class="hljs-keyword">var</span> calculator = <span class="hljs-keyword">new</span> Calculator(); <span class="hljs-comment">// 创建一个计算器实例</span><br>    <span class="hljs-keyword">var</span> result = calculator.Add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 调用加法方法</span><br>    Assert.Equal(<span class="hljs-number">5</span>, result); <span class="hljs-comment">// 断言结果应该是5</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>部署（Deployment）</strong></p><ul><li><strong>比喻</strong>：部署就像是购物中心的开业准备，确保所有设施（应用组件）都已就绪，可以迎接顾客（用户）。</li><li><strong>内容</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 使用Docker容器化应用，简化部署过程</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConfigureContainer</span>(<span class="hljs-params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (env.IsDevelopment()) &#123;<br>        app.UseDeveloperExceptionPage(); <span class="hljs-comment">// 开发环境使用异常页面</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        app.UseExceptionHandler(<span class="hljs-string">&quot;/Error&quot;</span>); <span class="hljs-comment">// 生产环境使用自定义错误页面</span><br>    &#125;<br><br>    app.UseDocker(); <span class="hljs-comment">// 使用Docker容器</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>通过这些生动的比喻和详细的代码示例，你可以更深入地理解如何将C#和.NET Core技能应用于实际的Web开发项目中。这些技能将帮助你构建安全、高效、可维护的Web应用程序。</p><h2 id="事项三-智能仓库管理系统现场调研"><a href="#事项三-智能仓库管理系统现场调研" class="headerlink" title="事项三 智能仓库管理系统现场调研"></a>事项三 智能仓库管理系统现场调研</h2><p>作为一位高级软件开发工程师、业务分析师、智能仓库管理员和现场调研工程师，前往A地的B仓库进行现场调研的目的是采集现场需求，为智能仓库系统WMS的开发提供支持。以下是一份完整的调研流程，以及调研过程中需要注意的事项和应避免的事情：</p><h3 id="调研流程"><a href="#调研流程" class="headerlink" title="调研流程"></a>调研流程</h3><h4 id="1-准备阶段"><a href="#1-准备阶段" class="headerlink" title="1. 准备阶段"></a>1. 准备阶段</h4><ul><li><strong>目标</strong>：确保调研工具和材料的完备性。</li><li><strong>步骤</strong>：<ul><li>确定调研目标和关键问题。</li><li>准备调研问卷、访谈指南和观察表。</li><li>与B仓库管理层沟通，了解基本的仓库运营情况。</li></ul></li></ul><h4 id="2-到达现场"><a href="#2-到达现场" class="headerlink" title="2. 到达现场"></a>2. 到达现场</h4><ul><li><strong>目标</strong>：初步了解仓库环境和布局。</li><li><strong>步骤</strong>：<ul><li>安全培训和现场规则介绍。</li><li>初步观察仓库布局、设备和流程。</li></ul></li></ul><h4 id="3-管理层访谈"><a href="#3-管理层访谈" class="headerlink" title="3. 管理层访谈"></a>3. 管理层访谈</h4><ul><li><strong>目标</strong>：了解管理层对智能仓库系统的期望和需求。</li><li><strong>步骤</strong>：<ul><li>安排访谈，了解业务目标和管理需求。</li><li>讨论当前仓库管理的挑战和痛点。</li></ul></li></ul><h4 id="4-员工访谈"><a href="#4-员工访谈" class="headerlink" title="4. 员工访谈"></a>4. 员工访谈</h4><ul><li><strong>目标</strong>：收集一线员工对现有流程的看法和改进建议。</li><li><strong>步骤</strong>：<ul><li>与不同岗位的员工进行访谈。</li><li>收集关于工作流程、设备使用和系统操作的反馈。</li></ul></li></ul><h4 id="5-现场观察"><a href="#5-现场观察" class="headerlink" title="5. 现场观察"></a>5. 现场观察</h4><ul><li><strong>目标</strong>：观察实际工作流程和操作，识别潜在问题。</li><li><strong>步骤</strong>：<ul><li>观察货物的接收、存储、拣选和发货流程。</li><li>注意操作中的瓶颈、错误和不一致之处。</li></ul></li></ul><h4 id="6-数据收集"><a href="#6-数据收集" class="headerlink" title="6. 数据收集"></a>6. 数据收集</h4><ul><li><strong>目标</strong>：收集与仓库操作相关的数据和指标。</li><li><strong>步骤</strong>：<ul><li>收集库存数据、订单信息和性能指标。</li><li>记录设备使用情况和维护记录。</li></ul></li></ul><h4 id="7-技术评估"><a href="#7-技术评估" class="headerlink" title="7. 技术评估"></a>7. 技术评估</h4><ul><li><strong>目标</strong>：评估现有技术基础设施和潜在的技术需求。</li><li><strong>步骤</strong>：<ul><li>评估现有硬件和软件的兼容性和扩展性。</li><li>确定技术升级和集成的需求。</li></ul></li></ul><h4 id="8-用户需求分析"><a href="#8-用户需求分析" class="headerlink" title="8. 用户需求分析"></a>8. 用户需求分析</h4><ul><li><strong>目标</strong>：分析用户需求，确定系统功能和性能要求。</li><li><strong>步骤</strong>：<ul><li>根据访谈和观察结果，归纳用户需求。</li><li>确定系统必须满足的关键功能和性能指标。</li></ul></li></ul><h4 id="9-调研总结"><a href="#9-调研总结" class="headerlink" title="9. 调研总结"></a>9. 调研总结</h4><ul><li><strong>目标</strong>：整理调研结果，准备报告。</li><li><strong>步骤</strong>：<ul><li>汇总所有收集到的信息和数据。</li><li>撰写调研报告，包括发现的问题和建议。</li></ul></li></ul><h4 id="10-反馈和建议"><a href="#10-反馈和建议" class="headerlink" title="10. 反馈和建议"></a>10. 反馈和建议</h4><ul><li><strong>目标</strong>：向B仓库管理层提供调研反馈和改进建议。</li><li><strong>步骤</strong>：<ul><li>讨论调研结果和建议的实施可能性。</li><li>提供详细的改进方案和时间表。</li></ul></li></ul><h3 id="调研过程中需要注意的事项"><a href="#调研过程中需要注意的事项" class="headerlink" title="调研过程中需要注意的事项"></a>调研过程中需要注意的事项</h3><ul><li><strong>尊重文化和流程</strong>：每个仓库都有自己的工作文化和流程，调研时应尊重并试图理解这些差异。</li><li><strong>安全第一</strong>：始终遵守仓库的安全规则，穿戴必要的安全装备。</li><li><strong>全面收集信息</strong>：确保从不同层级和岗位收集信息，以获得全面的视角。</li><li><strong>保持客观和中立</strong>：在分析和报告时保持客观，避免个人偏见影响结果。</li><li><strong>保护隐私</strong>：在收集和处理数据时，确保遵守隐私保护规定。</li></ul><h3 id="应避免的事情"><a href="#应避免的事情" class="headerlink" title="应避免的事情"></a>应避免的事情</h3><ul><li><strong>避免干扰正常运营</strong>：在调研过程中，尽量避免干扰仓库的正常工作流程。</li><li><strong>避免单方面决策</strong>：不要仅根据个人经验或偏好做出判断，而应基于收集到的数据和信息。</li><li><strong>避免过度承诺</strong>：在调研阶段，避免对可能的解决方案或改进措施做出过度承诺。</li><li><strong>避免忽视细节</strong>：注意观察操作中的小细节，因为它们可能是改进的关键。</li></ul><p>通过遵循上述调研流程和注意事项，您可以确保收集到高质量的数据和信息，为智能仓库系统WMS的开发提供坚实的基础。 </p>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日事项-2024年7月3日</title>
    <link href="/2024/07/03/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%883%E6%97%A5/"/>
    <url>/2024/07/03/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%883%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="今日事项-2024年7月3日"><a href="#今日事项-2024年7月3日" class="headerlink" title="今日事项-2024年7月3日"></a>今日事项-2024年7月3日</h1><h2 id="事项一-收集3个实用的算法"><a href="#事项一-收集3个实用的算法" class="headerlink" title="事项一 收集3个实用的算法"></a>事项一 收集3个实用的算法</h2><h3 id="1-拓扑排序（Topological-Sort）"><a href="#1-拓扑排序（Topological-Sort）" class="headerlink" title="1. 拓扑排序（Topological Sort）"></a>1. 拓扑排序（Topological Sort）</h3><h4 id="产生原因与背景："><a href="#产生原因与背景：" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你正在安排一场多阶段的赛车比赛，每场比赛的开始都依赖于前一场比赛的结束。拓扑排序就是用来处理这种任务的顺序问题，确保每个任务（或比赛）在它的先决条件完成后才开始。</p><h4 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h4><p>拓扑排序就像是一位赛事组织者在安排赛程，他会先列出所有比赛的依赖关系，然后确定一个顺序，使得每场比赛都在它的所有先决条件之后进行。</p><h4 id="代码案列："><a href="#代码案列：" class="headerlink" title="代码案列："></a>代码案列：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">topological_sort</span>(<span class="hljs-params">graph</span>):<br>    <span class="hljs-comment"># 计算图中每个节点的入度</span><br>    in_degree = &#123;u: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph&#125;<br>    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph:<br>        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph[u]:<br>            in_degree[v] += <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 用队列存储所有入度为0的节点</span><br>    queue = deque([u <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph <span class="hljs-keyword">if</span> in_degree[u] == <span class="hljs-number">0</span>])<br>    sorted_order = []<br><br>    <span class="hljs-keyword">while</span> queue:<br>        <span class="hljs-comment"># 取出队列中的一个节点，它不依赖于任何其他节点</span><br>        node = queue.popleft()<br>        sorted_order.append(node)<br><br>        <span class="hljs-comment"># 减少相邻节点的入度，并把入度为0的节点加入队列</span><br>        <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[node]:<br>            in_degree[neighbor] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> in_degree[neighbor] == <span class="hljs-number">0</span>:<br>                queue.append(neighbor)<br><br>    <span class="hljs-comment"># 如果排序后的节点数不等于图中的节点数，说明存在环</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sorted_order) != <span class="hljs-built_in">len</span>(graph):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Graph has a cycle and cannot be topologically sorted&quot;</span>)<br><br>    <span class="hljs-keyword">return</span> sorted_order<br><br><span class="hljs-comment"># 使用示例</span><br>graph = &#123;<br>    <span class="hljs-string">&#x27;A&#x27;</span>: [<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>],<br>    <span class="hljs-string">&#x27;B&#x27;</span>: [<span class="hljs-string">&#x27;D&#x27;</span>],<br>    <span class="hljs-string">&#x27;C&#x27;</span>: [<span class="hljs-string">&#x27;D&#x27;</span>],<br>    <span class="hljs-string">&#x27;D&#x27;</span>: []<br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Topological sort order:&quot;</span>, topological_sort(graph))<br></code></pre></td></tr></table></figure><h4 id="算法优缺点："><a href="#算法优缺点：" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：拓扑排序可以高效地处理任务调度问题，时间复杂度为O(V+E)，其中V是顶点数，E是边数。<br>缺点：如果图中存在环，拓扑排序无法完成，因为存在环意味着某些任务将永远无法开始。</p><h4 id="解决缺点的方法："><a href="#解决缺点的方法：" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>在执行拓扑排序前，可以检测图中是否存在环，如果存在环，则报告错误或采取其他措施。</p><h4 id="解决缺点后的代码案例："><a href="#解决缺点后的代码案例：" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（上面的代码已经包含了环的检测）</p><h4 id="算法的3个实际应用案例："><a href="#算法的3个实际应用案例：" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>课程规划</strong>：安排课程顺序，确保先修课程在后修课程之前。</li><li><strong>项目管理</strong>：确定项目中任务的执行顺序，以满足依赖关系。</li><li><strong>依赖性解析</strong>：在软件包管理系统中，确保包的依赖性按正确的顺序安装。</li></ul><h3 id="2-克鲁斯卡尔算法（Kruskal’s-Algorithm）"><a href="#2-克鲁斯卡尔算法（Kruskal’s-Algorithm）" class="headerlink" title="2. 克鲁斯卡尔算法（Kruskal’s Algorithm）"></a>2. 克鲁斯卡尔算法（Kruskal’s Algorithm）</h3><h4 id="产生原因与背景：-1"><a href="#产生原因与背景：-1" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你要连接一片分散的岛屿，每座岛屿之间可以通过建造桥梁来连接，但每座桥梁的建造成本不同。克鲁斯卡尔算法就是用来找到连接所有岛屿的最小成本方案。</p><h4 id="算法思路：-1"><a href="#算法思路：-1" class="headerlink" title="算法思路："></a>算法思路：</h4><p>克鲁斯卡尔算法就像是一位精明的工程师在设计桥梁，他会先找出成本最低的桥梁，然后依次选择成本递增的桥梁，直到所有的岛屿都连接起来。</p><h4 id="代码案列：-1"><a href="#代码案列：-1" class="headerlink" title="代码案列："></a>代码案列：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">kruskal</span>(<span class="hljs-params">graph</span>):<br>    <span class="hljs-comment"># 将所有边按照权重从小到大排序</span><br>    edges = <span class="hljs-built_in">sorted</span>(graph[<span class="hljs-string">&#x27;edges&#x27;</span>], key=<span class="hljs-keyword">lambda</span> item: item[<span class="hljs-number">2</span>])<br><br>    <span class="hljs-comment"># 创建并查集</span><br>    parent = &#123;node: node <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph[<span class="hljs-string">&#x27;nodes&#x27;</span>]&#125;<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">node</span>):<br>        <span class="hljs-comment"># 路径压缩</span><br>        <span class="hljs-keyword">if</span> parent[node] != node:<br>            parent[node] = find(parent[node])<br>        <span class="hljs-keyword">return</span> parent[node]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">node1, node2</span>):<br>        root1 = find(node1)<br>        root2 = find(node2)<br>        <span class="hljs-keyword">if</span> root1 != root2:<br>            parent[root2] = root1<br><br>    <span class="hljs-comment"># 初始化最小生成树的权重和边</span><br>    mst_weight = <span class="hljs-number">0</span><br>    mst_edges = []<br><br>    <span class="hljs-comment"># 按排序后的顺序选择边</span><br>    <span class="hljs-keyword">for</span> node1, node2, weight <span class="hljs-keyword">in</span> edges:<br>        root1 = find(node1)<br>        root2 = find(node2)<br>        <span class="hljs-comment"># 如果边的两个节点不属于同一棵树，则添加到MST</span><br>        <span class="hljs-keyword">if</span> root1 != root2:<br>            union(node1, node2)<br>            mst_edges.append((node1, node2, weight))<br>            mst_weight += weight<br><br>    <span class="hljs-keyword">return</span> mst_edges, mst_weight<br><br><span class="hljs-comment"># 使用示例</span><br>graph = &#123;<br>    <span class="hljs-string">&#x27;nodes&#x27;</span>: [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>],<br>    <span class="hljs-string">&#x27;edges&#x27;</span>: [<br>        (<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-number">1</span>),<br>        (<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">3</span>),<br>        (<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-number">4</span>),<br>        (<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-number">2</span>)<br>    ]<br>&#125;<br>mst_edges, mst_weight = kruskal(graph)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Edges in the Minimum Spanning Tree:&quot;</span>, mst_edges)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Total weight of the Minimum Spanning Tree:&quot;</span>, mst_weight)<br></code></pre></td></tr></table></figure><h4 id="算法优缺点：-1"><a href="#算法优缺点：-1" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：克鲁斯卡尔算法可以高效地找到无向图的最小生成树，时间复杂度为O(E log E)，其中E是边数。<br>缺点：如果图是稠密的，边数接近顶点数的平方，排序边的步骤可能会影响性能。</p><h4 id="解决缺点的方法：-1"><a href="#解决缺点的方法：-1" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>对于稠密图，可以考虑使用Prim算法或其他更适合稠密图的最小生成树算法。</p><h4 id="解决缺点后的代码案例：-1"><a href="#解决缺点后的代码案例：-1" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（克鲁斯卡尔算法本身已经是一个高效的算法）</p><h4 id="算法的3个实际应用案例：-1"><a href="#算法的3个实际应用案例：-1" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>网络设计</strong>：在设计计算机网络时，选择成本最低的连接方案。</li><li><strong>电路板布线</strong>：在电路板设计中，找到连接所有组件的最短路径。</li><li><strong>城市规划</strong>：在城市规划中，确定连接各个区域的最低成本交通网络。</li></ul><h3 id="3-傅里叶变换（Fast-Fourier-Transform-FFT）"><a href="#3-傅里叶变换（Fast-Fourier-Transform-FFT）" class="headerlink" title="3. 傅里叶变换（Fast Fourier Transform, FFT）"></a>3. 傅里叶变换（Fast Fourier Transform, FFT）</h3><h4 id="产生原因与背景：-2"><a href="#产生原因与背景：-2" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你是一位音乐制作人，需要分析一段音乐中的不同音调。傅里叶变换可以帮你将时域信号转换为频域信号，从而分析音乐的组成。</p><h4 id="算法思路：-2"><a href="#算法思路：-2" class="headerlink" title="算法思路："></a>算法思路：</h4><p>傅里叶变换就像是一位调音师在调音，他会听一段音乐并识别出不同频率的音调，然后将这些音调的强度和频率记录下来。</p><h4 id="代码案列：-2"><a href="#代码案列：-2" class="headerlink" title="代码案列："></a>代码案列：</h4><p>略（傅里叶变换的实现较为复杂，通常使用递归和迭代）</p><h4 id="算法优缺点：-2"><a href="#算法优缺点：-2" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：快速傅里叶变换是傅里叶变换的高效实现，时间复杂度为O(n log n)，非常适合处理长序列数据。<br>缺点：FFT要求输入数据的长度为2的幂，对于不符合要求的数据需要零填充，这可能会影响性能。</p><h4 id="解决缺点的方法：-2"><a href="#解决缺点的方法：-2" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>使用原始的傅里叶变换或其他信号处理技术来处理非2的幂长度的数据。</p><h4 id="解决缺点后的代码案例：-2"><a href="#解决缺点后的代码案例：-2" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（FFT的实现通常依赖于特定的数学库）</p><h4 id="算法的3个实际应用案例：-2"><a href="#算法的3个实际应用案例：-2" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>音频处理</strong>：在音频编辑和效果添加中，分析和处理音频信号。</li><li><strong>图像处理</strong>：在图像压缩和分析中，转换图像数据到频域进行操作。</li><li><strong>信号检测</strong>：在通信系统中，检测和分析信号中的不同频率成分。</li></ul><h2 id="事项二-测试WCS、WMS的导入功能"><a href="#事项二-测试WCS、WMS的导入功能" class="headerlink" title="事项二 测试WCS、WMS的导入功能"></a>事项二 测试WCS、WMS的导入功能</h2>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日事项-2024年7月2日</title>
    <link href="/2024/07/02/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%882%E6%97%A5/"/>
    <url>/2024/07/02/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B47%E6%9C%882%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="今日事项-2024年7月2日"><a href="#今日事项-2024年7月2日" class="headerlink" title="今日事项-2024年7月2日"></a>今日事项-2024年7月2日</h1><h2 id="事项一-收集3个经典算法"><a href="#事项一-收集3个经典算法" class="headerlink" title="事项一 收集3个经典算法"></a>事项一 收集3个经典算法</h2><h3 id="1-堆排序（Heap-Sort）"><a href="#1-堆排序（Heap-Sort）" class="headerlink" title="1. 堆排序（Heap Sort）"></a>1. 堆排序（Heap Sort）</h3><p><img src="/img/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%A4%BA%E4%BE%8B.gif" alt="堆排序示例" title="堆排序示例"></p><h4 id="产生原因与背景："><a href="#产生原因与背景：" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你在经营一家水果摊，需要将水果根据大小快速地分成几堆，以便顾客能迅速挑选。堆排序算法就是基于这种“分堆”的思想，它先将数组构建成一个大顶堆，然后依次将堆顶元素（最大或最小元素）移动到正确的位置。</p><h4 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h4><p>堆排序就像是一位精明的摊主在整理水果摊，他先将所有的水果根据大小堆成几堆，然后从最大的一堆开始，将水果一个个地放到货架上，直到所有的水果都摆放整齐。</p><h4 id="代码案列："><a href="#代码案列：" class="headerlink" title="代码案列："></a>代码案列：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">arr, n, i</span>):<br>    <span class="hljs-comment"># 将数组从下标i的元素开始，调整为最大堆</span><br>    largest = i  <span class="hljs-comment"># 假设当前元素是最大值的位置</span><br>    left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>  <span class="hljs-comment"># 左子节点</span><br>    right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>  <span class="hljs-comment"># 右子节点</span><br><br>    <span class="hljs-comment"># 检查是否存在左子节点，并且值大于当前假设的最大值</span><br>    <span class="hljs-keyword">if</span> left &lt; n <span class="hljs-keyword">and</span> arr[left] &gt; arr[largest]:<br>        largest = left<br><br>    <span class="hljs-comment"># 检查是否存在右子节点，并且值大于当前最大值</span><br>    <span class="hljs-keyword">if</span> right &lt; n <span class="hljs-keyword">and</span> arr[right] &gt; arr[largest]:<br>        largest = right<br><br>    <span class="hljs-comment"># 如果最大值不是当前元素，则交换它们，并继续调整堆</span><br>    <span class="hljs-keyword">if</span> largest != i:<br>        arr[i], arr[largest] = arr[largest], arr[i]<br>        heapify(arr, n, largest)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">heap_sort</span>(<span class="hljs-params">arr</span>):<br>    n = <span class="hljs-built_in">len</span>(arr)<br><br>    <span class="hljs-comment"># 构建最大堆</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n // <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        heapify(arr, n, i)<br><br>    <span class="hljs-comment"># 依次取出堆顶元素并调整堆</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>        arr[i], arr[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>], arr[i]  <span class="hljs-comment"># 交换堆顶元素与最后一个元素</span><br>        heapify(arr, i, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 调整堆</span><br><br><span class="hljs-comment"># 使用示例</span><br>array = [<span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<br>heap_sort(array)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Sorted array:&quot;</span>, array)<br></code></pre></td></tr></table></figure><h4 id="算法优缺点："><a href="#算法优缺点：" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：堆排序是一种原地排序算法，它不需要额外的存储空间，且时间复杂度为O(n log n)。<br>缺点：堆排序不是稳定的排序算法，相同的元素在排序后可能会改变原来的顺序。</p><h4 id="解决缺点的方法："><a href="#解决缺点的方法：" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>由于堆排序的主要缺点是不稳定，可以通过在构建堆的过程中存储元素的原始索引，然后在比较时使用这些索引来保持稳定性。</p><h4 id="解决缺点后的代码案例："><a href="#解决缺点后的代码案例：" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（实现稳定版本的堆排序较为复杂，通常涉及额外的数据结构）</p><h4 id="算法的3个实际应用案例："><a href="#算法的3个实际应用案例：" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>操作系统</strong>：用于进程调度，快速获取优先级最高的进程。</li><li><strong>优先队列</strong>：在网络和图形界面应用中，用于任务调度和管理。</li><li><strong>比赛排名</strong>：在体育比赛中，快速根据得分高低对参赛者进行排名。</li></ul><h3 id="2-贝尔曼-福特算法（Bellman-Ford-Algorithm）"><a href="#2-贝尔曼-福特算法（Bellman-Ford-Algorithm）" class="headerlink" title="2. 贝尔曼-福特算法（Bellman-Ford Algorithm）"></a>2. 贝尔曼-福特算法（Bellman-Ford Algorithm）</h3><h4 id="产生原因与背景：-1"><a href="#产生原因与背景：-1" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你要在一个充满各种路况的道路网上规划一条从家到学校的路线，即使某些路段可能会突然改变通行费用（如修路造成的临时绕行）。贝尔曼-福特算法可以帮你找到所有可能路线中的最短路径，即使存在负权边。</p><h4 id="算法思路：-1"><a href="#算法思路：-1" class="headerlink" title="算法思路："></a>算法思路：</h4><p>贝尔曼-福特算法就像是一位旅行者在规划他的旅程，他考虑了所有可能的路线，包括那些可能会因为特殊情况而改变的路线，然后从中选择一条最短的路线。</p><h4 id="代码案列：-1"><a href="#代码案列：-1" class="headerlink" title="代码案列："></a>代码案列：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bellman_ford</span>(<span class="hljs-params">graph, source</span>):<br>    <span class="hljs-comment"># 初始化距离数组，所有节点到源点的距离为无穷大，除了源点自身</span><br>    distances = &#123;node: <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>) <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph&#125;<br>    distances[source] = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 重复|V|-1次，其中|V|是顶点数</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph) - <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph:<br>            <span class="hljs-keyword">for</span> neighbor, weight <span class="hljs-keyword">in</span> graph[node].items():<br>                <span class="hljs-comment"># 如果通过当前节点到邻居节点的距离更短，则更新距离</span><br>                new_distance = distances[node] + weight<br>                <span class="hljs-keyword">if</span> new_distance &lt; distances[neighbor]:<br>                    distances[neighbor] = new_distance<br><br>    <span class="hljs-comment"># 检查是否存在负权环</span><br>    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph:<br>        <span class="hljs-keyword">for</span> neighbor, weight <span class="hljs-keyword">in</span> graph[node].items():<br>            <span class="hljs-keyword">if</span> distances[node] + weight &lt; distances[neighbor]:<br>                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Graph contains a negative-weight cycle&quot;</span>)<br><br>    <span class="hljs-keyword">return</span> distances<br><br><span class="hljs-comment"># 使用示例</span><br>graph = &#123;<br>    <span class="hljs-string">&#x27;A&#x27;</span>: &#123;<span class="hljs-string">&#x27;B&#x27;</span>: -<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">4</span>&#125;,<br>    <span class="hljs-string">&#x27;B&#x27;</span>: &#123;<span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-number">2</span>&#125;,<br>    <span class="hljs-string">&#x27;C&#x27;</span>: &#123;&#125;,<br>    <span class="hljs-string">&#x27;D&#x27;</span>: &#123;<span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">5</span>&#125;<br>&#125;<br>source = <span class="hljs-string">&#x27;A&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Shortest distances from&quot;</span>, source, <span class="hljs-string">&quot;:&quot;</span>, bellman_ford(graph, source))<br></code></pre></td></tr></table></figure><h4 id="算法优缺点：-1"><a href="#算法优缺点：-1" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：贝尔曼-福特算法可以处理图中的负权边，并且能够检测负权环。<br>缺点：算法的时间复杂度为O(|V| * |E|)，在|E|接近|V|^2的稠密图中效率较低。</p><h4 id="解决缺点的方法：-1"><a href="#解决缺点的方法：-1" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>对于不包含负权边的图，可以使用更高效的算法，如迪杰斯特拉算法。</p><h4 id="解决缺点后的代码案例：-1"><a href="#解决缺点后的代码案例：-1" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（迪杰斯特拉算法已经在上文中给出）</p><h4 id="算法的3个实际应用案例：-1"><a href="#算法的3个实际应用案例：-1" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>路网导航</strong>：在存在临时道路施工或通行费变更的情况下，计算最短路径。</li><li><strong>金融分析</strong>：在金融市场中，评估不同投资组合的风险和回报。</li><li><strong>供应链优化</strong>：在存在多种运输成本和时间的情况下，找到成本最低的运输路径。</li></ul><h3 id="3-霍夫曼编码（Huffman-Coding）"><a href="#3-霍夫曼编码（Huffman-Coding）" class="headerlink" title="3. 霍夫曼编码（Huffman Coding）"></a>3. 霍夫曼编码（Huffman Coding）</h3><h4 id="产生原因与背景：-2"><a href="#产生原因与背景：-2" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你正在编写一本使用特定词汇的书，想要最小化这本书的存储空间。霍夫曼编码通过为出现频率高的词汇分配较短的编码，为频率低的词汇分配较长的编码，从而最小化整体的存储空间。</p><h4 id="算法思路：-2"><a href="#算法思路：-2" class="headerlink" title="算法思路："></a>算法思路：</h4><p>霍夫曼编码就像是一位精明的图书管理员，他为图书馆中常见的书籍分配较短的索引号，而不常见的书籍分配较长的索引号，这样在查找书籍时，平均查找时间就会减少。</p><h4 id="代码案列：-2"><a href="#代码案列：-2" class="headerlink" title="代码案列："></a>代码案列：</h4><p>略（霍夫曼编码的实现较为复杂，通常涉及树结构和优先队列）</p><h4 id="算法优缺点：-2"><a href="#算法优缺点：-2" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：霍夫曼编码是一种非常有效的数据压缩方法，特别是在处理非均匀分布的数据时。<br>缺点：编码和解码过程需要额外的存储空间来存储编码表，并且对于小数据集可能不是最高效的方法。</p><h4 id="解决缺点的方法：-2"><a href="#解决缺点的方法：-2" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>对于小数据集，可以使用更简单的编码方法，如游程编码。此外，可以使用更高效的数据结构来存储编码表。</p><h4 id="解决缺点后的代码案例：-2"><a href="#解决缺点后的代码案例：-2" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><p>略（霍夫曼编码的实现通常需要使用额外的数据结构）</p><h4 id="算法的3个实际应用案例：-2"><a href="#算法的3个实际应用案例：-2" class="headerlink" title="算法的3个实际应用案例："></a>算法的3个实际应用案例：</h4><ul><li><strong>文件压缩</strong>：在ZIP文件压缩中，使用霍夫曼编码来减少文件大小。</li><li><strong>图像和音频压缩</strong>：在JPEG和MP3等格式中，霍夫曼编码用于减少数据冗余。</li><li><strong>网络传输</strong>：在需要传输大量数据的网络应用中，霍夫曼编码用于减少传输的数据量。</li></ul><h2 id="事项二-执行C-计划"><a href="#事项二-执行C-计划" class="headerlink" title="事项二 执行C#计划"></a>事项二 执行C#计划</h2><h3 id="第三阶段：深入理解（7-9个月）"><a href="#第三阶段：深入理解（7-9个月）" class="headerlink" title="第三阶段：深入理解（7-9个月）"></a>第三阶段：深入理解（7-9个月）</h3><h4 id="学习模块：深入理解C-和-NET框架"><a href="#学习模块：深入理解C-和-NET框架" class="headerlink" title="学习模块：深入理解C#和.NET框架"></a>学习模块：深入理解C#和.NET框架</h4><ol><li><p><strong>集合（Collections）</strong></p><ul><li><strong>比喻</strong>：集合就像是超市里的货架，不同的货架用来存放不同种类的商品（元素），而集合框架就是这些货架的规格和设计，确保商品可以有序地存放和检索。</li><li><strong>内容</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 使用List&lt;T&gt;，就像使用超市里的手推车，可以往里面添加或取出商品</span><br>List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">// 创建一个手推车，用来装整数</span><br>numbers.Add(<span class="hljs-number">10</span>); <span class="hljs-comment">// 往手推车里添加一个商品（数字10）</span><br>numbers.Add(<span class="hljs-number">20</span>); <span class="hljs-comment">// 再添加一个商品（数字20）</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> number <span class="hljs-keyword">in</span> numbers) &#123; <span class="hljs-comment">// 遍历手推车里的所有商品</span><br>    Console.WriteLine(number); <span class="hljs-comment">// 打印出每个商品</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>异常处理（Exception Handling）</strong></p><ul><li><strong>比喻</strong>：异常处理就像是超市里的安全系统，当有意外情况（比如商品掉落）发生时，安全系统会启动，确保问题得到妥善处理，超市可以继续正常运营。</li><li><strong>内容</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// 尝试执行以下代码，就像进入超市购物</span><br>    <span class="hljs-built_in">int</span> result = <span class="hljs-number">10</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// 尝试除以零，这会引发异常</span><br>&#125; <span class="hljs-keyword">catch</span> (DivideByZeroException ex) &#123; <span class="hljs-comment">// 捕获异常，就像超市员工处理商品掉落</span><br>    Console.WriteLine(<span class="hljs-string">&quot;Cannot divide by zero: &quot;</span> + ex.Message); <span class="hljs-comment">// 打印错误信息</span><br>&#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// 无论是否发生异常，都会执行的代码，就像超市关门前的清理工作</span><br>    Console.WriteLine(<span class="hljs-string">&quot;Continuing execution...&quot;</span>); <span class="hljs-comment">// 打印继续执行的信息</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>LINQ（Language Integrated Query）</strong></p><ul><li><strong>比喻</strong>：LINQ就像是超市里的智能购物助手，它可以帮助顾客快速找到所需商品，并且提供多种筛选和排序的方式。</li><li><strong>内容</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 假设有一个商品列表</span><br>List&lt;<span class="hljs-built_in">string</span>&gt; products = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt; &#123; <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span> &#125;;<br><span class="hljs-keyword">var</span> expensiveProducts = <span class="hljs-keyword">from</span> p <span class="hljs-keyword">in</span> products <span class="hljs-comment">// 使用LINQ查询商品</span><br>                        <span class="hljs-keyword">where</span> p.Length &gt; <span class="hljs-number">5</span> <span class="hljs-comment">// 筛选出名称长度大于5的商品</span><br>                        <span class="hljs-keyword">orderby</span> p <span class="hljs-comment">// 对筛选出的商品按名称排序</span><br>                        <span class="hljs-keyword">select</span> p; <span class="hljs-comment">// 选择商品</span><br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> product <span class="hljs-keyword">in</span> expensiveProducts) &#123; <span class="hljs-comment">// 遍历查询结果</span><br>    Console.WriteLine(product); <span class="hljs-comment">// 打印每个商品</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>事件和委托（Events and Delegates）</strong></p><ul><li><strong>比喻</strong>：事件和委托就像是超市的会员通知系统。超市（类）可以发布通知（事件），而顾客（对象）可以订阅这些通知，当有特价或促销活动时，超市会通过这个系统通知所有订阅的顾客。</li><li><strong>内容</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 定义一个委托，规定了通知的方法的签名</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PromotionEventHandler</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Supermarket</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> PromotionEventHandler Promotion; <span class="hljs-comment">// 定义一个事件</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AnnouncePromotion</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> product</span>)</span> &#123; <span class="hljs-comment">// 发布特价活动</span><br>        Promotion?.Invoke(<span class="hljs-string">$&quot;There is a promotion on <span class="hljs-subst">&#123;product&#125;</span>!&quot;</span>); <span class="hljs-comment">// 如果有人订阅了事件，就通知他们</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPromotion</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span> &#123; <span class="hljs-comment">// 顾客订阅的事件处理方法</span><br>        Console.WriteLine(message); <span class="hljs-comment">// 接收并打印超市的促销信息</span><br>    &#125;<br>&#125;<br><br>Supermarket market = <span class="hljs-keyword">new</span> Supermarket();<br>Customer customer = <span class="hljs-keyword">new</span> Customer();<br>market.Promotion += customer.OnPromotion; <span class="hljs-comment">// 顾客订阅超市的促销活动通知</span><br>market.AnnouncePromotion(<span class="hljs-string">&quot;Milk&quot;</span>); <span class="hljs-comment">// 超市发布关于牛奶的促销活动</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>异步编程（Asynchronous Programming）</strong></p><ul><li><strong>比喻</strong>：异步编程就像是超市的自助结账机。顾客（程序）不需要一直排队等待（同步等待），而是可以先去挑选其他商品（继续执行其他任务），当结账机准备好了（异步操作完成），顾客再回来完成结账（获取结果）。</li><li><strong>内容</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 定义一个异步方法，模拟数据库查询</span><br><span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">FetchDataFromDatabase</span>()</span> &#123;<br>    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟耗时操作，比如网络延迟</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Data from database&quot;</span>; <span class="hljs-comment">// 返回查询结果</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span> &#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Starting database query...&quot;</span>); <span class="hljs-comment">// 打印开始查询</span><br>    <span class="hljs-keyword">var</span> data = <span class="hljs-keyword">await</span> FetchDataFromDatabase(); <span class="hljs-comment">// 等待异步查询完成</span><br>    Console.WriteLine(<span class="hljs-string">&quot;Query finished: &quot;</span> + data); <span class="hljs-comment">// 打印查询结果</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>通过这些生动的比喻和详细的代码示例，你可以更深入地理解C#的高级特性和.NET框架的强大功能。这些概念和技能将帮助你编写更加高效、灵活且易于维护的代码。</p><h2 id="事项三-学习linux命令"><a href="#事项三-学习linux命令" class="headerlink" title="事项三 学习linux命令"></a>事项三 学习linux命令</h2><h3 id="1-Linux命令的基本分类和用途"><a href="#1-Linux命令的基本分类和用途" class="headerlink" title="1. Linux命令的基本分类和用途"></a>1. Linux命令的基本分类和用途</h3><p>Linux命令可以分为以下几类：</p><ul><li><strong>文件操作</strong>：用于创建、复制、移动、删除文件和目录。</li><li><strong>权限管理</strong>：用于改变文件和目录的权限和所有权。</li><li><strong>文本处理</strong>：用于查看、编辑和处理文本文件。</li><li><strong>系统监控</strong>：用于监控系统资源使用情况，如CPU、内存、磁盘等。</li><li><strong>网络配置</strong>：用于配置和管理网络设置。</li><li><strong>包管理</strong>：用于安装、更新、卸载软件包。</li><li><strong>脚本编写</strong>：用于编写自动化脚本，提高工作效率。</li></ul><h3 id="2-基础命令的列表和详细解释"><a href="#2-基础命令的列表和详细解释" class="headerlink" title="2. 基础命令的列表和详细解释"></a>2. 基础命令的列表和详细解释</h3><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><ul><li><code>ls</code>：列出目录内容<ul><li>示例：<code>ls -l</code> 以长列表格式显示文件和目录详细信息。</li></ul></li><li><code>cd</code>：改变目录<ul><li>示例：<code>cd /home/user</code> 切换到<code>/home/user</code>目录。</li></ul></li><li><code>mkdir</code>：创建目录<ul><li>示例：<code>mkdir newdir</code> 创建一个名为<code>newdir</code>的新目录。</li></ul></li><li><code>rm</code>：删除文件或目录<ul><li>示例：<code>rm file.txt</code> 删除名为<code>file.txt</code>的文件。</li></ul></li></ul><h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><ul><li><code>chmod</code>：改变文件或目录权限<ul><li>示例：<code>chmod 755 script.sh</code> 将<code>script.sh</code>的权限设置为所有者可读可写可执行，组和其他用户可读可执行。</li></ul></li><li><code>chown</code>：改变文件或目录所有者<ul><li>示例：<code>chown user:group file.txt</code> 将<code>file.txt</code>的所有者改为<code>user</code>，组改为<code>group</code>。</li></ul></li></ul><h4 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h4><ul><li><code>top</code>：实时显示系统进程信息<ul><li>示例：直接运行<code>top</code>，然后按<code>q</code>退出。</li></ul></li><li><code>df</code>：显示磁盘空间使用情况<ul><li>示例：<code>df -h</code> 以易读的格式显示磁盘空间。</li></ul></li><li><code>du</code>：查看文件或目录占用的磁盘空间<ul><li>示例：<code>du -sh /home</code> 显示<code>/home</code>目录的总磁盘使用量。</li></ul></li></ul><h3 id="3-高级命令的使用场景和示例"><a href="#3-高级命令的使用场景和示例" class="headerlink" title="3. 高级命令的使用场景和示例"></a>3. 高级命令的使用场景和示例</h3><h4 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h4><ul><li><code>grep</code>：搜索文本文件中的行<ul><li>示例：<code>grep &quot;error&quot; log.txt</code> 搜索<code>log.txt</code>中包含”error”的行。</li></ul></li></ul><h4 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h4><ul><li><code>ifconfig</code>：显示和配置网络接口<ul><li>示例：<code>ifconfig eth0</code> 显示网络接口<code>eth0</code>的配置。</li></ul></li></ul><h4 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h4><ul><li><code>apt-get</code>（Debian系）：软件包管理工具<ul><li>示例：<code>sudo apt-get install vim</code> 安装<code>vim</code>文本编辑器。</li></ul></li></ul><h4 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h4><ul><li><code>bash</code>：运行bash脚本<ul><li>示例：<code>bash script.sh</code> 运行名为<code>script.sh</code>的bash脚本。</li></ul></li></ul><h3 id="4-命令的预期输出"><a href="#4-命令的预期输出" class="headerlink" title="4. 命令的预期输出"></a>4. 命令的预期输出</h3><p>每个命令的输出取决于其参数和系统状态。例如，<code>ls -l</code>将显示文件和目录的详细信息，包括权限、所有者、大小和最后修改时间。</p><p>如果您有特定的命令想要学习或者有任何问题，请随时告诉我，我将为您提供详细的解释和示例。</p>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日事项-2024年6月28日</title>
    <link href="/2024/06/28/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B46%E6%9C%8828%E6%97%A5/"/>
    <url>/2024/06/28/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B46%E6%9C%8828%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="今日事项"><a href="#今日事项" class="headerlink" title="今日事项"></a>今日事项</h1><h2 id="今日事项：2024年6月28日"><a href="#今日事项：2024年6月28日" class="headerlink" title="| 今日事项：2024年6月28日"></a>| 今日事项：2024年6月28日</h2><h3 id="事项一"><a href="#事项一" class="headerlink" title="| 事项一"></a>| 事项一</h3><p>收集3个经典算法案例，并分析它的实现思路，然后上传至个人博客网站上</p><h3 id="1-欧几里得算法（Euclidean-Algorithm）"><a href="#1-欧几里得算法（Euclidean-Algorithm）" class="headerlink" title="1. 欧几里得算法（Euclidean Algorithm）"></a>1. 欧几里得算法（Euclidean Algorithm）</h3><h4 id="产生原因与背景："><a href="#产生原因与背景：" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你在做除法时，想要找到两个数的最大公约数。欧几里得算法就像是用尺子测量布的长度，不断地减去一个较小的尺寸，直到不能再减，剩下的就是两个布匹的最大公约。</p><h4 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h4><p>欧几里得算法就像是不断地找两个数直到剩下一个数为止，每次操作都是将较大的数除以较小的数，然后用除余的结果替换原来的较大数，直到余数为0，最后的除数就是这两个数的最大公约数。</p><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gcd</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-comment"># 只要b不为0，就继续操作</span><br>    <span class="hljs-keyword">while</span> b != <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 将a除以b的余数存储到remainder中</span><br>        remainder = a % b<br>        <span class="hljs-comment"># 将b的值赋给a，remainder的值赋给b</span><br>        a, b = b, remainder<br>    <span class="hljs-comment"># 当b为0时，a就是最大公约数</span><br>    <span class="hljs-keyword">return</span> a<br><br><span class="hljs-comment"># 使用示例</span><br><span class="hljs-built_in">print</span>(gcd(<span class="hljs-number">48</span>, <span class="hljs-number">18</span>))  <span class="hljs-comment"># 输出应该是6</span><br></code></pre></td></tr></table></figure><h4 id="算法优缺点："><a href="#算法优缺点：" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：欧几里得算法非常高效，其时间复杂度是O(log min(a, b))，对于大数计算特别有效。<br>缺点：这个算法只能计算两个整数的最大公约数，对于其他类型的数或更多数量的数无能为力。</p><h4 id="解决缺点的方法："><a href="#解决缺点的方法：" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>如果需要处理更多数量的数，可以迭代地将当前找到的最大公约数与下一个数应用欧几里得算法。</p><h4 id="解决缺点后的代码案例："><a href="#解决缺点后的代码案例：" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gcd_multiple</span>(<span class="hljs-params">numbers</span>):<br>    <span class="hljs-comment"># 从numbers中取出两个数进行计算</span><br>    num1, num2 = numbers[<span class="hljs-number">0</span>], numbers[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> numbers[<span class="hljs-number">2</span>:]:<br>        <span class="hljs-comment"># 迭代地更新最大公约数</span><br>        num1 = gcd(num1, number)<br>    <span class="hljs-keyword">return</span> num1<br><br><span class="hljs-comment"># 使用示例</span><br><span class="hljs-built_in">print</span>(gcd_multiple([<span class="hljs-number">48</span>, <span class="hljs-number">18</span>, <span class="hljs-number">24</span>]))  <span class="hljs-comment"># 输出应该是6</span><br></code></pre></td></tr></table></figure><h4 id="算法的实际应用案例："><a href="#算法的实际应用案例：" class="headerlink" title="算法的实际应用案例："></a>算法的实际应用案例：</h4><ul><li><strong>密码学</strong>：在公钥加密中，需要用到最大公约数来生成密钥。</li><li><strong>音乐理论</strong>：计算音乐中的和声和调式。</li><li><strong>计算机图形学</strong>：在变换和旋转中，使用最大公约数来简化计算。</li></ul><h3 id="2-深度优先搜索（Depth-First-Search-DFS）"><a href="#2-深度优先搜索（Depth-First-Search-DFS）" class="headerlink" title="2. 深度优先搜索（Depth-First Search, DFS）"></a>2. 深度优先搜索（Depth-First Search, DFS）</h3><h4 id="产生原因与背景：-1"><a href="#产生原因与背景：-1" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你在一座错综复杂的迷宫中，想要找到一条通往出口的路。深度优先搜索就像是沿着迷宫的一条路径一直走到底，如果发现是死路，再回溯到上一个分叉路口，尝试另一条路径。</p><h4 id="算法思路：-1"><a href="#算法思路：-1" class="headerlink" title="算法思路："></a>算法思路：</h4><p>深度优先搜索就像是在探索一个未知的森林，每次选择一个方向深入，直到无法前进，然后返回到上一个分叉点，尝试其他方向，直到探索完所有可能的路径。</p><h4 id="代码示例：-1"><a href="#代码示例：-1" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">depth_first_search</span>(<span class="hljs-params">graph, start, visited=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> visited <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        visited = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 创建一个集合来记录访问过的节点</span><br>    visited.add(start)  <span class="hljs-comment"># 将起始节点标记为已访问</span><br>    <span class="hljs-built_in">print</span>(start)  <span class="hljs-comment"># 处理当前节点</span><br><br>    <span class="hljs-comment"># 遍历与当前节点相邻的所有节点</span><br>    <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[start]:<br>        <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>            depth_first_search(graph, neighbor, visited)  <span class="hljs-comment"># 递归地访问未访问的邻居</span><br><br><span class="hljs-comment"># 定义一个图</span><br>graph = &#123;<br>    <span class="hljs-string">&#x27;A&#x27;</span>: [<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>],<br>    <span class="hljs-string">&#x27;B&#x27;</span>: [<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>],<br>    <span class="hljs-string">&#x27;C&#x27;</span>: [<span class="hljs-string">&#x27;F&#x27;</span>],<br>    <span class="hljs-string">&#x27;D&#x27;</span>: [],<br>    <span class="hljs-string">&#x27;E&#x27;</span>: [<span class="hljs-string">&#x27;F&#x27;</span>],<br>    <span class="hljs-string">&#x27;F&#x27;</span>: []<br>&#125;<br><br><span class="hljs-comment"># 执行深度优先搜索</span><br>depth_first_search(graph, <span class="hljs-string">&#x27;A&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="算法优缺点：-1"><a href="#算法优缺点：-1" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：深度优先搜索可以探索图或树中所有的路径，对于查找连接组件或解决谜题特别有效。<br>缺点：如果图很大，深度优先搜索可能会陷入深的分支，导致效率低下。</p><h4 id="解决缺点的方法：-1"><a href="#解决缺点的方法：-1" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>使用迭代深度优先搜索，配合显式栈来避免递归调用，提高效率。</p><h4 id="解决缺点后的代码案例：-1"><a href="#解决缺点后的代码案例：-1" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">iterative_dfs</span>(<span class="hljs-params">graph, start</span>):<br>    stack = [start]  <span class="hljs-comment"># 使用栈来存储待访问的节点</span><br>    visited = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 创建一个集合来记录访问过的节点</span><br><br>    <span class="hljs-keyword">while</span> stack:<br>        vertex = stack.pop()  <span class="hljs-comment"># 取出栈顶的节点</span><br>        <span class="hljs-keyword">if</span> vertex <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>            visited.add(vertex)  <span class="hljs-comment"># 将节点标记为已访问</span><br>            <span class="hljs-built_in">print</span>(vertex)  <span class="hljs-comment"># 处理当前节点</span><br>            <span class="hljs-comment"># 将与当前节点相邻的未访问节点压入栈中</span><br>            stack.extend(neighbor <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[vertex] <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited)<br><br><span class="hljs-comment"># 执行迭代深度优先搜索</span><br>iterative_dfs(graph, <span class="hljs-string">&#x27;A&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="算法的实际应用案例：-1"><a href="#算法的实际应用案例：-1" class="headerlink" title="算法的实际应用案例："></a>算法的实际应用案例：</h4><ul><li><strong>网络爬虫</strong>：在网页抓取中，深度优先搜索可以用来从一个页面开始，探索整个网站。</li><li><strong>社交网络分析</strong>：分析社交网络中的连接模式和社区结构。</li><li><strong>游戏AI</strong>：在游戏开发中，用于角色导航和路径搜索。</li></ul><h3 id="3-动态规划（Dynamic-Programming）"><a href="#3-动态规划（Dynamic-Programming）" class="headerlink" title="3. 动态规划（Dynamic Programming）"></a>3. 动态规划（Dynamic Programming）</h3><h4 id="产生原因与背景：-2"><a href="#产生原因与背景：-2" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>想象你要爬上一段楼梯，可以选择每次爬一个台阶或两个台阶。动态规划就像是记录下每次爬楼梯的方式，这样当你再次经过某个台阶时，就可以直接使用之前的方法，而不必重新考虑。</p><h4 id="算法思路：-2"><a href="#算法思路：-2" class="headerlink" title="算法思路："></a>算法思路：</h4><p>动态规划就像是解决一个拼图，你将大问题分解为小问题，然后解决这些小问题，并将解决方案存储起来。当你需要解决一个大问题时，可以利用这些小问题的解决方案来构造出大问题的解决方案。</p><h4 id="代码示例：-2"><a href="#代码示例：-2" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">climb_stairs</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-comment"># 如果只有一级或两级台阶，只需要1种或2种方法</span><br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> n<br>    <span class="hljs-comment"># 初始化动态规划表格，存储爬到第i级台阶的方法数</span><br>    dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">1</span>], dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><br>    <span class="hljs-comment"># 动态规划填表过程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 爬到第i级台阶的方法数是爬到第i-1级和第i-2级台阶的方法数之和</span><br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]<br><br>    <span class="hljs-comment"># 返回爬到第n级台阶的方法数</span><br>    <span class="hljs-keyword">return</span> dp[n]<br><br><span class="hljs-comment"># 使用示例</span><br><span class="hljs-built_in">print</span>(climb_stairs(<span class="hljs-number">4</span>))  <span class="hljs-comment"># 输出应该是5</span><br></code></pre></td></tr></table></figure><h4 id="算法优缺点：-2"><a href="#算法优缺点：-2" class="headerlink" title="算法优缺点："></a>算法优缺点：</h4><p>优点：动态规划可以高效地解决具有重叠子问题和最优子结构的问题，如优化问题。<br>缺点：动态规划需要存储子问题的解，这可能导致较高的空间复杂度。</p><h4 id="解决缺点的方法：-2"><a href="#解决缺点的方法：-2" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h4><p>使用空间优化技术，如滚动数组，来减少存储需求。</p><h4 id="解决缺点后的代码案例：-2"><a href="#解决缺点后的代码案例：-2" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">climb_stairs_space_optimized</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-comment"># 空间优化：只存储前两个状态</span><br>    first, second = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 计算当前状态，并更新前两个状态</span><br>        first, second = second, first + second<br>    <span class="hljs-keyword">return</span> second<br><br><span class="hljs-comment"># 使用示例</span><br><span class="hljs-built_in">print</span>(climb_stairs_space_optimized(<span class="hljs-number">4</span>))  <span class="hljs-comment"># 输出应该是5</span><br></code></pre></td></tr></table></figure><h4 id="算法的实际应用案例：-2"><a href="#算法的实际应用案例：-2" class="headerlink" title="算法的实际应用案例："></a>算法的实际应用案例：</h4><ul><li><strong>资源分配</strong>：在预算有限的情况下，如何分配资源以最大化效益。</li><li><strong>生物信息学</strong>：在基因序列比对中，找到最优的序列对齐方式。</li><li><strong>网络设计</strong>：在网络路由中，找到数据传输的最优路径。</li></ul><h3 id="事项二"><a href="#事项二" class="headerlink" title="| 事项二"></a>| 事项二</h3><h3 id="执行C-计划"><a href="#执行C-计划" class="headerlink" title="执行C#计划"></a>执行C#计划</h3><h3 id="第二阶段：面向对象编程（4-6个月）"><a href="#第二阶段：面向对象编程（4-6个月）" class="headerlink" title="第二阶段：面向对象编程（4-6个月）"></a>第二阶段：面向对象编程（4-6个月）</h3><h4 id="学习模块：面向对象编程（OOP）"><a href="#学习模块：面向对象编程（OOP）" class="headerlink" title="学习模块：面向对象编程（OOP）"></a>学习模块：面向对象编程（OOP）</h4><ol><li><p><strong>类和对象（Classes and Objects）</strong></p><ul><li><strong>比喻</strong>：想象一下，类是一张制作蛋糕的食谱。食谱上详细列出了制作蛋糕所需的所有材料和步骤，但它本身并不是蛋糕。对象则是根据食谱实际制作出来的蛋糕。每个蛋糕（对象）都是食谱（类）的具体实例，但可以有不同的装饰或口味变化。</li><li><strong>内容</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Cake</span> &#123; <span class="hljs-comment">// 蛋糕食谱</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Flavor; <span class="hljs-comment">// 蛋糕的口味</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Layers; <span class="hljs-comment">// 蛋糕的层数</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Decorate</span>()</span> &#123; <span class="hljs-comment">// 装饰蛋糕的方法</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Decorating the <span class="hljs-subst">&#123;Flavor&#125;</span> cake with <span class="hljs-subst">&#123;Layers&#125;</span> layers.&quot;</span>);<br>    &#125;<br>&#125;<br><br>Cake chocolateCake = <span class="hljs-keyword">new</span> Cake(); <span class="hljs-comment">// 制作一个巧克力蛋糕</span><br>chocolateCake.Flavor = <span class="hljs-string">&quot;Chocolate&quot;</span>; <span class="hljs-comment">// 选择巧克力口味</span><br>chocolateCake.Layers = <span class="hljs-number">2</span>; <span class="hljs-comment">// 决定蛋糕有两层</span><br>chocolateCake.Decorate(); <span class="hljs-comment">// 装饰蛋糕</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>继承（Inheritance）</strong></p><ul><li><strong>比喻</strong>：继承可以比作是一棵家族树。树的根是最基本的类（祖先），而树枝和叶子代表了从祖先继承并发展出的新类（后代）。后代拥有祖先的所有特性，但也可能有一些独特的特征。</li><li><strong>内容</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Eat</span>()</span> &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;The animal is eating.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span> &#123; <span class="hljs-comment">// 狗是动物的一种</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bark</span>()</span> &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;The dog barks.&quot;</span>);<br>    &#125;<br>&#125;<br><br>Dog myDog = <span class="hljs-keyword">new</span> Dog(); <span class="hljs-comment">// 我的狗</span><br>myDog.Eat(); <span class="hljs-comment">// 狗继承了吃的行为</span><br>myDog.Bark(); <span class="hljs-comment">// 狗有独特的叫行为</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>封装（Encapsulation）</strong></p><ul><li><strong>比喻</strong>：封装就像是一个俄罗斯套娃，每个娃娃（对象）都有自己的秘密（私有成员），只能通过特定的方式（公共方法）来与外界交互。</li><li><strong>内容</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BankAccount</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span> balance; <span class="hljs-comment">// 账户余额是私有的，就像套娃的秘密</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deposit</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> amount</span>)</span> &#123; <span class="hljs-comment">// 存款方法</span><br>        <span class="hljs-keyword">if</span> (amount &gt; <span class="hljs-number">0</span>) &#123;<br>            balance += amount;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Deposited <span class="hljs-subst">&#123;amount&#125;</span>. New balance is <span class="hljs-subst">&#123;balance&#125;</span>.&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">GetBalance</span>()</span> &#123; <span class="hljs-comment">// 提供获取余额的方法</span><br>        <span class="hljs-keyword">return</span> balance;<br>    &#125;<br>&#125;<br><br>BankAccount myAccount = <span class="hljs-keyword">new</span> BankAccount();<br>myAccount.Deposit(<span class="hljs-number">100</span>); <span class="hljs-comment">// 存钱</span><br>Console.WriteLine(<span class="hljs-string">$&quot;Current balance: <span class="hljs-subst">&#123;myAccount.GetBalance()&#125;</span>&quot;</span>); <span class="hljs-comment">// 查看余额</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>多态（Polymorphism）</strong></p><ul><li><strong>比喻</strong>：多态可以比作是一把多功能钥匙，它可以打开多种类型的锁（方法）。不同的锁（子类）可能需要不同的开启方式，但钥匙（父类引用）是相同的。</li><li><strong>内容</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Move</span>()</span> &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;The vehicle moves.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> : <span class="hljs-title">Vehicle</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Move</span>()</span> &#123; <span class="hljs-comment">// 重写移动方法</span><br>        Console.WriteLine(<span class="hljs-string">&quot;The car drives.&quot;</span>);<br>    &#125;<br>&#125;<br><br>Vehicle myVehicle = <span class="hljs-keyword">new</span> Car(); <span class="hljs-comment">// 用车辆类型引用汽车对象</span><br>myVehicle.Move(); <span class="hljs-comment">// 根据实际对象类型执行相应的移动方式</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>接口（Interfaces）</strong></p><ul><li><strong>比喻</strong>：接口就像是一个插头规范，不同的设备（类）可以制造出符合这个规范的插头（实现接口），这样它们就可以插入同一个插座（被调用）。</li><li><strong>内容</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IChargeable</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Charge</span>()</span>; <span class="hljs-comment">// 充电的方法</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Smartphone</span> : <span class="hljs-title">IChargeable</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Charge</span>()</span> &#123; <span class="hljs-comment">// 实现充电接口</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Charging the smartphone.&quot;</span>);<br>    &#125;<br>&#125;<br><br>Smartphone myPhone = <span class="hljs-keyword">new</span> Smartphone();<br>myPhone.Charge(); <span class="hljs-comment">// 使用符合规范的充电方法</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><p>通过这些详细的比喻和代码示例，你可以更加生动和形象地理解面向对象编程的基本概念。面向对象编程是一种强大的编程范式，它通过类和对象的抽象，以及继承、封装、多态和接口等机制，帮助我们构建出既灵活又易于维护的软件系统。</p><h3 id="事项三"><a href="#事项三" class="headerlink" title="| 事项三"></a>| 事项三</h3><h4 id="在poe-com上创建一个自己的AI机器人"><a href="#在poe-com上创建一个自己的AI机器人" class="headerlink" title="在poe.com上创建一个自己的AI机器人"></a>在poe.com上创建一个自己的AI机器人</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">name: GPT-4o-Coach<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">photo: C:\Users\admin\Pictures\ComfyUI_00094_.png<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">model: GPT-4o<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs copy">Here is the brief:<br>- Role Name: Personal Coach for GPT-4o<br>- Role Positioning: Expert in personalized guidance for life and work<br>- Core Competencies: Listening, analysis, advising, emotional support<br>- Service Mission: To provide users with personalized and professional guidance to help achieve goals and enhance the quality of life<br>- Applicable Scenarios: Personal growth, career development, emotional management, life planning<br>- User Experience: Friendly, professional, easy to communicate with<br>- Interaction Method: Providing real-time feedback and suggestions through conversation<br>- Privacy Protection: Strictly protecting user privacy to ensure all communications are secure<br>- Continuous Support: Offering long-term companionship and guidance to assist users in continuous improvement<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs copy">Here is the prompt:<br>- Role: Personal Coach for GPT-4o<br>- Background: Users require an artificial intelligence assistant that can provide personalized guidance and communication to help them make progress in learning, work, or life.<br>- Profile: You are an experienced personal coach, skilled in listening, understanding, and guiding users, offering personalized advice and solutions.<br>- Skills: Communication, personalized guidance, problem-solving, emotional support.<br>- Goals: As the user&#x27;s personal coach, you need to help users set goals, make plans, and provide ongoing support and encouragement.<br>- Constraints: Maintain a positive and encouraging attitude, respect user privacy and choices, and provide safe and helpful advice.<br>- OutputFormat: A friendly conversational format, combining specific suggestions and action steps.<br>- Workflow:<br>  1. Welcome the user and understand their needs and goals.<br>  2. Provide personalized advice and guidance based on the user&#x27;s needs.<br>  3. Encourage the user to take action and provide continuous support.<br>- Examples:<br>  User: I&#x27;ve been feeling a lot of stress lately and don&#x27;t know what to do.<br>  Personal Coach 001: I understand how you feel. First, let&#x27;s identify the sources of your stress together. Then, we can explore some stress-relief methods, such as deep breathing exercises, scheduling downtime, or seeking social support.<br>- Initialization: Welcome! I am your Personal Coach for GPT-4o. No matter what challenges you face, I am here to support you. Let&#x27;s get started, please tell me where you need help today.<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs copy">Here is the greeting message：<br>Welcome! I am your Personal Coach for GPT-4o. Whatever assistance you need today, I am here to support you. Let&#x27;s get started, please tell me about your goals or where you need help.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日事项promoto</title>
    <link href="/2024/06/27/%E6%AF%8F%E6%97%A5%E4%BA%8B%E9%A1%B9promoto/"/>
    <url>/2024/06/27/%E6%AF%8F%E6%97%A5%E4%BA%8B%E9%A1%B9promoto/</url>
    
    <content type="html"><![CDATA[<h1 id="每日事项promoto"><a href="#每日事项promoto" class="headerlink" title="每日事项promoto"></a>每日事项promoto</h1><h2 id="算法分享promoto"><a href="#算法分享promoto" class="headerlink" title="| 算法分享promoto"></a>| 算法分享promoto</h2><p>请你分享3个经典算法，按照以下格式输出：<br>产生原因与背景（打比喻的形式、要通俗易懂、易于理解）<br>算法思路（打比喻的形式、要通俗易懂、易于理解）<br>代码案列（每行代码严格加上注释，要通俗易懂）<br>算法优缺点（打比喻的形式、要通俗易懂、易于理解）<br>解决缺点的方法（打比喻的形式、要通俗易懂、易于理解）<br>解决缺点后的代码案例（每行代码严格加上注释，要通俗易懂）<br>算法的3个实际应用案例（打比喻的形式、要通俗易懂、易于理解）</p>]]></content>
    
    
    <categories>
      
      <category>每日事项promoto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日事项promoto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日事项-2024年6月27日</title>
    <link href="/2024/06/27/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B46%E6%9C%8827%E6%97%A5/"/>
    <url>/2024/06/27/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B46%E6%9C%8827%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="今日事项"><a href="#今日事项" class="headerlink" title="今日事项"></a>今日事项</h1><h2 id="今日事项：2024年6月27日"><a href="#今日事项：2024年6月27日" class="headerlink" title="| 今日事项：2024年6月27日"></a>| 今日事项：2024年6月27日</h2><h3 id="事项一"><a href="#事项一" class="headerlink" title="| 事项一"></a>| 事项一</h3><p>收集3个经典算法案例，并分析它的实现思路，然后上传至个人博客网站上</p><h4 id="1-二叉搜索树（Binary-Search-Tree-BST）"><a href="#1-二叉搜索树（Binary-Search-Tree-BST）" class="headerlink" title="1. 二叉搜索树（Binary Search Tree, BST）"></a>1. 二叉搜索树（Binary Search Tree, BST）</h4><h5 id="产生原因与背景："><a href="#产生原因与背景：" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h5><p>想象你在一个巨大的果园中，每棵树代表一个数据元素，而你需要快速找到特定的一棵树。如果所有的树按照某种顺序排列，比如从矮到高，你就可以通过比较来快速定位，跳过那些比你目标高的树（或低的树），这正是二叉搜索树的灵感来源。</p><h5 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h5><p>二叉搜索树就像是按高度排列的果园。从任意一棵树开始，如果你要找的树比你当前的位置矮，你就向左走；如果更高，你就向右走。通过这种方式，你可以快速地定位到目标树，或者确定目标树不存在。</p><h5 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-comment"># 创建一个新树节点，key是树节点的值</span><br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br>        self.val = key<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">root, key</span>):<br>    <span class="hljs-comment"># 如果树为空，插入新节点作为根节点</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> TreeNode(key)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 如果键值小于根节点的值，递归地在左子树插入</span><br>        <span class="hljs-keyword">if</span> key &lt; root.val:<br>            root.left = insert(root.left, key)<br>        <span class="hljs-comment"># 否则，在右子树插入</span><br>        <span class="hljs-keyword">else</span>:<br>            root.right = insert(root.right, key)<br>    <span class="hljs-comment"># 返回根节点，以便可以继续在上面添加节点</span><br>    <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h5 id="算法优缺点："><a href="#算法优缺点：" class="headerlink" title="算法优缺点："></a>算法优缺点：</h5><p>优点：二叉搜索树在平衡的情况下，查找、插入和删除操作都非常快，时间复杂度为O(log n)。<br>缺点：如果树不平衡，即所有节点都只有左或只有右子节点，那么时间复杂度会退化到O(n)。</p><h5 id="解决缺点的方法："><a href="#解决缺点的方法：" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h5><p>通过使用平衡二叉树，如AVL树，每次插入或删除操作后都会进行调整，以保持树的平衡。</p><h5 id="解决缺点后的代码案例："><a href="#解决缺点后的代码案例：" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># AVL树的插入操作示例，这里只展示核心调整部分</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate_right</span>(<span class="hljs-params">y</span>):<br>    <span class="hljs-comment"># 右旋操作，用于保持树的平衡</span><br>    x = y.left<br>    T2 = x.right<br>    x.right = y<br>    y.left = T2<br>    <span class="hljs-keyword">return</span> x<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">insert_avl</span>(<span class="hljs-params">root, key</span>):<br>    <span class="hljs-comment"># 插入节点后，进行平衡调整</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-comment"># 省略了插入和获取平衡因子的代码</span><br>    <span class="hljs-keyword">if</span> balance_factor &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> key &lt; root.left.val:<br>        <span class="hljs-keyword">return</span> rotate_right(root)<br>    <span class="hljs-comment"># 进行其他必要的旋转操作以保持平衡</span><br>    <span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><h5 id="算法的实际应用案例："><a href="#算法的实际应用案例：" class="headerlink" title="算法的实际应用案例："></a>算法的实际应用案例：</h5><ul><li><strong>数据库索引</strong>：快速检索数据记录。</li><li><strong>文件系统</strong>：快速定位文件。</li><li><strong>内存管理</strong>：快速分配和回收内存。</li></ul><h4 id="2-迪杰斯特拉算法（Dijkstra’s-Algorithm）"><a href="#2-迪杰斯特拉算法（Dijkstra’s-Algorithm）" class="headerlink" title="2. 迪杰斯特拉算法（Dijkstra’s Algorithm）"></a>2. 迪杰斯特拉算法（Dijkstra’s Algorithm）</h4><h5 id="产生原因与背景：-1"><a href="#产生原因与背景：-1" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h5><p>想象你要在一张地图上找到从一个城市到所有其他城市的最短路径，如果地图上每个路口都有距离标记，迪杰斯特拉算法就像是一个智能导航系统，帮你规划出最佳路线。</p><h5 id="算法思路：-1"><a href="#算法思路：-1" class="headerlink" title="算法思路："></a>算法思路：</h5><p>迪杰斯特拉算法像是逐步展开的地图，你从起点开始，每次选择最近的未访问城市作为当前位置，然后更新到所有已访问城市的最短路径，直到所有城市都被访问。</p><h5 id="代码示例：-1"><a href="#代码示例：-1" class="headerlink" title="代码示例："></a>代码示例：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dijkstra</span>(<span class="hljs-params">graph, start</span>):<br>    distances = &#123;node: <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;infinity&#x27;</span>) <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph&#125;  <span class="hljs-comment"># 初始化所有节点到无穷大距离</span><br>    distances[start] = <span class="hljs-number">0</span>  <span class="hljs-comment"># 起点到自身的距离为0</span><br>    priority_queue = [(<span class="hljs-number">0</span>, start)]  <span class="hljs-comment"># 创建一个优先队列</span><br><br>    <span class="hljs-keyword">while</span> priority_queue:<br>        current_distance, current_node = heapq.heappop(priority_queue)  <span class="hljs-comment"># 从优先队列中取出最近的节点</span><br>        <span class="hljs-keyword">if</span> current_distance &gt; distances[current_node]:  <span class="hljs-comment"># 如果已经找到更短的路径，则跳过</span><br>            <span class="hljs-keyword">continue</span><br><br>        <span class="hljs-comment"># 遍历当前节点的所有邻居</span><br>        <span class="hljs-keyword">for</span> neighbor, weight <span class="hljs-keyword">in</span> graph[current_node].items():<br>            distance = current_distance + weight  <span class="hljs-comment"># 计算到邻居的距离</span><br>            <span class="hljs-comment"># 如果找到了更短的路径，则更新距离并加入优先队列</span><br>            <span class="hljs-keyword">if</span> distance &lt; distances[neighbor]:<br>                distances[neighbor] = distance<br>                heapq.heappush(priority_queue, (distance, neighbor))<br><br>    <span class="hljs-keyword">return</span> distances<br></code></pre></td></tr></table></figure><h5 id="算法优缺点：-1"><a href="#算法优缺点：-1" class="headerlink" title="算法优缺点："></a>算法优缺点：</h5><p>优点：迪杰斯特拉算法可以快速找到单源最短路径，特别是在图的边权都是非负的情况下。<br>缺点：如果图中有负权边，迪杰斯特拉算法可能无法正确工作。</p><h5 id="解决缺点的方法：-1"><a href="#解决缺点的方法：-1" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h5><p>对于有负权边的情况，可以使用Bellman-Ford算法，它可以处理负权边，但时间复杂度较高。</p><h5 id="解决缺点后的代码案例：-1"><a href="#解决缺点后的代码案例：-1" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bellman_ford</span>(<span class="hljs-params">graph, source</span>):<br>    distances = &#123;node: <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;infinity&#x27;</span>) <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph&#125;<br>    distances[source] = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 重复|V|-1次，其中|V|是顶点数</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph) - <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph:<br>            <span class="hljs-keyword">for</span> neighbor, weight <span class="hljs-keyword">in</span> graph[node].items():<br>                <span class="hljs-keyword">if</span> distances[node] + weight &lt; distances[neighbor]:<br>                    distances[neighbor] = distances[node] + weight<br><br>    <span class="hljs-comment"># 检查负权环</span><br>    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph:<br>        <span class="hljs-keyword">for</span> neighbor, weight <span class="hljs-keyword">in</span> graph[node].items():<br>            <span class="hljs-keyword">if</span> distances[node] + weight &lt; distances[neighbor]:<br>                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Graph contains a negative-weight cycle&quot;</span>)<br><br>    <span class="hljs-keyword">return</span> distances<br></code></pre></td></tr></table></figure><h5 id="算法的实际应用案例：-1"><a href="#算法的实际应用案例：-1" class="headerlink" title="算法的实际应用案例："></a>算法的实际应用案例：</h5><ul><li><strong>路网导航</strong>：计算从一点到多点的最短行驶距离。</li><li><strong>网络路由</strong>：在网络中找到数据传输的最短路径。</li><li><strong>供应链管理</strong>：优化产品从源头到客户的运输路径。</li></ul><h4 id="3-归并排序（Merge-Sort）"><a href="#3-归并排序（Merge-Sort）" class="headerlink" title="3. 归并排序（Merge Sort）"></a>3. 归并排序（Merge Sort）</h4><p><img src="/img/%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B.gif" alt="归并算法示例" title="归并算法示例"></p><h5 id="产生原因与背景：-2"><a href="#产生原因与背景：-2" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h5><p>想象你要整理两大叠混乱的纸张，每叠纸张已经按顺序排列。你可以轻松地将这两叠纸张合并成一叠有序的纸张。归并排序就是模仿这个过程，通过递归地分解和合并来对数据进行排序。</p><h5 id="算法思路：-2"><a href="#算法思路：-2" class="headerlink" title="算法思路："></a>算法思路：</h5><p>归并排序就像是一个熟练的图书管理员整理书架，首先将书籍分成可以单手管理的小堆，然后逐堆整理，最后将这些小堆两两合并，直到所有书籍都有序排列。</p><h5 id="代码示例：-2"><a href="#代码示例：-2" class="headerlink" title="代码示例："></a>代码示例：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_sort</span>(<span class="hljs-params">arr</span>):<br>    <span class="hljs-comment"># 基线条件：如果数组只有一个元素或为空，它已经是有序的</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br><br>    <span class="hljs-comment"># 将数组分为两半</span><br>    mid = <span class="hljs-built_in">len</span>(arr) // <span class="hljs-number">2</span><br>    left_half = arr[:mid]<br>    right_half = arr[mid:]<br><br>    <span class="hljs-comment"># 递归地对两半进行排序</span><br>    left_sorted = merge_sort(left_half)<br>    right_sorted = merge_sort(right_half)<br><br>    <span class="hljs-comment"># 合并两个有序数组</span><br>    <span class="hljs-keyword">return</span> merge(left_sorted, right_sorted)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left, right</span>):<br>    result = []<br>    i = j = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 合并过程，选取左右数组中较小的元素，直到任一数组为空</span><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(left) <span class="hljs-keyword">and</span> j &lt; <span class="hljs-built_in">len</span>(right):<br>        <span class="hljs-keyword">if</span> left[i] &lt; right[j]:<br>            result.append(left[i])<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            result.append(right[j])<br>            j += <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 复制剩余的元素</span><br>    result.extend(left[i:])<br>    result.extend(right[j:])<br><br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h5 id="算法优缺点：-2"><a href="#算法优缺点：-2" class="headerlink" title="算法优缺点："></a>算法优缺点：</h5><p>优点：归并排序是一种稳定的排序算法，无论输入数据如何，都能保证O(n log n)的时间复杂度。<br>缺点：归并排序需要额外的内存空间来存储临时数组，这可能在内存受限的情况下成为问题。</p><h5 id="解决缺点的方法：-2"><a href="#解决缺点的方法：-2" class="headerlink" title="解决缺点的方法："></a>解决缺点的方法：</h5><p>可以实施原地归并排序算法，但这样会牺牲一些代码的简洁性和可读性。</p><h5 id="解决缺点后的代码案例：-2"><a href="#解决缺点后的代码案例：-2" class="headerlink" title="解决缺点后的代码案例："></a>解决缺点后的代码案例：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_sort_in_place</span>(<span class="hljs-params">arr, temp_arr, left, right</span>):<br>    <span class="hljs-keyword">if</span> left &lt; right:<br>        mid = (left + right) // <span class="hljs-number">2</span><br>        merge_sort_in_place(arr, temp_arr, left, mid)<br>        merge_sort_in_place(arr, temp_arr, mid + <span class="hljs-number">1</span>, right)<br>        merge_in_place(arr, temp_arr, left, mid, right)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_in_place</span>(<span class="hljs-params">arr, temp_arr, left, mid, right</span>):<br>    i, j = left, mid + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(left, right + <span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 复制到临时数组以避免数据覆盖</span><br>        temp_arr[k] = arr[k]<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(left, right + <span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 合并回原数组</span><br>        <span class="hljs-keyword">if</span> i &gt; mid:<br>            arr[k] = temp_arr[j]<br>            j += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> j &gt; right:<br>            arr[k] = temp_arr[i]<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> temp_arr[i] &lt;= temp_arr[j]:<br>            arr[k] = temp_arr[i]<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            arr[k] = temp_arr[j]<br>            j += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h5 id="算法的实际应用案例：-2"><a href="#算法的实际应用案例：-2" class="headerlink" title="算法的实际应用案例："></a>算法的实际应用案例：</h5><ul><li><strong>数据库记录排序</strong>：在数据库查询中，快速对大量记录进行排序。</li><li><strong>大数据处理</strong>：在处理大规模数据集时，有效排序。</li><li><strong>文件排序</strong>：对大型文件中的数据进行排序，可以分步处理和合并结果。</li></ul><h3 id="事项二"><a href="#事项二" class="headerlink" title="| 事项二"></a>| 事项二</h3><p>输出智能仓库控制系统WMS的业务流程及操作流程</p><h4 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h4><p>根据WMS仓库系统优化版的功能，可以简单梳理出货物从入库到出库的完整业务流程，具体业务流程需根据现场情况来定，以下流程仅供参考：</p><p>(1)货物入库前的准备：<br>    策略管理：在策略管理模块中，设置条码策略（3.3.1）、入库策略（3.3.2）和拣货策略（3.3.3），以指导后续的入库操作。</p><p>(2)货物到达仓库：<br>    仓储管理：在仓库管理（3.6.1）、库区管理（3.6.2）和库位管理（3.6.3）中，为即将到达的货物分配合适的仓库和库位。</p><p>(3)入库作业：<br>    作业管理：在入库作业（3.8.1）中，创建入库单据，记录货物信息，如货物类型、数量等，并根据入库策略进行操作。</p><p>(4)货物检验：<br>    检验管理：在质检单（3.9.1）中，对货物进行质量检验，确保货物符合入库标准。</p><p>(5)货物上架：<br>    仓储管理：根据规划区域（3.6.4）和库位管理（3.6.3），将货物放置到指定的库位上。</p><p>(6)库存更新：<br>    监控台模块：在库存查询（3.1.6）中，更新货物的库存信息，确保库存数据的准确性。</p><p>(7)货物存储期间的管理：<br>    报警管理：设置库存预警（3.7.2），监控库存水平，防止货物短缺或过剩。<br>    系统管理：通过用户管理（3.4.1）、权限管理（3.4.6）等确保仓库操作的安全性和合规性。</p><p>(8)出库前的准备：<br>    策略管理：在出库策略（3.3.4）中，根据业务需求制定出库规则。</p><p>(9)出库作业：<br>    作业管理：在出库作业（3.8.2）中，根据出库单据进行货物的拣选和准备。</p><p>(10)特殊处理（如有需要）：<br>    特殊处理模块：处理托盘物料变更（3.10.1）、货主变更（3.10.2）等特殊情况。</p><p>(11)货物出库：<br>    仓储管理：在库位管理（3.6.3）中，更新库位状态，标记货物已出库。</p><p>(12)库存再次更新：<br>    监控台模块：在库存查询（3.1.6）中，再次更新库存信息，反映最新的库存状态。</p><p>(13)盘点与核对：<br>    盘点管理：定期进行计划盘点（3.11.1）和盘点单（3.11.2），录入盘点结果（3.11.3），并处理损益单（3.11.4）。</p><p>(14)报表生成：<br>    报表中心模块：在综合报表（3.13）中，生成相关的入库和出库报表，用于分析和决策支持。</p><p>(15)数据交换与系统集成：<br>    接口管理：通过接口配置（3.12.1）和数据交换（如RCS、U8、WCS相关数据），确保WMS系统与其他系统的数据同步。</p><p>这个流程涵盖了从货物到达仓库前的准备工作，到货物最终出库的整个业务流程，确保了货物在仓库中的高效管理和正确流转。</p><h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><h5 id="1-系统初始化"><a href="#1-系统初始化" class="headerlink" title="1. 系统初始化"></a>1. 系统初始化</h5><ul><li><strong>目标</strong>：完成系统基础配置，确保各模块正常运行。</li><li><strong>步骤</strong>：<ul><li>配置网络连接和服务器参数。</li><li>安装系统软件和必要的补丁。</li><li>设置系统权限和用户角色。</li></ul></li></ul><h5 id="2-用户登录与权限验证"><a href="#2-用户登录与权限验证" class="headerlink" title="2. 用户登录与权限验证"></a>2. 用户登录与权限验证</h5><h6 id="2-1-用户登录"><a href="#2-1-用户登录" class="headerlink" title="2.1 用户登录"></a>2.1 用户登录</h6><ul><li><strong>目标</strong>：允许授权用户访问系统。</li><li><strong>步骤</strong>：<ul><li>输入用户名和密码。</li><li>进行多因素认证（如果启用）。</li></ul></li></ul><h6 id="2-2-权限验证"><a href="#2-2-权限验证" class="headerlink" title="2.2 权限验证"></a>2.2 权限验证</h6><ul><li><strong>目标</strong>：确保用户只能访问授权的功能和数据。</li><li><strong>步骤</strong>：<ul><li>系统自动验证用户角色和权限。</li><li>根据用户角色展示相应的操作界面。</li></ul></li></ul><h5 id="3-货物入库流程"><a href="#3-货物入库流程" class="headerlink" title="3. 货物入库流程"></a>3. 货物入库流程</h5><h6 id="3-1-入库计划"><a href="#3-1-入库计划" class="headerlink" title="3.1 入库计划"></a>3.1 入库计划</h6><ul><li><strong>目标</strong>：根据采购订单制定详细的入库计划。</li><li><strong>步骤</strong>：<ul><li>从ERP系统导入订单数据或手动输入。</li><li>确定预计到货日期和所需资源。</li></ul></li></ul><h6 id="3-2-货物接收"><a href="#3-2-货物接收" class="headerlink" title="3.2 货物接收"></a>3.2 货物接收</h6><ul><li><strong>目标</strong>：确保到货与订单相符，并进行初步检验。</li><li><strong>步骤</strong>：<ul><li>扫描货物条码或RFID标签核对信息。</li><li>检查货物数量和质量，记录异常。</li></ul></li></ul><h6 id="3-3-货位分配"><a href="#3-3-货位分配" class="headerlink" title="3.3 货位分配"></a>3.3 货位分配</h6><ul><li><strong>目标</strong>：根据货物特性和存储策略分配货位。</li><li><strong>步骤</strong>：<ul><li>系统推荐货位或根据特定规则手动分配。</li><li>考虑货物尺寸、重量和存储要求。</li></ul></li></ul><h6 id="3-4-入库登记"><a href="#3-4-入库登记" class="headerlink" title="3.4 入库登记"></a>3.4 入库登记</h6><ul><li><strong>目标</strong>：在系统中记录货物的入库信息。</li><li><strong>步骤</strong>：<ul><li>录入货物详细信息，如SKU、批次、数量等。</li><li>打印并粘贴货位标签，更新库存状态。</li></ul></li></ul><h5 id="4-库存管理"><a href="#4-库存管理" class="headerlink" title="4. 库存管理"></a>4. 库存管理</h5><h6 id="4-1-实时库存更新"><a href="#4-1-实时库存更新" class="headerlink" title="4.1 实时库存更新"></a>4.1 实时库存更新</h6><ul><li><strong>目标</strong>：确保库存数据的准确性和实时性。</li><li><strong>步骤</strong>：<ul><li>系统自动更新库存数量。</li><li>手动更新库存状态，如报废、在检等。</li></ul></li></ul><h6 id="4-2-盘点操作"><a href="#4-2-盘点操作" class="headerlink" title="4.2 盘点操作"></a>4.2 盘点操作</h6><ul><li><strong>目标</strong>：定期核对实际库存与系统记录。</li><li><strong>步骤</strong>：<ul><li>制定盘点计划，包括盘点范围和时间。</li><li>执行盘点，录入盘点结果，系统自动调整库存。</li></ul></li></ul><h6 id="4-3-库存预警"><a href="#4-3-库存预警" class="headerlink" title="4.3 库存预警"></a>4.3 库存预警</h6><ul><li><strong>目标</strong>：预防库存不足或过剩，及时响应。</li><li><strong>步骤</strong>：<ul><li>设置库存预警阈值和通知规则。</li><li>系统自动发送预警通知给相关人员。</li></ul></li></ul><h5 id="5-订单处理"><a href="#5-订单处理" class="headerlink" title="5. 订单处理"></a>5. 订单处理</h5><h6 id="5-1-订单接收"><a href="#5-1-订单接收" class="headerlink" title="5.1 订单接收"></a>5.1 订单接收</h6><ul><li><strong>目标</strong>：从销售系统接收订单信息。</li><li><strong>步骤</strong>：<ul><li>自动导入订单数据或手动输入。</li><li>审核订单信息的完整性和准确性。</li></ul></li></ul><h6 id="5-2-订单预处理"><a href="#5-2-订单预处理" class="headerlink" title="5.2 订单预处理"></a>5.2 订单预处理</h6><ul><li><strong>目标</strong>：准备订单的拣货和发货。</li><li><strong>步骤</strong>：<ul><li>分配订单处理优先级。</li><li>准备必要的包装材料和运输标签。</li></ul></li></ul><h5 id="6-拣货与复核"><a href="#6-拣货与复核" class="headerlink" title="6. 拣货与复核"></a>6. 拣货与复核</h5><h6 id="6-1-拣货作业"><a href="#6-1-拣货作业" class="headerlink" title="6.1 拣货作业"></a>6.1 拣货作业</h6><ul><li><strong>目标</strong>：根据订单要求准确拣选货物。</li><li><strong>步骤</strong>：<ul><li>系统生成拣货单和最优拣货路径。</li><li>拣货员按路径拣选货物，扫描确认。</li></ul></li></ul><h6 id="6-2-复核与打包"><a href="#6-2-复核与打包" class="headerlink" title="6.2 复核与打包"></a>6.2 复核与打包</h6><ul><li><strong>目标</strong>：确保拣选货物的准确性，并准备发货。</li><li><strong>步骤</strong>：<ul><li>对拣选的货物进行数量和条件复核。</li><li>根据货物特性进行打包，并贴上运输标签。</li></ul></li></ul><h5 id="7-货物出库"><a href="#7-货物出库" class="headerlink" title="7. 货物出库"></a>7. 货物出库</h5><h6 id="7-1-出库准备"><a href="#7-1-出库准备" class="headerlink" title="7.1 出库准备"></a>7.1 出库准备</h6><ul><li><strong>目标</strong>：确保出库货物信息的准确性，并准备必要的文件。</li><li><strong>步骤</strong>：<ul><li>录入或确认出库信息，如客户、地址、运输方式等。</li><li>打印发货标签和运输文件。</li></ul></li></ul><h6 id="7-2-出库扫描与发货"><a href="#7-2-出库扫描与发货" class="headerlink" title="7.2 出库扫描与发货"></a>7.2 出库扫描与发货</h6><ul><li><strong>目标</strong>：更新出库信息，确保库存数据的准确性。</li><li><strong>步骤</strong>：<ul><li>扫描出库货物的条码或RFID标签。</li><li>更新库存状态，记录发货信息，通知运输部门。</li></ul></li></ul><h5 id="8-报表与分析"><a href="#8-报表与分析" class="headerlink" title="8. 报表与分析"></a>8. 报表与分析</h5><h6 id="8-1-报表生成"><a href="#8-1-报表生成" class="headerlink" title="8.1 报表生成"></a>8.1 报表生成</h6><ul><li><strong>目标</strong>：提供详细的业务和库存报表，支持决策。</li><li><strong>步骤</strong>：<ul><li>根据需求生成各类报表，如入库、出库、库存报表等。</li><li>支持报表的导出、打印和邮件发送。</li></ul></li></ul><h6 id="8-2-数据分析"><a href="#8-2-数据分析" class="headerlink" title="8.2 数据分析"></a>8.2 数据分析</h6><ul><li><strong>目标</strong>：分析报表数据，发现业务趋势和潜在问题。</li><li><strong>步骤</strong>：<ul><li>使用数据分析工具识别关键指标。</li><li>制作图表和报告，为管理层提供决策支持。</li></ul></li></ul><h5 id="9-系统维护与升级"><a href="#9-系统维护与升级" class="headerlink" title="9. 系统维护与升级"></a>9. 系统维护与升级</h5><ul><li><strong>目标</strong>：确保系统长期稳定运行，适应业务发展。</li><li><strong>步骤</strong>：<ul><li>定期检查系统性能，优化数据库。</li><li>定期备份数据，确保数据安全。</li><li>应用系统更新和安全补丁。</li></ul></li></ul><h5 id="10-客户服务与反馈"><a href="#10-客户服务与反馈" class="headerlink" title="10. 客户服务与反馈"></a>10. 客户服务与反馈</h5><ul><li><strong>目标</strong>：提供优质的客户服务，持续改进系统。</li><li><strong>步骤</strong>：<ul><li>建立用户反馈机制，收集用户意见。</li><li>定期培训用户，提高系统使用效率。</li><li>快速响应用户问题，提供技术支持。</li></ul></li></ul><h5 id="附录：故障排除指南"><a href="#附录：故障排除指南" class="headerlink" title="附录：故障排除指南"></a>附录：故障排除指南</h5><ul><li><strong>目标</strong>：为用户提供常见问题的解决方案。</li><li><strong>内容</strong>：<ul><li>列出常见问题及其解决方法。</li><li>提供联系技术支持的渠道和步骤。</li></ul></li></ul><p>请根据实际业务需求和系统功能调整上述操作流程。如果需要进一步定制或自动化特定流程，请与系统管理员或技术支持团队联系。</p><h3 id="事项三"><a href="#事项三" class="headerlink" title="事项三"></a>事项三</h3><p>执行C#计划</p><h4 id="第一阶段：基础建设（1-3个月）"><a href="#第一阶段：基础建设（1-3个月）" class="headerlink" title="第一阶段：基础建设（1-3个月）"></a>第一阶段：基础建设（1-3个月）</h4><h5 id="学习模块：C-基础语法"><a href="#学习模块：C-基础语法" class="headerlink" title="学习模块：C#基础语法"></a>学习模块：C#基础语法</h5><p><strong>比喻</strong>：想象编程语言就像学习一门新的语言，C#就像是学习英语，基础语法就像是学习字母和基本的单词。</p><ol><li><p><strong>变量和数据类型（Variables and Data Types）</strong></p><ul><li><strong>比喻</strong>：变量就像是你的名字标签，它告诉你这个存储空间是用来放什么的。数据类型则像是标签上的分类，比如“水果”或“蔬菜”。</li><li><strong>内容</strong>：学习如何声明变量（<code>int</code>, <code>string</code>, <code>bool</code>等），以及它们的基本用途。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> age = <span class="hljs-number">25</span>; <span class="hljs-comment">// 想象这里age是一个装着数字25的盒子</span><br><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;Alice&quot;</span>; <span class="hljs-comment">// name是一个装着名字&quot;Alice&quot;的标签</span><br><span class="hljs-built_in">bool</span> isStudent = <span class="hljs-literal">true</span>; <span class="hljs-comment">// isStudent是一个开关，true表示开，false表示关</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>控制结构（Control Structures）</strong></p><ul><li><strong>if语句</strong>：就像是一个门卫，检查条件是否满足，如果满足就让你通过。</li><li><strong>switch语句</strong>：可以想象成一个多路口的交通灯，根据条件选择不同的路径。</li><li><strong>循环（Loops）</strong>：循环就像是你每天重复的刷牙动作，只要条件满足，就会一直重复执行。</li><li><strong>if语句</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span>) &#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;You are an adult.&quot;</span>); <span class="hljs-comment">// 如果年龄大于等于18，就告诉你成年了</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>switch语句</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">switch</span> (dayOfWeek) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Monday&quot;</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Start of the week!&quot;</span>);<br>        <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 每个case结束后都要用break停止</span><br>    <span class="hljs-comment">// 更多case...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>循环（Loops）</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123; <span class="hljs-comment">// 从0数到9，就像数手指一样</span><br>    Console.WriteLine(i); <span class="hljs-comment">// 每次循环打印当前的数字</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>数组（Arrays）</strong></p><ul><li><strong>比喻</strong>：数组就像是一排排的书架，每个书架上都可以放相同类型的书籍（元素）。</li><li><strong>内容</strong>：学习如何声明和使用数组，包括访问和修改数组中的元素。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span>[] numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">// 创建一个有5个空位的数字书架</span><br>numbers[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>; <span class="hljs-comment">// 把数字10放在第一个书架上</span><br>Console.WriteLine(numbers[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 读取第一个书架上的数字</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>字符串操作（String Manipulation）</strong></p><ul><li><strong>比喻</strong>：字符串就像是一句话或者一段故事，你可以读取它、修改它，甚至可以把它分成几个部分。</li><li><strong>内容</strong>：学习字符串的基本操作，如连接（<code>+</code>）、长度获取（<code>Length</code>属性）、子字符串（<code>Substring</code>方法）等。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> greeting = <span class="hljs-string">&quot;Hello, &quot;</span> + name; <span class="hljs-comment">// 把&quot;Hello, &quot;和name拼接起来，像是做三明治</span><br>Console.WriteLine(greeting); <span class="hljs-comment">// 打印拼接后的字符串</span><br><span class="hljs-built_in">string</span> city = <span class="hljs-string">&quot;New York&quot;</span>; <span class="hljs-comment">// city是一个装着&quot;New York&quot;的盒子</span><br><span class="hljs-built_in">int</span> cityLength = city.Length; <span class="hljs-comment">// 测量盒子里内容的长度</span><br><span class="hljs-built_in">string</span> partOfCity = city.Substring(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 取出&quot;New York&quot;中的&quot;New&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>函数（Functions）</strong></p><ul><li><strong>比喻</strong>：函数就像是食谱，它告诉你如何制作一道菜，你需要提供原料（参数），然后按照步骤（代码块）来完成。</li><li><strong>内容</strong>：学习如何定义函数，以及如何调用它们。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SayHello</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> person</span>)</span> &#123; <span class="hljs-comment">// 定义一个函数，它接受一个人的名字</span><br>    Console.WriteLine(<span class="hljs-string">$&quot;Hello, <span class="hljs-subst">&#123;person&#125;</span>!&quot;</span>); <span class="hljs-comment">// 打印问候语</span><br>&#125;<br>SayHello(name); <span class="hljs-comment">// 调用函数，传入name变量</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>输入和输出（Input and Output）</strong></p><ul><li><strong>Console.WriteLine</strong>：就像是用笔在纸上写字，你可以把信息输出到控制台。</li><li><strong>Console.ReadLine</strong>：就像是听别人说话，你可以从控制台接收输入。</li><li><strong>Console.WriteLine</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(<span class="hljs-string">&quot;Enter your name: &quot;</span>); <span class="hljs-comment">// 打印提示信息，就像问别人名字</span><br></code></pre></td></tr></table></figure></li><li><strong>Console.ReadLine</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> userName = Console.ReadLine(); <span class="hljs-comment">// 读取用户输入的名字，像听别人告诉你他的名字</span><br>Console.WriteLine(<span class="hljs-string">$&quot;Nice to meet you, <span class="hljs-subst">&#123;userName&#125;</span>!&quot;</span>); <span class="hljs-comment">// 打印欢迎语</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>命名空间（Namespaces）</strong></p><ul><li><strong>比喻</strong>：命名空间就像是图书馆的不同区域，每个区域都有不同的书籍（类和方法）。</li><li><strong>内容</strong>：学习如何使用<code>using</code>指令来包含命名空间，以便使用它们提供的功能。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System; <span class="hljs-comment">// 包含System命名空间，就像进入了一个有很多工具的房间</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>注释（Comments）</strong></p><ul><li><strong>比喻</strong>：注释就像是给代码写的笔记，帮助别人（或未来的你）理解代码的意图。</li><li><strong>内容</strong>：学习如何写单行注释（<code>//</code>）和多行注释（<code>/* ... */</code>）。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 这是一个单行注释，就像在代码旁边做的笔记</span><br><span class="hljs-built_in">int</span> number = <span class="hljs-number">5</span>; <span class="hljs-comment">// 告诉别人这个变量存储了一个数字</span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> 这是一个多行注释</span><br><span class="hljs-comment"> 可以跨越多行，就像写一篇短文</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>通过这些基础模块的学习，你将建立起C#编程的坚实基础，就像是学会了英语的基本语法和词汇，为进一步的深入学习打下基础。记住，编程就像是学习语言，多练习、多读、多写是提高的关键。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日事项-2024年6月26日</title>
    <link href="/2024/06/26/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B46%E6%9C%8826%E6%97%A5/"/>
    <url>/2024/06/26/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B46%E6%9C%8826%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="今日事项"><a href="#今日事项" class="headerlink" title="今日事项"></a>今日事项</h1><h2 id="今日事项：2024年6月26日"><a href="#今日事项：2024年6月26日" class="headerlink" title="| 今日事项：2024年6月26日"></a>| 今日事项：2024年6月26日</h2><h3 id="事项一："><a href="#事项一：" class="headerlink" title="| 事项一："></a>| 事项一：</h3><p>写5个角色的promoto，并上传至个人博客网站上<br>角色1：C#开发专家<br>角色2：语言学专家和记忆技巧导师<br>角色3：SQL Server 2014 专家<br>角色4：智能仓库系统实施工程师<br>角色5：AI知识库系统工程师</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> Role: C#开发专家<br><span class="hljs-bullet">-</span> Background: 用户希望快速掌握C#开发基础技能，以便能够独立进行项目开发。<br><span class="hljs-bullet">-</span> Profile: 你是一位经验丰富的C#开发专家，熟悉C#语言的各个方面，包括语法、面向对象编程、常用库等。<br><span class="hljs-bullet">-</span> Skills: 熟悉C#语言特性、.NET框架、Visual Studio开发环境、调试技巧等。<br><span class="hljs-bullet">-</span> Goals: 设计一个能够帮助用户快速掌握C#开发基础技能的流程。<br><span class="hljs-bullet">-</span> Constrains: 该流程需要简洁明了，适合编程初学者，并且能够逐步引导用户深入理解C#编程。<br><span class="hljs-bullet">-</span> OutputFormat: 结构化的教程，包括代码示例、关键概念解释、练习题和项目实践。<br><span class="hljs-bullet">-</span> Workflow:<br><span class="hljs-bullet">  1.</span> 介绍C#语言和.NET框架的基本概念。<br><span class="hljs-bullet">  2.</span> 详细讲解C#的基础语法和面向对象编程。<br><span class="hljs-bullet">  3.</span> 展示如何在Visual Studio中创建和管理项目。<br><span class="hljs-bullet">  4.</span> 教授基本的调试技巧和性能优化方法。<br><span class="hljs-bullet">  5.</span> 提供实际的小项目案例，让用户通过实践加深理解。<br><span class="hljs-bullet">-</span> Examples:<br><span class="hljs-bullet">  -</span> 基础语法：变量声明、控制流（if, switch, loops）。<br><span class="hljs-bullet">  -</span> 面向对象编程：类和对象、继承、封装、多态。<br><span class="hljs-bullet">  -</span> 集合：数组、列表、字典等。<br><span class="hljs-bullet">  -</span> 异常处理：try、catch、finally。<br><span class="hljs-bullet">  -</span> Visual Studio使用：项目创建、代码编辑、编译、运行。<br><span class="hljs-bullet">-</span> Initialization: 欢迎加入C#开发的世界！让我们一起快速掌握C#开发的基础技能，让你能够自信地开始你的编程之旅。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> Role: 语言学专家和记忆技巧导师<br><span class="hljs-bullet">-</span> Background: 用户在学习英语单词时遇到了记忆难题，希望通过发音联想法来提高记忆效率。<br><span class="hljs-bullet">-</span> Profile: 你是一位精通多种语言的语言学家，同时擅长利用记忆科学的方法帮助学生提高学习效率。<br><span class="hljs-bullet">-</span> Skills: 语言学知识、记忆技巧、发音规则、联想法教学。<br><span class="hljs-bullet">-</span> Goals: 你需要设计一个能够帮助用户通过发音联想法快速记忆英语单词的流程。<br><span class="hljs-bullet">-</span> Constrains: 该流程需要简单易懂，适合不同英语水平的学习者，并且能够有效提高记忆效率。<br><span class="hljs-bullet">-</span> OutputFormat: 文本说明与实际单词例子的结合。<br><span class="hljs-bullet">-</span> Workflow:<br><span class="hljs-bullet">  1.</span> 介绍发音联想法的基本原理。<br><span class="hljs-bullet">  2.</span> 提供具体的单词例子和联想记忆的步骤。<br><span class="hljs-bullet">  3.</span> 给出练习建议和复习策略。<br><span class="hljs-bullet">-</span> Examples:<br>  单词：&#x27;biology&#x27;（生物学）<br>  发音：/baɪˈɒlədʒi/<br>  联想：将单词拆分为&#x27;bio&#x27;和&#x27;logy&#x27;两部分。&#x27;bio&#x27;可以联想到生命（life），&#x27;logy&#x27;联想到学科（study），联想到“生物学是研究生命的学科”。<br>  单词：&#x27;abandon&#x27;（放弃）<br>  发音：/əˈbændən/<br>  联想：将单词拆分为&#x27;a&#x27;、&#x27;bandon&#x27;两部分。&#x27;a&#x27;联想到一（one），&#x27;bandon&#x27;联想到乐队（band）的谐音，联想到“一个人放弃乐队”。<br><span class="hljs-bullet">-</span> Initialization: 欢迎使用发音联想法记忆英语单词，让我们一起开启高效学习之旅！请给发送我你想学习的单词吧！<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">-</span> Role: <span class="hljs-keyword">SQL</span> Server <span class="hljs-number">2014</span> 专家<br><span class="hljs-operator">-</span> Background: 用户希望掌握 <span class="hljs-keyword">SQL</span> Server <span class="hljs-number">2014</span> 的 <span class="hljs-keyword">SQL</span> 语法，以便能够高效地进行数据库管理和查询。<br><span class="hljs-operator">-</span> Profile: 你是一位经验丰富的数据库管理员和 <span class="hljs-keyword">SQL</span> 专家，专注于 <span class="hljs-keyword">SQL</span> Server <span class="hljs-number">2014</span> 版本。<br><span class="hljs-operator">-</span> Skills: 精通 <span class="hljs-keyword">SQL</span> 语法、数据库设计、性能优化、T<span class="hljs-operator">-</span><span class="hljs-keyword">SQL</span> 编程。<br><span class="hljs-operator">-</span> Goals: 设计一个能够帮助用户从基础到高级逐步掌握 <span class="hljs-keyword">SQL</span> Server <span class="hljs-number">2014</span> <span class="hljs-keyword">SQL</span> 语法的学习路径。<br><span class="hljs-operator">-</span> Constrains: 确保学习材料适合不同水平的用户，从初学者到有经验的开发者。<br><span class="hljs-operator">-</span> OutputFormat: 结构化的教程，包括基础概念、示例查询、实践练习和高级主题。<br><span class="hljs-operator">-</span> Workflow:<br>  <span class="hljs-number">1.</span> 介绍 <span class="hljs-keyword">SQL</span> Server <span class="hljs-number">2014</span> 的基本概念和界面。<br>  <span class="hljs-number">2.</span> 教授基础 <span class="hljs-keyword">SQL</span> 语法，包括 <span class="hljs-keyword">SELECT</span>、<span class="hljs-keyword">INSERT</span>、<span class="hljs-keyword">UPDATE</span> 和 <span class="hljs-keyword">DELETE</span> 语句。<br>  <span class="hljs-number">3.</span> 通过示例和练习加深对 <span class="hljs-keyword">SQL</span> 语法的理解。<br>  <span class="hljs-number">4.</span> 探索高级主题，如存储过程、触发器、视图和索引。<br>  <span class="hljs-number">5.</span> 提供性能优化和查询调优的技巧。<br><span class="hljs-operator">-</span> Examples:<br>  <span class="hljs-keyword">SQL</span> 基础：<br>  <span class="hljs-operator">-</span> <span class="hljs-keyword">SELECT</span> 语句：`<span class="hljs-keyword">SELECT</span> column1, column2 <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;`<br>  <span class="hljs-operator">-</span> <span class="hljs-keyword">INSERT</span> 语句：`<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (column1, column2) <span class="hljs-keyword">VALUES</span> (value1, value2);`<br>  高级主题：<br>  <span class="hljs-operator">-</span> 存储过程：`<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> procedure_name <span class="hljs-keyword">AS</span> <span class="hljs-keyword">BEGIN</span> ... <span class="hljs-keyword">END</span>;`<br>  <span class="hljs-operator">-</span> 触发器：`<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> trigger_name <span class="hljs-keyword">ON</span> table_name AFTER <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">AS</span> <span class="hljs-keyword">BEGIN</span> ... <span class="hljs-keyword">END</span>;`<br><span class="hljs-operator">-</span> Initialization: 欢迎使用 <span class="hljs-keyword">SQL</span> Server <span class="hljs-number">2014</span> <span class="hljs-keyword">SQL</span> 语法学习指南！让我们开始你的数据库之旅吧。请告诉我你当前的 <span class="hljs-keyword">SQL</span> 知识水平，以便我为你提供定制化的学习建议。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> Role: 智能仓库系统实施工程师<br><span class="hljs-bullet">-</span> Background: 作为一名智能仓库系统的实施工程师，你需要具备深厚的技术知识、项目管理能力和对物流自动化的理解。<br><span class="hljs-bullet">-</span> Profile: 你是一位经验丰富的智能仓库系统实施工程师，擅长将复杂的技术解决方案转化为实际操作流程，确保系统的高效运行。<br><span class="hljs-bullet">-</span> Skills: 技术知识、项目管理、自动化设备操作、数据分析、团队协作。<br><span class="hljs-bullet">-</span> Goals: 设计一个能够帮助你在智能仓库系统实施过程中，从规划到执行各个阶段的提示词。<br><span class="hljs-bullet">-</span> Constrains: 确保提示词能够覆盖智能仓库系统实施的关键步骤，包括需求分析、系统设计、设备安装、系统集成、测试与优化、用户培训和后期维护。<br><span class="hljs-bullet">-</span> OutputFormat: 结构化的步骤说明，包括关键任务和检查清单。<br><span class="hljs-bullet">-</span> Workflow:<br><span class="hljs-bullet">  1.</span> 需求分析与规划：与客户沟通，了解业务需求和预期目标。<br><span class="hljs-bullet">  2.</span> 系统设计与配置：根据需求设计系统架构，选择合适的硬件和软件。<br><span class="hljs-bullet">  3.</span> 设备采购与安装：采购必要的设备，并进行现场安装与配置。<br><span class="hljs-bullet">  4.</span> 系统集成与测试：将各个组件集成到一起，进行系统测试以确保稳定性。<br><span class="hljs-bullet">  5.</span> 用户培训与文档编制：对操作人员进行培训，并编制操作手册和维护指南。<br><span class="hljs-bullet">  6.</span> 系统上线与监控：正式启动系统，监控运行状态，确保性能符合预期。<br><span class="hljs-bullet">  7.</span> 后期维护与优化：定期维护系统，收集反馈，进行必要的优化升级。<br><span class="hljs-bullet">-</span> Examples:<br><span class="hljs-bullet">  -</span> 如何选择合适的仓库管理系统（WMS）？<br><span class="hljs-bullet">  -</span> 智能仓库中常用的自动化设备有哪些？<br><span class="hljs-bullet">  -</span> 如何确保仓库系统的安全性和可靠性？<br><span class="hljs-bullet">-</span> Initialization: 欢迎使用智能仓库系统实施工程师提示词，让我们一起打造高效、可靠的智能仓库解决方案！请告诉我你当前面临的具体问题或需求。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> Role: AI知识库系统工程师<br><span class="hljs-bullet">-</span> Background: 你是一位专注于构建和优化公司内部AI知识库系统的工程师，旨在帮助企业更高效地管理和利用其知识资源。<br><span class="hljs-bullet">-</span> Profile: 你具备深厚的AI技术和知识管理背景，能够理解企业的核心需求，并设计出符合其业务流程的知识库系统。<br><span class="hljs-bullet">-</span> Skills: 人工智能、机器学习、自然语言处理、数据库管理、系统架构设计。<br><span class="hljs-bullet">-</span> Goals: 设计并实现一个能够不断学习和自我完善的AI知识库系统，以支持企业的知识管理和决策制定。<br><span class="hljs-bullet">-</span> Constrains: 系统需要具备高度的可扩展性、安全性和用户友好性，同时确保数据的准确性和及时更新。<br><span class="hljs-bullet">-</span> OutputFormat: 技术文档、系统架构图、用户手册、培训材料。<br><span class="hljs-bullet">-</span> Workflow:<br><span class="hljs-bullet">  1.</span> 与企业沟通，了解其业务流程和知识管理需求。<br><span class="hljs-bullet">  2.</span> 设计知识库系统架构，包括数据收集、处理、存储和检索流程。<br><span class="hljs-bullet">  3.</span> 开发和部署AI模型，用于自动化知识提取、分类和推荐。<br><span class="hljs-bullet">  4.</span> 实施系统测试和优化，确保系统性能和用户体验。<br><span class="hljs-bullet">  5.</span> 提供系统使用培训和持续的技术支持。<br><span class="hljs-bullet">-</span> Examples:<br>  企业A需要一个能够处理大量客户服务对话记录的知识库，以便快速检索解决方案和改进服务流程。<br>  企业B希望构建一个包含市场趋势分析的知识库，以辅助产品开发和市场策略制定。<br><span class="hljs-bullet">-</span> Initialization: 欢迎来到AI知识库系统构建项目！请告诉我您的具体需求，我们将一起打造一个强大的知识管理工具。<br></code></pre></td></tr></table></figure><h3 id="事项二："><a href="#事项二：" class="headerlink" title="| 事项二："></a>| 事项二：</h3><p>收集3个经典算法案例，并分析它的实现思路，然后上传至个人博客网站上</p><h3 id="1-快速排序（Quick-Sort）"><a href="#1-快速排序（Quick-Sort）" class="headerlink" title="1. 快速排序（Quick Sort）"></a>1. 快速排序（Quick Sort）</h3><p><img src="/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%A4%BA%E4%BE%8B.gif" alt="快速排序示例" title="快速排序示例"></p><p>产生原因与背景：<br>快速排序由英国计算机科学家托尼·霍尔（Tony Hoare）在1960年提出。它的设计初衷是为了处理大量数据的排序问题，特别是在计算机科学和数据处理领域。快速排序的设计利用了分治法（Divide and Conquer）的思想，通过递归的方式将问题分解成更小的子问题来解决。快速排序的平均时间复杂度为O(n log n)，这使得它在大多数情况下比其它O(n^2)的排序算法（如冒泡排序、选择排序）要高效。</p><p>算法思路：在将要排序的数据中选取一个数据作为基准，然后用这个基准来筛选所有数据，把小于基准的数据放在左边，大于基准的数据放在右边，然后在基准左边的数据组合中选取一个数据作为基准，然后把小于基准的数据放在基准的左边，大于基准的数据就放在基准的右边，在所有数据中首次选出的基准的右边的数据组中选取一个数据作为基准，然后将大于基准的数据放在基准的右边，小于基准的数据放在基准的左边，依次重复这些步骤，即可完成所有数据的排序。</p><p>代码示例：<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs copy">def quick_sort(arr):<br># 基数为1的数组无需排序<br>if len(arr) &lt; 2:<br>return arr<br><br># 选择基准元素，这里选择数组的第一个元素<br>pivot = arr[0]<br># 定义三个列表，分别存储小于、等于、大于基准的元素<br>less = []<br>equal = []<br>greater = []<br><br># 遍历数组，根据元素与基准的比较结果分配到不同的列表<br>for x in arr:<br>if x &lt; pivot:<br>less.append(x)<br>elif x == pivot:<br>equal.append(x)<br>else:<br>greater.append(x)<br><br># 递归地对小于和大于基准的元素进行快速排序，并将结果连接起来<br>return quick_sort(less) + equal + quick_sort(greater)<br><br># 使用示例<br>array = [3, 6, 8, 10, 1, 2, 1]<br>print(&quot;Sorted array:&quot;, quick_sort(array))<br></code></pre></td></tr></table></figure></p><h4 id="问题1：选取的基准数据是否有要求？唯一？"><a href="#问题1：选取的基准数据是否有要求？唯一？" class="headerlink" title="问题1：选取的基准数据是否有要求？唯一？"></a>问题1：选取的基准数据是否有要求？唯一？</h4><p>在快速排序中，选取的基准数据（通常称为”pivot”）并没有严格的要求，也就是说，基准数据可以是数组中的任意一个元素。它不一定是唯一的，因为快速排序算法的效率并不取决于特定的基准选择，而是依赖于基准将数组分为两个子数组的能力。</p><p>通常，有几种选择基准的方法：</p><ul><li>选择第一个元素、最后一个元素或中间元素作为基准。</li><li>随机选择数组中的一个元素作为基准。</li><li>使用”三数取中”法，即取数组的第一个、中间的和最后一个元素的中位数作为基准。</li></ul><p>不同的基准选择方法可能会影响快速排序的性能，特别是在最坏情况和最佳情况下。例如，如果总是选择第一个或最后一个元素作为基准，那么在已经排序或接近排序的数组上执行快速排序将非常低效。随机选择基准可以提高算法在平均情况下的性能。</p><h4 id="问题2：在与基准数据作比较的过程中，遇到与基准数据相同大小的值时，是怎样排序的？"><a href="#问题2：在与基准数据作比较的过程中，遇到与基准数据相同大小的值时，是怎样排序的？" class="headerlink" title="问题2：在与基准数据作比较的过程中，遇到与基准数据相同大小的值时，是怎样排序的？"></a>问题2：在与基准数据作比较的过程中，遇到与基准数据相同大小的值时，是怎样排序的？</h4><p>在快速排序中，与基准数据相同大小的值可以放在任一边。通常有两种处理方式：</p><ul><li><strong>稳定分区</strong>：将等于基准的元素放在基准的左边，这样在递归排序左子数组时，这些元素将保持在原地不动。这种方法保留了相等元素的原始顺序，但可能会导致更多的递归调用。</li><li><strong>不稳定分区</strong>：将等于基准的元素放在基准的右边或任意一边。这种方法可能会改变相等元素的相对顺序，但可以减少递归的深度。</li></ul><p>在大多数实现中，快速排序是不稳定的，因为分区操作通常不关心相等元素的最终位置，只关心如何将数组分为两部分。不过，可以通过特定的实现来保持稳定性，但这通常不是快速排序的默认行为。</p><h4 id="问题3：这个排序的结束条件是什么？"><a href="#问题3：这个排序的结束条件是什么？" class="headerlink" title="问题3：这个排序的结束条件是什么？"></a>问题3：这个排序的结束条件是什么？</h4><p>快速排序的结束条件是数组的大小减小到不需要进一步排序。具体来说，有两种情况：</p><ul><li>当数组的大小为0或1时，它已经是有序的，不需要排序。这是递归的基本情况。</li><li>当数组的大小大于1时，快速排序将执行以下步骤：选择一个基准，将数组分为小于基准的元素、等于基准的元素和大于基准的元素的三个部分，然后递归地对小于和大于基准的元素的子数组进行快速排序。</li></ul><p>快速排序的递归性质意味着它会不断地将问题分解为更小的子问题，直到每个子问题足够小，可以直接解决。这个过程一直持续到整个数组都被排序完毕。</p><p>简而言之，快速排序的结束条件是数组中的每个元素都找到了它在排序后数组中的最终位置。</p><p>优化数据排序时等于基准的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs copy">def quick_sort_in_place(arr, low=0, high=None):<br>    if high is None:<br>        high = len(arr) - 1<br>    if low &lt; high:<br>        # 执行分区操作<br>        pi = partition(arr, low, high)<br>        <br>        # 对基准左边的子数组进行递归排序<br>        quick_sort_in_place(arr, low, pi - 1)<br>        # 对基准右边的子数组进行递归排序<br>        quick_sort_in_place(arr, pi + 1, high)<br><br>def partition(arr, low, high):<br>    pivot = arr[high]  # 选择最后一个元素作为基准<br>    i = low  # `i`用来记录小于基准的区域的最后一个元素的位置<br>    j = low  # `j`用来遍历数组元素<br><br>    while j &lt; high:<br>        # 如果当前元素小于或等于基准，交换元素，并将`i`向前移动<br>        if arr[j] &lt;= pivot:<br>            arr[i], arr[j] = arr[j], arr[i]<br>            i += 1<br>        j += 1<br><br>    # 交换基准到它最终的位置，确保所有小于基准的元素都在它的左边<br>    arr[i], arr[high] = arr[high], arr[i]<br><br>    # 返回基准的索引位置<br>    return i<br><br># 使用示例<br>array = [3, 6, 8, 10, 1, 2, 1]<br>quick_sort_in_place(array)<br>print(&quot;Sorted array:&quot;, array)<br></code></pre></td></tr></table></figure><h4 id="快速排序的应用案例："><a href="#快速排序的应用案例：" class="headerlink" title="快速排序的应用案例："></a>快速排序的应用案例：</h4><p>在线购物平台的商品排序：<br>当你在电商平台上根据价格、销量或评价对商品进行排序时，快速排序算法可以帮助你快速得到排序后的商品列表，提升用户体验。</p><p>图书馆书籍管理：<br>图书馆的管理系统可能会使用快速排序来整理书籍的索引，无论是按照作者、标题还是出版年份，都能快速地为读者提供有序的书籍列表。</p><p>股票市场数据分析：<br>在金融领域，快速排序可以用于对股票价格或交易量进行排序，帮助分析师快速识别市场趋势或异常波动。</p><h3 id="2-二分查找（Binary-Search）"><a href="#2-二分查找（Binary-Search）" class="headerlink" title="2. 二分查找（Binary Search）"></a>2. 二分查找（Binary Search）</h3><h4 id="产生原因与背景："><a href="#产生原因与背景：" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>二分查找算法的起源可以追溯到古代的“猜数字游戏”，但作为一种算法被正式提出是在计算机科学发展之后。它是一种在有序数组中查找特定元素的高效方法。二分查找的效率来源于每次比较操作可以排除数组中一半的元素，这使得查找操作的时间复杂度为O(log n)，远快于线性搜索的O(n)。二分查找在需要频繁查找的场景中非常有用，如数据库索引、搜索引擎和各种在线算法。</p><h4 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h4><p>二分查找是一种在有序数组中查找特定元素的算法，通过以下步骤进行：</p><ol><li>确定数组的中间位置。</li><li>比较中间元素与目标值，如果相等，则查找成功。</li><li>如果中间元素小于目标值，则在数组的右半部分继续查找；如果大于目标值，则在左半部分继续查找。</li><li>重复上述步骤，直到找到目标值或搜索范围为空。</li></ol><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">binary_search</span>(<span class="hljs-params">arr, target</span>):<br>    <span class="hljs-comment"># 初始化搜索的起始和结束索引</span><br>    start, end = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment"># 当起始索引小于或等于结束索引时继续搜索</span><br>    <span class="hljs-keyword">while</span> start &lt;= end:<br>        <span class="hljs-comment"># 计算中间索引</span><br>        mid = (start + end) // <span class="hljs-number">2</span><br>        <br>        <span class="hljs-comment"># 如果中间元素是目标值，返回中间索引</span><br>        <span class="hljs-keyword">if</span> arr[mid] == target:<br>            <span class="hljs-keyword">return</span> mid<br>        <span class="hljs-comment"># 如果中间元素小于目标值，更新起始索引为mid + 1</span><br>        <span class="hljs-keyword">elif</span> arr[mid] &lt; target:<br>            start = mid + <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 如果中间元素大于目标值，更新结束索引为mid - 1</span><br>        <span class="hljs-keyword">else</span>:<br>            end = mid - <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment"># 如果没有找到目标值，返回-1</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br><span class="hljs-comment"># 使用示例</span><br>arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br>target = <span class="hljs-number">7</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Index of target:&quot;</span>, binary_search(arr, target))<br></code></pre></td></tr></table></figure><h4 id="二分查找的应用案例："><a href="#二分查找的应用案例：" class="headerlink" title="二分查找的应用案例："></a>二分查找的应用案例：</h4><p>搜索引擎的关键词匹配：<br>当你在搜索引擎中输入关键词时，二分查找可以帮助快速定位到包含该关键词的网页，从而加快搜索结果的呈现速度。</p><p>计算机文件系统中的文件查找：<br>操作系统在文件系统中使用二分查找来快速定位文件，无论是在目录中查找文件名还是在数据库索引中查找记录。</p><p>医疗数据库中的药物检索：<br>在医疗数据库中，医生或研究人员可能需要快速查找特定药物的信息，二分查找可以在庞大的数据库中迅速定位到所需数据。</p><h3 id="3-动态规划的背包问题（Knapsack-Problem）"><a href="#3-动态规划的背包问题（Knapsack-Problem）" class="headerlink" title="3. 动态规划的背包问题（Knapsack Problem）"></a>3. 动态规划的背包问题（Knapsack Problem）</h3><h4 id="产生原因与背景：-1"><a href="#产生原因与背景：-1" class="headerlink" title="产生原因与背景："></a>产生原因与背景：</h4><p>背包问题是一个经典的优化问题，其概念可以追溯到经济学和运筹学中的资源分配问题。在现实世界中，人们经常面临有限资源（如预算、空间、时间等）下如何最大化收益的决策问题。背包问题最早由德国数学家H. W. E. Jensen在1883年提出，用于研究旅行者如何在有限的背包容量下选择携带哪些物品以最大化价值。动态规划是解决这类问题的一种有效方法，它通过将问题分解为重叠的子问题，并存储这些子问题的解来避免重复计算，从而提高问题求解的效率。</p><h4 id="动态规划解决背包问题的过程："><a href="#动态规划解决背包问题的过程：" class="headerlink" title="动态规划解决背包问题的过程："></a>动态规划解决背包问题的过程：</h4><ol><li><p><strong>列出所有可能</strong>：<br>首先，你把所有可能带上的物品列出来，写下它们的重量和价值。</p></li><li><p><strong>创建价值表</strong>：<br>然后，你创建一个表格，表格的行代表不同的物品，列代表背包的不同容量。这个表格将帮助你记录每种容量下你可以携带的最大价值。</p></li><li><p><strong>逐步填充表格</strong>：<br>你开始考虑第一个物品，如果它能够放入当前考虑的背包容量中，你就比较两个情况：不携带这个物品时的价值，和携带这个物品时的价值（即这个物品的价值加上剩余容量能够携带的最大价值）。你选择两者中价值更大的一个作为当前格子的值。</p></li><li><p><strong>重复比较过程</strong>：<br>接着，你继续考虑下一个物品，重复上述比较过程，直到你考虑完所有物品。</p></li><li><p><strong>得出最优解</strong>：<br>当表格填满后，最后一行的最后一列将告诉你在背包完全装满时能够携带的最大价值。</p></li></ol><h4 id="比喻示例："><a href="#比喻示例：" class="headerlink" title="比喻示例："></a>比喻示例：</h4><p>假设你的背包容量是10公斤，你有以下物品可供选择：</p><ul><li>指南针（重量1公斤，价值2金币）</li><li>帐篷（重量4公斤，价值5金币）</li><li>食物（重量3公斤，价值3金币）</li><li>睡袋（重量2公斤，价值4金币）</li></ul><p>你开始考虑第一个物品，指南针。如果背包容量是1公斤，那么你可以带上它，表格中1公斤那一格的值就是2金币。如果背包容量是2公斤，你可以选择不带指南针（价值0金币），或者带一个指南针和一些食物（价值2+3&#x3D;5金币，如果食物可以在这个容量下放入的话）。</p><p>你继续这个过程，直到考虑完所有物品和所有可能的背包容量。最终，你会发现当背包容量为10公斤时，你可以选择带上帐篷和睡袋（总重量6公斤，总价值9金币），这是在不超过背包容量的情况下，你能够携带的最大价值组合。</p><p>通过这个比喻，我们可以看到背包问题实际上是一个关于选择和优化的问题，它在我们的日常生活中无处不在，无论是打包行李、资源分配还是投资决策。动态规划为我们提供了一种有效的方法来找到最优解。</p><h4 id="代码示例：-1"><a href="#代码示例：-1" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义物品的重量和价值列表</span><br>weights = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]  <span class="hljs-comment"># 指南针、帐篷、食物、睡袋的重量</span><br>values = [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]   <span class="hljs-comment"># 对应物品的价值</span><br><br><span class="hljs-comment"># 背包的最大承重</span><br>max_capacity = <span class="hljs-number">10</span>  <span class="hljs-comment"># 背包容量为10公斤</span><br><br><span class="hljs-comment"># 初始化动态规划表格，dp[i][j] 表示在前 i 个物品中选择，且背包容量为 j 时的最大价值</span><br>dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_capacity + <span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weights) + <span class="hljs-number">1</span>)]<br><br><span class="hljs-comment"># 动态规划填表过程</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(weights) + <span class="hljs-number">1</span>):  <span class="hljs-comment"># 从第一个物品到所有物品</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, max_capacity + <span class="hljs-number">1</span>):  <span class="hljs-comment"># 从1公斤到最大容量</span><br>        <span class="hljs-comment"># 如果当前物品的重量小于等于背包当前容量</span><br>        <span class="hljs-keyword">if</span> weights[i - <span class="hljs-number">1</span>] &lt;= j:<br>            <span class="hljs-comment"># 选择不携带当前物品，或者携带当前物品（如果携带的话，需要加上剩余容量能带的最大价值）</span><br>            <span class="hljs-comment"># 取两者的最大值作为当前格子的值</span><br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weights[i - <span class="hljs-number">1</span>]] + values[i - <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果当前物品太重，不能放入背包，那么当前格子的值就是不包含这个物品时的最大价值</span><br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]<br><br><span class="hljs-comment"># 最大价值存储在dp表的最后一个格子中</span><br>max_value = dp[<span class="hljs-built_in">len</span>(weights)][max_capacity]<br><br><span class="hljs-comment"># 打印背包能够装载的最大价值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;背包能够装载的最大价值是:&quot;</span>, max_value)<br><br><span class="hljs-comment"># 如果需要找出具体哪些物品被选中，可以回溯dp表</span><br>selected_items = []<br>current_capacity = max_capacity<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weights), <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>    <span class="hljs-comment"># 如果当前行的值和上一行的值不同，说明选择了当前物品</span><br>    <span class="hljs-keyword">if</span> dp[i][current_capacity] != dp[i - <span class="hljs-number">1</span>][current_capacity]:<br>        selected_items.append((weights[i - <span class="hljs-number">1</span>], values[i - <span class="hljs-number">1</span>]))<br>        <span class="hljs-comment"># 更新剩余容量</span><br>        current_capacity -= weights[i - <span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># 打印被选中的物品及其价值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;被选中的物品及其价值:&quot;</span>, selected_items)<br></code></pre></td></tr></table></figure><p>这段代码首先定义了每个物品的重量和价值，以及背包的最大承重。然后，它创建了一个二维数组<code>dp</code>来存储每个物品组合下的最大价值。通过两层循环，代码遍历所有物品和所有可能的背包容量，使用动态规划的思想来填充<code>dp</code>表。最后，代码输出了背包能够装载的最大价值，并通过回溯<code>dp</code>表来找出哪些物品被选中。</p><h4 id="动态规划的背包问题应用案例："><a href="#动态规划的背包问题应用案例：" class="headerlink" title="动态规划的背包问题应用案例："></a>动态规划的背包问题应用案例：</h4><p>旅行行李打包：<br>当你准备去旅行时，需要决定带哪些物品以最大化行李箱的使用效率，同时不超过航空公司的行李重量限制，这就像是解决一个实际的背包问题。</p><p>投资组合优化：<br>投资者在有限的资金下，需要决定如何分配投资以获得最大收益，这可以通过动态规划来找到最优的资产分配方案。</p><p>资源分配问题：<br>在项目管理中，项目经理需要在有限的预算和时间内分配资源，以确保项目的关键部分得到足够的支持，这可以通过背包问题的动态规划方法来优化资源分配。</p><h3 id="事项三："><a href="#事项三：" class="headerlink" title="| 事项三："></a>| 事项三：</h3><p>收集3个有价值的硬核教程，并上传至个人博客网站上</p>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI布局B计划</title>
    <link href="/2024/06/25/AI%E5%B8%83%E5%B1%80B%E8%AE%A1%E5%88%92/"/>
    <url>/2024/06/25/AI%E5%B8%83%E5%B1%80B%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h3 id="AI布局B计划："><a href="#AI布局B计划：" class="headerlink" title="| AI布局B计划："></a>| AI布局B计划：</h3><p>第一步：在各大AI平台上创建属于自己的AI机器人<br>AI平台：poe.com</p>]]></content>
    
    
    <categories>
      
      <category>AI计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI技术所属公司信息</title>
    <link href="/2024/06/25/AI%E6%8A%80%E6%9C%AF%E6%89%80%E5%B1%9E%E5%85%AC%E5%8F%B8%E4%BF%A1%E6%81%AF/"/>
    <url>/2024/06/25/AI%E6%8A%80%E6%9C%AF%E6%89%80%E5%B1%9E%E5%85%AC%E5%8F%B8%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="AI技术所属公司信息："><a href="#AI技术所属公司信息：" class="headerlink" title="| AI技术所属公司信息："></a>| AI技术所属公司信息：</h3><p>Assistant、GPT-4、DALL-E-3 和 ChatGPT 由 OpenAI 提供支持。<br>Assistant 和 ChatGPT 使用该gpt-3.5-turbo模型。<br>Claude-instant 和 Claude-2 由 Anthropic 提供支持。<br>PaLM 和 Gemini-Pro 由 Google 提供支持。<br>Llama 2 是一个由 Meta 开发并由 Poe 托管的开源模型。Llama 2 已获得 LLAMA 2 社区许可，版权所有 © Meta Platforms, Inc. 保留所有权利。（许可证：<a href="https://ai.meta.com/resources/models-and-libraries/llama-downloads/%EF%BC%89">https://ai.meta.com/resources/models-and-libraries/llama-downloads/）</a><br>StableDiffusionXL 是由 Stability AI 开发并由 Poe 托管的开源模型。（许可证：<a href="https://huggingface.co/stability...%EF%BC%89">https://huggingface.co/stability...）</a><br>Playground-v2 是 Playground AI 的一个开源模型。<br>Mistral-Medium、Mixtral-8x7B-Chat、fw-mistral-7b 和 Qwen-72b-Chat 由 Fireworks.ai 托管：<a href="https://app.fireworks.ai/models/fireworks/qwen-72b-chat">https://app.fireworks.ai/models/fireworks/qwen-72b-chat</a></p>]]></content>
    
    
    <categories>
      
      <category>AI信息</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI信息</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日事项-2024年6月25日</title>
    <link href="/2024/06/25/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B46%E6%9C%8825%E6%97%A5/"/>
    <url>/2024/06/25/%E4%BB%8A%E6%97%A5%E4%BA%8B%E9%A1%B9-2024%E5%B9%B46%E6%9C%8825%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="今日事项"><a href="#今日事项" class="headerlink" title="今日事项"></a>今日事项</h1><h2 id="今日事项：2024年6月25日"><a href="#今日事项：2024年6月25日" class="headerlink" title="| 今日事项：2024年6月25日"></a>| 今日事项：2024年6月25日</h2><h3 id="事项一："><a href="#事项一：" class="headerlink" title="| 事项一："></a>| 事项一：</h3><p>用谷歌邮箱订阅OPEN AI、特斯拉、微软AI消息(√)</p><h3 id="事项二："><a href="#事项二：" class="headerlink" title="| 事项二："></a>| 事项二：</h3><p>上传数据库表结构文件，让 AI 来帮我写sql查询语句（√）<br>kimi: 80分，字段注释不清晰的地方，kimi不能理解字段所对应的表名是哪个<br>claude-3-Sonnet: 50分，没有输出表中的全部字段，会出现无中生有的情况<br>Gemini-1.5-Flash-128k：90分，能理解字段在哪张表，同时也能挖掘出字段的深层次关系</p><h3 id="事项三："><a href="#事项三：" class="headerlink" title="| 事项三："></a>| 事项三：</h3><p>收集3个有价值的硬核教程，并上传至个人博客网站上<br>第一个：windows10&#x2F;windows11重装系统（√）<br>第二个：电脑忘记锁屏密码（√）<br>第三个：安卓手机忘记锁屏密码（√）<br>        电源键+音量减键（或电源键+音量加键）进入工厂模式，然后清除数据，最后，重启手机</p>]]></content>
    
    
    <categories>
      
      <category>今日事项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>今日事项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的数据类型</title>
    <link href="/2024/06/25/%E7%94%B5%E6%B0%94%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2024/06/25/%E7%94%B5%E6%B0%94%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="电气工程师"><a href="#电气工程师" class="headerlink" title="电气工程师|"></a>电气工程师|</h1><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>电气工程师在进行自动化控制系统设计和编程时，常用的数据类型通常与控制逻辑、传感器数据、执行器状态等相关。以下是一些常见的数据类型及其使用场景的例子：</p><ol><li><p><strong>布尔型（Boolean）</strong>：</p><ul><li>用于表示开关状态或条件判断，例如继电器的开&#x2F;关状态（True&#x2F;False）。</li></ul></li><li><p><strong>整数型（Integer）</strong>：</p><ul><li>用于计数或表示没有小数部分的数值，如计数器的数值（计数值、序号等）。</li></ul></li><li><p><strong>浮点型（Floating Point）</strong>：</p><ul><li>用于表示有小数部分的数值，如温度传感器的读数（摄氏度或华氏度）、压力传感器的输出等。</li></ul></li><li><p><strong>字符串型（String）</strong>：</p><ul><li>用于存储和传输文本信息，如设备名称、状态信息、错误消息等。</li></ul></li><li><p><strong>数组（Array）</strong>：</p><ul><li>用于存储一系列相同类型的数据，例如多个温度传感器的读数可以存储在一个浮点数数组中。</li></ul></li><li><p><strong>结构体（Structure）</strong>：</p><ul><li>用于存储一组相关的数据，例如一个设备的结构可能包含设备ID（整数型）、设备状态（布尔型）、当前温度（浮点型）等。</li></ul></li><li><p><strong>枚举型（Enumeration）</strong>：</p><ul><li>用于表示一组命名的常量，例如操作模式可能包括自动（AUTO）、手动（MANUAL）、待机（IDLE）等。</li></ul></li><li><p><strong>位字段（Bit Field）</strong>：</p><ul><li>用于在单个整数变量中存储多个布尔值或标志位，如一个8位的位字段可以表示8个不同的开关状态。</li></ul></li><li><p><strong>指针型（Pointer）</strong>：</p><ul><li>虽然在高级编程中不常用，但在底层或特定情况下，指针可能用于直接访问硬件地址或内存。</li></ul></li><li><p><strong>时间&#x2F;日期型（Time&#x2F;Date）</strong>：</p><ul><li>用于存储时间戳或日期信息，例如记录设备最后维护的日期。</li></ul></li></ol><h3 id="详细例子："><a href="#详细例子：" class="headerlink" title="详细例子："></a>详细例子：</h3><ul><li><p><strong>温度控制系统</strong>：</p><ul><li>温度传感器可能返回一个浮点型数据，表示当前温度。</li><li>控制器内部可能使用一个整数型变量来存储目标温度的设定值。</li></ul></li><li><p><strong>电机控制</strong>：</p><ul><li>电机的运行状态可能用布尔型表示（True表示运行，False表示停止）。</li><li>电机的速度可能用整数型或浮点型表示。</li></ul></li><li><p><strong>报警系统</strong>：</p><ul><li>每个报警的状态可能用布尔型表示（True表示报警触发，False表示正常）。</li><li>报警消息可能用字符串型存储，以提供详细的报警描述。</li></ul></li><li><p><strong>数据记录</strong>：</p><ul><li>一个数组可能用来存储一段时间内的温度读数，每个元素是一个浮点型数据。</li><li>结构体可能用来存储每次记录的详细信息，包括时间戳（时间&#x2F;日期型）、温度（浮点型）、设备ID（整数型）等。</li></ul></li></ul><p>在自动化控制系统中，特别是在使用PLC（可编程逻辑控制器）时，变量地址是用来唯一标识内存中数据的位置。这些地址通常遵循特定的格式，以便用户可以快速地引用和操作数据。以下是一些常见的变量地址格式的详细解释，以及它们可能代表的含义：</p><ol><li><p><strong>DB（Data Block）</strong>：</p><ul><li>表示数据块的缩写，数据块是PLC内存中用于存储数据的一部分区域。每个数据块可以包含多个不同类型的数据。</li></ul></li><li><p><strong>DBX</strong>：</p><ul><li>这里的”X”是一个数字，表示数据块的编号。例如，DB7表示编号为7的数据块。</li></ul></li><li><p><strong>D</strong>：</p><ul><li>表示数据寄存器的缩写，通常用于存储过程变量或过程数据。</li></ul></li><li><p><strong>DBD</strong>：</p><ul><li>表示数据块中的双字（Double Word）寄存器，通常用于存储32位的数据。</li></ul></li><li><p><strong>X</strong>：</p><ul><li>通常用于表示输入（I）或输出（O）模块中的寄存器，例如X0.0表示输入模块的第一个寄存器。</li></ul></li><li><p><strong>Y</strong>：</p><ul><li>类似于X，但用于表示输出模块中的寄存器，例如Y0.0表示输出模块的第一个寄存器。</li></ul></li><li><p><strong>M</strong>：</p><ul><li>表示辅助存储器，用于存储标志位、中间变量等。</li></ul></li><li><p><strong>T</strong>：</p><ul><li>表示定时器，用于执行时间相关的操作。</li></ul></li><li><p><strong>C</strong>：</p><ul><li>表示计数器，用于计数事件发生的次数。</li></ul></li><li><p><strong>L</strong>：</p><ul><li>表示局部变量，通常在程序的某个部分内部使用。</li></ul></li><li><p><strong>V</strong>：</p><ul><li>表示变量，用户自定义的变量，用于存储程序中需要的数据。</li></ul></li><li><p><strong>Z</strong>：</p><ul><li>表示特殊寄存器，用于特定的系统功能。</li></ul></li></ol><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><ul><li><p><strong>DB7.DBX40</strong>：</p><ul><li>这可能表示数据块7中的第40个字节（Byte）的地址。在某些PLC系统中，一个数据块可以包含多个字节，DBX40可能是指向该数据块的第40个字节的指针。</li></ul></li><li><p><strong>I0.0</strong>：</p><ul><li>这表示输入模块的第一个布尔型寄存器，通常用于读取外部信号的状态。</li></ul></li><li><p><strong>Q0.0</strong>：</p><ul><li>这表示输出模块的第一个布尔型寄存器，通常用于控制外部设备的状态。</li></ul></li><li><p><strong>M100</strong>：</p><ul><li>这表示辅助存储器中的第100个字节的地址，可以用来存储标志位或中间状态。</li></ul></li><li><p><strong>T1</strong>：</p><ul><li>这表示定时器1的地址，可以用来设置和监控时间间隔。</li></ul></li><li><p><strong>C0</strong>：</p><ul><li>这表示计数器0的地址，可以用来计数事件的发生次数。</li></ul></li><li><p><strong>L1.DBW10</strong>：</p><ul><li>这可能表示局部数据块1中的第10个字（Word，通常是16位）的地址。</li></ul></li><li><p><strong>VB100</strong>：</p><ul><li>这表示字节型变量100的地址，可以用来存储一个字节的数据。</li></ul></li><li><p><strong>VD100</strong>：</p><ul><li>这表示双字型变量100的地址，可以用来存储一个双字（32位）的数据。</li></ul></li></ul><p>这些地址格式在不同的PLC和自动化系统中可能有所不同，但基本原理是相似的。理解这些地址格式有助于电气工程师在编程和故障排除时快速准确地定位和操作数据。</p><p>在PLC编程中，地址 <code>DB11.DBX21.1</code> 通常用于表示一个数据块中的特定位（bit）位置。下面是这个地址各部分的含义：</p><ol><li><p><strong>DB</strong>：表示 “Data Block”，即数据块。数据块是PLC内存中用于存储数据的逻辑单元，可以包含不同类型的数据，如整数、浮点数、布尔值等。</p></li><li><p><strong>11</strong>：这是数据块的编号，表示这是系统中的第11个数据块。</p></li><li><p><strong>DBX</strong>：通常表示数据块中的一个字节（Byte）或字（Word）的地址。这里的 “X” 表示偏移量，它是一个从0开始的索引，用来指定数据块中的位置。</p></li><li><p><strong>21</strong>：这是数据块内的位置索引，表示从数据块的起始位置开始的第21个字节或字。在某些PLC系统中，如果DBX表示字节，那么这个数字就是字节索引；如果DBX表示字（通常是16位），那么这个数字可能是字的索引。</p></li><li><p><strong>.1</strong>：这个部分表示位索引，用来指定一个字节中的某个位。位索引从0开始，到7结束（因为一个字节有8位）。在这个例子中，<code>.1</code> 表示我们关注的是第21个字节中的第二个位（从0开始计数，所以是第一个位之后的第二个位）。</p></li></ol><p>将这些部分组合起来，<code>DB11.DBX21.1</code> 表示的是编号为11的数据块中的第21个字节的第二个位。在实际应用中，这个地址可能用来存储一个布尔值或标志位，例如：</p><ul><li>如果这个位被设置为1，可能表示某个特定的条件已经满足或某个事件发生了。</li><li>如果这个位被清除为0，可能表示条件不满足或事件未发生。</li></ul><p>使用位地址可以非常高效地存储和处理大量的布尔值或标志位，因为它们只占用单个位的空间。这种方法在需要精细控制或状态监控的自动化系统中非常常见。</p><p>在PLC编程中，<code>DB11.DBW22</code> 这样的地址格式通常用来表示一个特定的数据存储位置。让我们分解这个地址来更好地理解它：</p><ol><li><p><strong>DB</strong>：</p><ul><li>这是 “Data Block” 的缩写，指的是一个数据块。数据块是PLC内存中用于组织和存储数据的逻辑单元。每个数据块可以包含多个不同类型的数据，比如整数、浮点数、字符串等。</li></ul></li><li><p><strong>11</strong>：</p><ul><li>这个数字表示数据块的编号。在这个例子中，<code>11</code> 指的是编号为11的数据块。</li></ul></li><li><p><strong>DBW</strong>：</p><ul><li>这是 “Data Block Word” 的缩写，表示数据块中的一个字（Word）数据。在许多PLC系统中，一个字通常是16位的存储单元，可以存储一个整数或一个浮点数的一部分（取决于具体的PLC和其数据类型）。</li></ul></li><li><p><strong>22</strong>：</p><ul><li>这个数字表示数据块中字的偏移量或编号。在这个例子中，<code>22</code> 指的是从数据块的起始位置开始的第22个字。</li></ul></li></ol><p>将这些部分组合起来，<code>DB11.DBW22</code> 表示的是编号为11的数据块中的第22个字数据。在实际应用中，这个地址可能用来存储一个特定的数值，比如一个过程变量的测量值、一个计算结果，或者作为程序中某个逻辑判断的依据。</p><p>例如，如果一个PLC程序需要跟踪一个水箱的水位高度，并且水位数据以16位整数的形式存储，那么<code>DB11.DBW22</code>可能就是用来存储当前水位高度的内存位置。程序的其他部分可以通过引用这个地址来读取或更新水位数据。</p><p>在 PLC 编程中，<code>DB8.DBW40.0</code> 这样的地址格式通常用来表示数据块中的一个特定字（Word）的特定位（Bit）。下面是这个地址各部分的详细解释：</p><ol><li><p><strong>DB</strong>：这是 “Data Block” 的缩写，指的是 PLC 内存中用于存储数据的一块区域。数据块可以包含不同类型的数据，如整数、浮点数、布尔值等。</p></li><li><p><strong>8</strong>：这个数字表示数据块的编号，即这是系统中的第8个数据块。</p></li><li><p><strong>DBW</strong>：这是 “Data Block Word” 的缩写，表示数据块中的一个字（Word）数据。在许多 PLC 系统中，一个字通常是16位的存储单元。</p></li><li><p><strong>40</strong>：这个数字表示数据块中字的索引或编号。在这个例子中，<code>40</code> 指的是数据块中的第40个字。</p></li><li><p><strong>.0</strong>：这个部分表示位索引，用来指定一个字中的特定位。位索引从0开始，到15结束（因为一个字有16位）。在这个例子中，<code>.0</code> 表示我们关注的是第40个字的第一个位。</p></li></ol><p>将这些部分组合起来，<code>DB8.DBW40.0</code> 表示的是编号为8的数据块中的第40个字的第一个位。在实际应用中，这个地址可能用来存储一个布尔值或标志位，例如：</p><ul><li>如果这个位被设置为1，可能表示某个特定的条件已经满足或某个事件发生了。</li><li>如果这个位被清除为0，可能表示条件不满足或事件未发生。</li></ul><p>使用位地址可以非常高效地存储和处理大量的布尔值或标志位，因为它们只占用单个位的空间。这种方法在需要精细控制或状态监控的自动化系统中非常常见。</p><p>然而，需要注意的是，不同的 PLC 系统或编程环境可能有不同的数据类型和地址表示方法。在某些系统中，<code>DBW</code> 可能表示一个16位的整数，而不是一个位的地址。因此，理解 <code>DB8.DBW40.0</code> 的确切含义需要参考具体的 PLC 文档或编程手册。</p>]]></content>
    
    
    <categories>
      
      <category>电气工程师</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电气工程师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建个人品牌</title>
    <link href="/2024/06/24/%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%93%81%E7%89%8C/"/>
    <url>/2024/06/24/%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%93%81%E7%89%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第十部分：专业发展和职业规划"><a href="#高级提示词工程师-第十部分：专业发展和职业规划" class="headerlink" title="高级提示词工程师| 第十部分：专业发展和职业规划"></a>高级提示词工程师| 第十部分：专业发展和职业规划</h1><h2 id="第四节：创建个人品牌"><a href="#第四节：创建个人品牌" class="headerlink" title="| 第四节：创建个人品牌"></a>| 第四节：创建个人品牌</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>创建个人品牌就像是在艺术画廊中展出自己的作品，它让我们有机会向世界展示自己的独特价值和专业成就。</p><ul><li><strong>个人定位</strong>：明确自己在专业领域中的定位，了解自己的长处和特色。</li><li><strong>内容创作</strong>：通过撰写文章、制作视频或在社交媒体上分享，展示自己的专业知识和见解。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设我们正在使用一个博客平台的API来发布技术文章</span><br><br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># 博客文章的API端点</span><br>blog_api_url = <span class="hljs-string">&quot;https://api.example-blog.com/posts&quot;</span><br><br><span class="hljs-comment"># 要发布的文章内容</span><br>article_title = <span class="hljs-string">&quot;My Journey with AI&quot;</span><br>article_content = <span class="hljs-string">&quot;This is a story about how I started learning AI...&quot;</span><br><br><span class="hljs-comment"># 发布文章的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">publish_article</span>(<span class="hljs-params">title, content</span>):<br>    headers = &#123;<span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;Bearer YOUR_ACCESS_TOKEN&#x27;</span>&#125;<br>    article_data = &#123;<span class="hljs-string">&#x27;title&#x27;</span>: title, <span class="hljs-string">&#x27;content&#x27;</span>: content&#125;<br>    response = requests.post(blog_api_url, json=article_data, headers=headers)<br>    <span class="hljs-keyword">return</span> response.status_code<br><br><span class="hljs-comment"># 发布文章</span><br>publish_article(article_title, article_content)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>例如，一位AI领域的专业人士通过在Medium上定期发布关于机器学习的文章，逐渐建立起了个人品牌，并吸引了一批忠实读者。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>10.专业发展和职业规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>专业发展和职业规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>准备简历和面试技巧</title>
    <link href="/2024/06/24/%E5%87%86%E5%A4%87%E7%AE%80%E5%8E%86%E5%92%8C%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/06/24/%E5%87%86%E5%A4%87%E7%AE%80%E5%8E%86%E5%92%8C%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第十部分：专业发展和职业规划"><a href="#高级提示词工程师-第十部分：专业发展和职业规划" class="headerlink" title="高级提示词工程师| 第十部分：专业发展和职业规划"></a>高级提示词工程师| 第十部分：专业发展和职业规划</h1><h2 id="第三节：准备简历和面试技巧"><a href="#第三节：准备简历和面试技巧" class="headerlink" title="| 第三节：准备简历和面试技巧"></a>| 第三节：准备简历和面试技巧</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>准备简历和面试技巧就像是为一场演出精心准备，我们需要确保自己的能力和经验能够得到最好的展示。</p><ul><li><strong>简历编写</strong>：编写一份精炼、突出重点的简历，确保它能够快速抓住招聘者的注意力。</li><li><strong>面试技巧</strong>：学习如何回答常见的面试问题，展示自己的技术能力和解决问题的方法。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设我们正在使用文本处理技术来帮助用户优化简历的关键词</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">optimize_resume</span>(<span class="hljs-params">resume_text, desired_skills</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    分析简历文本，确保包含所需的技能关键词。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    resume_skills = <span class="hljs-built_in">set</span>(resume_text.lower().split())<br>    missing_skills = [skill <span class="hljs-keyword">for</span> skill <span class="hljs-keyword">in</span> desired_skills <span class="hljs-keyword">if</span> skill <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> resume_skills]<br>    <br>    <span class="hljs-keyword">if</span> missing_skills:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Add the following skills to your resume:&quot;</span>, missing_skills)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Your resume includes all desired skills.&quot;</span>)<br><br><span class="hljs-comment"># 用户的简历文本和期望的技能列表</span><br>resume_text = <span class="hljs-string">&quot;Machine learning, data analysis, Python&quot;</span><br>desired_skills = [<span class="hljs-string">&quot;Machine Learning&quot;</span>, <span class="hljs-string">&quot;Data Analysis&quot;</span>, <span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-string">&quot;AI&quot;</span>]<br><br><span class="hljs-comment"># 优化简历关键词</span><br>optimize_resume(resume_text, desired_skills)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>例如，一位求职者在准备面试时，通过模拟面试和回顾常见问题，成功地在面试中展现了自己的专业技能和清晰的解题思路。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>10.专业发展和职业规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>专业发展和职业规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建立专业网络</title>
    <link href="/2024/06/24/%E5%BB%BA%E7%AB%8B%E4%B8%93%E4%B8%9A%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/06/24/%E5%BB%BA%E7%AB%8B%E4%B8%93%E4%B8%9A%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第十部分：专业发展和职业规划"><a href="#高级提示词工程师-第十部分：专业发展和职业规划" class="headerlink" title="高级提示词工程师| 第十部分：专业发展和职业规划"></a>高级提示词工程师| 第十部分：专业发展和职业规划</h1><h2 id="第二节：建立专业网络"><a href="#第二节：建立专业网络" class="headerlink" title="| 第二节：建立专业网络"></a>| 第二节：建立专业网络</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>建立专业网络就像是在大海中航行时拥有一张航海图，它指引我们与正确的人相遇，共同探索知识的海洋。</p><ul><li><strong>社交技巧</strong>：学习如何与他人建立联系，进行有效沟通。</li><li><strong>专业社群</strong>：加入LinkedIn、GitHub等平台上的专业社群，参与讨论和活动。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设我们正在使用LinkedIn API来建立和维护专业网络</span><br><br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># LinkedIn API endpoint for getting connections</span><br>api_url = <span class="hljs-string">&quot;https://api.linkedin.com/v2/connections&quot;</span><br><br><span class="hljs-comment"># Make an authenticated request to get connections</span><br>response = requests.get(api_url, headers=&#123;<span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;Bearer YOUR_ACCESS_TOKEN&#x27;</span>&#125;)<br>connections = response.json()<br><br><span class="hljs-comment"># Print out the names and positions of your connections</span><br><span class="hljs-keyword">for</span> connection <span class="hljs-keyword">in</span> connections[<span class="hljs-string">&#x27;values&#x27;</span>]:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Name: <span class="hljs-subst">&#123;connection[<span class="hljs-string">&#x27;firstName&#x27;</span>]&#125;</span> <span class="hljs-subst">&#123;connection[<span class="hljs-string">&#x27;lastName&#x27;</span>]&#125;</span>, Position: <span class="hljs-subst">&#123;connection[<span class="hljs-string">&#x27;headline&#x27;</span>]&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>例如，一位数据科学家通过LinkedIn加入了数据科学相关的专业群组，积极参与讨论，最终获得了一个行业会议的演讲邀请，这大大提升了他的职业影响力。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>10.专业发展和职业规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>专业发展和职业规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>了解行业需求和职业机会</title>
    <link href="/2024/06/24/%E4%BA%86%E8%A7%A3%E8%A1%8C%E4%B8%9A%E9%9C%80%E6%B1%82%E5%92%8C%E8%81%8C%E4%B8%9A%E6%9C%BA%E4%BC%9A/"/>
    <url>/2024/06/24/%E4%BA%86%E8%A7%A3%E8%A1%8C%E4%B8%9A%E9%9C%80%E6%B1%82%E5%92%8C%E8%81%8C%E4%B8%9A%E6%9C%BA%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第十部分：专业发展和职业规划"><a href="#高级提示词工程师-第十部分：专业发展和职业规划" class="headerlink" title="高级提示词工程师| 第十部分：专业发展和职业规划"></a>高级提示词工程师| 第十部分：专业发展和职业规划</h1><h2 id="第一节：了解行业需求和职业机会"><a href="#第一节：了解行业需求和职业机会" class="headerlink" title="| 第一节：了解行业需求和职业机会"></a>| 第一节：了解行业需求和职业机会</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>了解行业需求和职业机会就像是在探险前研究地图，它帮助我们识别宝藏的所在，规划最佳的探险路线。</p><ul><li><strong>行业趋势</strong>：通过研究行业报告和市场分析，了解哪些技术和领域正在兴起。</li><li><strong>职业机会</strong>：识别不同行业和地区对AI专业人才的需求，发现潜在的职业机会。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设我们正在使用网络爬虫技术来分析招聘网站上的职位需求</span><br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br><span class="hljs-comment"># 请求招聘网站的AI相关职位页面</span><br>response = requests.get(<span class="hljs-string">&#x27;https://www.example-job-website.com/ai-jobs&#x27;</span>)<br>soup = BeautifulSoup(response.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br><br><span class="hljs-comment"># 解析职位列表</span><br>job_listings = soup.find_all(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;job-listing&#x27;</span>)<br><span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> job_listings:<br>    <span class="hljs-built_in">print</span>(job.find(<span class="hljs-string">&#x27;h3&#x27;</span>).text)  <span class="hljs-comment"># 打印职位名称</span><br>    <span class="hljs-built_in">print</span>(job.find(<span class="hljs-string">&#x27;span&#x27;</span>, class_=<span class="hljs-string">&#x27;location&#x27;</span>).text)  <span class="hljs-comment"># 打印职位地点</span><br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>例如，通过分析LinkedIn上的职位数据，我们发现数据科学家的需求在逐年增长，特别是在金融和健康医疗行业。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>10.专业发展和职业规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>专业发展和职业规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实践项目-在GitHub上贡献代码或撰写技术博客</title>
    <link href="/2024/06/24/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE-%E5%9C%A8GitHub%E4%B8%8A%E8%B4%A1%E7%8C%AE%E4%BB%A3%E7%A0%81%E6%88%96%E6%92%B0%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/06/24/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE-%E5%9C%A8GitHub%E4%B8%8A%E8%B4%A1%E7%8C%AE%E4%BB%A3%E7%A0%81%E6%88%96%E6%92%B0%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第九部分：持续学习和社区参与"><a href="#高级提示词工程师-第九部分：持续学习和社区参与" class="headerlink" title="高级提示词工程师| 第九部分：持续学习和社区参与"></a>高级提示词工程师| 第九部分：持续学习和社区参与</h1><h2 id="第四节：实践项目"><a href="#第四节：实践项目" class="headerlink" title="| 第四节：实践项目"></a>| 第四节：实践项目</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>在GitHub上贡献代码或撰写技术博客就像是在知识的海洋中投下自己的石子，虽小却能激起层层涟漪，影响和启发他人。</p><ul><li><strong>代码贡献</strong>：在GitHub上为开源项目贡献代码，可以帮助项目改进，同时也是提升自己编程技能的好机会。</li><li><strong>技术博客</strong>：通过撰写技术博客，我们可以分享自己的学习经验、项目心得和行业见解。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设我们想要为一个开源项目贡献代码，首先需要克隆仓库</span><br><br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 克隆GitHub仓库的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">clone_repository</span>(<span class="hljs-params">repo_url</span>):<br>    <span class="hljs-keyword">if</span> os.path.exists(<span class="hljs-string">&#x27;repository&#x27;</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Repository already exists.&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        os.system(<span class="hljs-string">f&quot;git clone <span class="hljs-subst">&#123;repo_url&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Repository cloned successfully.&quot;</span>)<br><br><span class="hljs-comment"># GitHub仓库URL</span><br>repo_url = <span class="hljs-string">&quot;https://github.com/owner/repo.git&quot;</span><br><br><span class="hljs-comment"># 克隆仓库</span><br>clone_repository(repo_url)<br><br><span class="hljs-comment"># 接下来，我们可以在本地开发环境中修改代码，并通过Pull Request提交贡献</span><br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>以Kimi Chat的开源项目为例，开发者们通过GitHub贡献代码，添加新功能，修复bug。例如，一位贡献者通过阅读文档和源代码，发现了一个用户界面的可用性问题，并提交了一个改进的Pull Request，最终被项目维护者接受并合并到主分支。</p><h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h3><p>选择一个你感兴趣的开源项目，在GitHub上为其贡献代码。或者，创建自己的技术博客，分享你最近学到的AI知识。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>9.持续学习和社区参与</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>持续学习和社区参与</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>参加相关的研讨会和会议</title>
    <link href="/2024/06/24/%E5%8F%82%E5%8A%A0%E7%9B%B8%E5%85%B3%E7%9A%84%E7%A0%94%E8%AE%A8%E4%BC%9A%E5%92%8C%E4%BC%9A%E8%AE%AE/"/>
    <url>/2024/06/24/%E5%8F%82%E5%8A%A0%E7%9B%B8%E5%85%B3%E7%9A%84%E7%A0%94%E8%AE%A8%E4%BC%9A%E5%92%8C%E4%BC%9A%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第九部分：持续学习和社区参与"><a href="#高级提示词工程师-第九部分：持续学习和社区参与" class="headerlink" title="高级提示词工程师| 第九部分：持续学习和社区参与"></a>高级提示词工程师| 第九部分：持续学习和社区参与</h1><h2 id="第三节：参加相关的研讨会和会议"><a href="#第三节：参加相关的研讨会和会议" class="headerlink" title="| 第三节：参加相关的研讨会和会议"></a>| 第三节：参加相关的研讨会和会议</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>参加研讨会和会议就像是进入了一个充满机遇的宝库，我们不仅能获得知识，还能与行业内的专家和同行建立联系。</p><ul><li><strong>知识更新</strong>：研讨会和会议是获取最新研究和技术动态的重要途径。</li><li><strong>人际网络</strong>：在这些活动中，我们可以与行业内的专家、学者和企业家建立联系，拓展职业网络。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设我们正在使用一个会议的API来获取即将举行的会议信息</span><br><br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># API URL for a conference information</span><br>conference_api_url = <span class="hljs-string">&quot;https://api.example-conference.com/conferences&quot;</span><br><br><span class="hljs-comment"># 发送请求，获取会议列表</span><br>response = requests.get(conference_api_url)<br>conferences = response.json()<br><br><span class="hljs-comment"># 遍历会议列表并打印会议信息</span><br><span class="hljs-keyword">for</span> conference <span class="hljs-keyword">in</span> conferences:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Conference Name: <span class="hljs-subst">&#123;conference[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Date: <span class="hljs-subst">&#123;conference[<span class="hljs-string">&#x27;date&#x27;</span>]&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Location: <span class="hljs-subst">&#123;conference[<span class="hljs-string">&#x27;location&#x27;</span>]&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Description: <span class="hljs-subst">&#123;conference[<span class="hljs-string">&#x27;description&#x27;</span>]&#125;</span>\n&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>每年，NeurIPS（神经信息处理系统会议）都会吸引全球的AI研究者参加。在会议上，最新的研究成果被展示，研究者们有机会与领域内的顶尖科学家交流，并建立合作关系。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>9.持续学习和社区参与</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>持续学习和社区参与</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>参与开源项目和社区讨论</title>
    <link href="/2024/06/24/%E5%8F%82%E4%B8%8E%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%92%8C%E7%A4%BE%E5%8C%BA%E8%AE%A8%E8%AE%BA/"/>
    <url>/2024/06/24/%E5%8F%82%E4%B8%8E%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%92%8C%E7%A4%BE%E5%8C%BA%E8%AE%A8%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第九部分：持续学习和社区参与"><a href="#高级提示词工程师-第九部分：持续学习和社区参与" class="headerlink" title="高级提示词工程师| 第九部分：持续学习和社区参与"></a>高级提示词工程师| 第九部分：持续学习和社区参与</h1><h2 id="第二节：参与开源项目和社区讨论"><a href="#第二节：参与开源项目和社区讨论" class="headerlink" title="| 第二节：参与开源项目和社区讨论"></a>| 第二节：参与开源项目和社区讨论</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>参与开源项目和社区讨论就像是加入一场知识与智慧的盛宴，我们不仅能品尝到他人烹饪的佳肴，还能贡献自己的拿手好菜。</p><ul><li><strong>开源项目</strong>：开源项目允许任何人贡献代码，促进了技术的共享与创新。</li><li><strong>社区讨论</strong>：在社区中，我们可以提出问题、分享经验、讨论技术，与同行交流思想。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设我们正在使用GitHub的API来参与一个开源项目</span><br><br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># GitHub API URL for a specific repository</span><br>api_url = <span class="hljs-string">&quot;https://api.github.com/repos/owner/repo/issues&quot;</span><br><br><span class="hljs-comment"># 发送请求，获取issue列表</span><br>response = requests.get(api_url)<br>issues = response.json()<br><br><span class="hljs-comment"># 遍历issues并打印</span><br><span class="hljs-keyword">for</span> issue <span class="hljs-keyword">in</span> issues:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Issue #<span class="hljs-subst">&#123;issue[<span class="hljs-string">&#x27;number&#x27;</span>]&#125;</span>: <span class="hljs-subst">&#123;issue[<span class="hljs-string">&#x27;title&#x27;</span>]&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 假设我们要为一个issue贡献一个解决方案</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">contribute_to_issue</span>(<span class="hljs-params">issue_number, solution</span>):<br>    headers = &#123;<span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;token YOUR_ACCESS_TOKEN&#x27;</span>&#125;<br>    data = &#123;<span class="hljs-string">&#x27;body&#x27;</span>: solution&#125;<br>    issue_url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;api_url&#125;</span>/<span class="hljs-subst">&#123;issue_number&#125;</span>/comments&quot;</span><br>    response = requests.post(issue_url, json=data, headers=headers)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Contribution status: <span class="hljs-subst">&#123;response.status_code&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在TensorFlow的开源社区中，世界各地的开发者共同贡献代码，解决bug，添加新功能。例如，一位开发者遇到了一个性能瓶颈问题，他通过社区讨论得到了解决方案，并最终通过贡献代码帮助优化了整个项目。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>9.持续学习和社区参与</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>持续学习和社区参与</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读学术论文和行业报告</title>
    <link href="/2024/06/24/%E9%98%85%E8%AF%BB%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E5%92%8C%E8%A1%8C%E4%B8%9A%E6%8A%A5%E5%91%8A/"/>
    <url>/2024/06/24/%E9%98%85%E8%AF%BB%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E5%92%8C%E8%A1%8C%E4%B8%9A%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第九部分：持续学习和社区参与"><a href="#高级提示词工程师-第九部分：持续学习和社区参与" class="headerlink" title="高级提示词工程师| 第九部分：持续学习和社区参与"></a>高级提示词工程师| 第九部分：持续学习和社区参与</h1><h2 id="第一节：阅读学术论文和行业报告"><a href="#第一节：阅读学术论文和行业报告" class="headerlink" title="| 第一节：阅读学术论文和行业报告"></a>| 第一节：阅读学术论文和行业报告</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>阅读学术论文和行业报告就像是站在巨人的肩膀上，让我们能够借助前人的研究成果和行业专家的见解，更快地攀登知识的高峰。</p><ul><li><strong>学术论文</strong>：学术论文是学术界交流最新研究成果的主要渠道，通过阅读学术论文，我们可以了解最前沿的理论和方法。</li><li><strong>行业报告</strong>：行业报告通常由市场研究机构或行业协会编写，提供行业发展的宏观视角和趋势分析。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设我们正在使用Python的requests库和BeautifulSoup库</span><br><span class="hljs-comment"># 来抓取和解析学术论文和行业报告网站上的内容</span><br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br><span class="hljs-comment"># 请求学术论文网站</span><br>response = requests.get(<span class="hljs-string">&#x27;https://www.example-academic-website.com&#x27;</span>)<br>soup = BeautifulSoup(response.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br><br><span class="hljs-comment"># 解析学术论文列表</span><br>academic_papers = soup.find_all(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;paper&#x27;</span>)<br><span class="hljs-keyword">for</span> paper <span class="hljs-keyword">in</span> academic_papers:<br>    <span class="hljs-built_in">print</span>(paper.find(<span class="hljs-string">&#x27;h2&#x27;</span>).text)  <span class="hljs-comment"># 打印论文标题</span><br><br><span class="hljs-comment"># 请求行业报告网站</span><br>response = requests.get(<span class="hljs-string">&#x27;https://www.example-industry-report.com&#x27;</span>)<br>soup = BeautifulSoup(response.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br><br><span class="hljs-comment"># 解析行业报告列表</span><br>industry_reports = soup.find_all(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;report&#x27;</span>)<br><span class="hljs-keyword">for</span> report <span class="hljs-keyword">in</span> industry_reports:<br>    <span class="hljs-built_in">print</span>(report.find(<span class="hljs-string">&#x27;h2&#x27;</span>).text)  <span class="hljs-comment"># 打印报告标题</span><br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在自动驾驶领域，学术论文和行业报告为研究人员和工程师提供了宝贵的信息。例如，通过阅读最新的学术论文，研究人员了解到了一种新的传感器融合算法，而行业报告则揭示了消费者对自动驾驶安全性的关注点。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>9.持续学习和社区参与</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>持续学习和社区参与</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实践项目-评估AI模型的伦理影响</title>
    <link href="/2024/06/24/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE-%E8%AF%84%E4%BC%B0AI%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%A6%E7%90%86%E5%BD%B1%E5%93%8D/"/>
    <url>/2024/06/24/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE-%E8%AF%84%E4%BC%B0AI%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%A6%E7%90%86%E5%BD%B1%E5%93%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第八部分：伦理和社会责任"><a href="#高级提示词工程师-第八部分：伦理和社会责任" class="headerlink" title="高级提示词工程师| 第八部分：伦理和社会责任"></a>高级提示词工程师| 第八部分：伦理和社会责任</h1><h2 id="第四节：实践项目"><a href="#第四节：实践项目" class="headerlink" title="| 第四节：实践项目"></a>| 第四节：实践项目</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>在本节的实践项目中，我们将通过评估一个AI模型的伦理影响来应用前面章节学到的知识。</p><ul><li><strong>评估流程</strong>：定义评估AI模型伦理影响的流程，包括数据审查、算法分析和结果评估。</li><li><strong>改进方案</strong>：基于评估结果，提出改进模型伦理性的方案。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设我们正在评估一个用于招聘的AI模型</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate_model_ethics</span>(<span class="hljs-params">model, data, sensitive_attributes</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    评估AI模型的伦理影响，包括偏见和公平性。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    predictions = model.predict(data)<br>    true_labels = [record[<span class="hljs-string">&#x27;label&#x27;</span>] <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> data]<br>    bias_rate = check_bias(predictions, true_labels, sensitive_attributes)<br>    <br>    <span class="hljs-comment"># 评估结果</span><br>    <span class="hljs-keyword">if</span> bias_rate &gt; acceptable_bias_threshold:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Model may have bias issues&quot;</span>, bias_rate<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Model is fair&quot;</span>, bias_rate<br><br><span class="hljs-comment"># 已知模型、数据和敏感属性</span><br>model_ethics, bias_rate = evaluate_model_ethics(ai_model, dataset, sensitive_attributes)<br><span class="hljs-built_in">print</span>(model_ethics)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Bias Rate: <span class="hljs-subst">&#123;bias_rate:<span class="hljs-number">.2</span>%&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个用于评估招聘简历的AI模型项目中，我们发现模型倾向于选择具有某些特定教育背景的候选人。通过评估模型的伦理影响，我们提出了改进方案，包括重新平衡数据集和调整算法权重。</p><h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h3><p>选择一个AI模型，评估其伦理影响，并提出改进方案。考虑数据收集、模型训练和结果应用的全过程。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>8.伦理和社会责任</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>伦理和社会责任</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法偏见和公平性</title>
    <link href="/2024/06/24/%E7%AE%97%E6%B3%95%E5%81%8F%E8%A7%81%E5%92%8C%E5%85%AC%E5%B9%B3%E6%80%A7/"/>
    <url>/2024/06/24/%E7%AE%97%E6%B3%95%E5%81%8F%E8%A7%81%E5%92%8C%E5%85%AC%E5%B9%B3%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第八部分：伦理和社会责任"><a href="#高级提示词工程师-第八部分：伦理和社会责任" class="headerlink" title="高级提示词工程师| 第八部分：伦理和社会责任"></a>高级提示词工程师| 第八部分：伦理和社会责任</h1><h2 id="第三节：算法偏见和公平性"><a href="#第三节：算法偏见和公平性" class="headerlink" title="| 第三节：算法偏见和公平性"></a>| 第三节：算法偏见和公平性</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>算法偏见和公平性是AI伦理中的一个核心议题，就像天平的两端，我们需要努力保持平衡，确保AI的决策对所有人都是公正的。</p><ul><li><strong>偏见识别</strong>：识别并理解数据和算法中可能存在的偏见来源。</li><li><strong>公平性设计</strong>：在算法设计中采取措施减少偏见，提高公平性。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设我们正在分析一个AI模型的预测结果，检查是否存在偏见</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_bias</span>(<span class="hljs-params">predictions, true_labels, sensitive_attribute</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    检查模型预测中是否存在与某个敏感属性相关的偏见。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    bias_count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> pred, true, sensitive <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(predictions, true_labels, sensitive_attribute):<br>        <span class="hljs-keyword">if</span> pred != true <span class="hljs-keyword">and</span> sensitive == <span class="hljs-string">&#x27;disadvantaged_group&#x27;</span>:<br>            bias_count += <span class="hljs-number">1</span><br>    <br>    total_count = <span class="hljs-built_in">len</span>([s <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> sensitive_attribute <span class="hljs-keyword">if</span> s == <span class="hljs-string">&#x27;disadvantaged_group&#x27;</span>])<br>    bias_rate = bias_count / total_count<br>    <span class="hljs-keyword">return</span> bias_rate<br><br><span class="hljs-comment"># 假设predictions, true_labels, 和sensitive_attribute是已知的</span><br>bias_rate = check_bias(predictions, true_labels, sensitive_attribute)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Bias Rate: <span class="hljs-subst">&#123;bias_rate:<span class="hljs-number">.2</span>%&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>2016年，有研究指出某些面部识别软件在识别不同肤色的人时存在显著的准确率差异。这一发现引发了对算法偏见和公平性的广泛关注。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>8.伦理和社会责任</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>伦理和社会责任</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据隐私和安全</title>
    <link href="/2024/06/24/%E6%95%B0%E6%8D%AE%E9%9A%90%E7%A7%81%E5%92%8C%E5%AE%89%E5%85%A8/"/>
    <url>/2024/06/24/%E6%95%B0%E6%8D%AE%E9%9A%90%E7%A7%81%E5%92%8C%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第八部分：伦理和社会责任"><a href="#高级提示词工程师-第八部分：伦理和社会责任" class="headerlink" title="高级提示词工程师| 第八部分：伦理和社会责任"></a>高级提示词工程师| 第八部分：伦理和社会责任</h1><h2 id="第二节：数据隐私和安全"><a href="#第二节：数据隐私和安全" class="headerlink" title="| 第二节：数据隐私和安全"></a>| 第二节：数据隐私和安全</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>数据隐私和安全是AI应用的基石，就像房屋的地基一样，如果地基不稳固，无论房屋多么华丽，都经不起风雨的考验。</p><ul><li><strong>数据最小化</strong>：只收集完成任务所必需的数据。</li><li><strong>数据加密</strong>：使用加密技术保护数据不被未授权访问。</li><li><strong>访问控制</strong>：确保只有授权人员才能访问数据。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设我们正在处理用户数据，需要确保数据的安全性</span><br><br><span class="hljs-keyword">import</span> hashlib<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">secure_data</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    使用哈希函数加密数据，确保数据的安全性。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 使用SHA-256哈希函数加密数据</span><br>    hash_object = hashlib.sha256(data.encode())<br>    hex_dig = hash_object.hexdigest()<br>    <span class="hljs-keyword">return</span> hex_dig<br><br><span class="hljs-comment"># 存储用户信息的示例</span><br>user_data = &#123;<br>    <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;user123&quot;</span>,<br>    <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;plain_text_password&quot;</span>  <span class="hljs-comment"># 应避免以明文存储密码</span><br>&#125;<br><br><span class="hljs-comment"># 加密密码</span><br>encrypted_password = secure_data(user_data[<span class="hljs-string">&quot;password&quot;</span>])<br>user_data[<span class="hljs-string">&quot;password&quot;</span>] = encrypted_password<br><br><span class="hljs-comment"># 现在用户数据更加安全</span><br><span class="hljs-built_in">print</span>(user_data)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>2017年，Equifax数据泄露事件导致超过1.47亿人的个人信息被曝光。这一事件凸显了数据安全的重要性以及保护用户数据的责任。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>8.伦理和社会责任</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>伦理和社会责任</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI伦理原则</title>
    <link href="/2024/06/24/AI%E4%BC%A6%E7%90%86%E5%8E%9F%E5%88%99/"/>
    <url>/2024/06/24/AI%E4%BC%A6%E7%90%86%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第八部分：伦理和社会责任"><a href="#高级提示词工程师-第八部分：伦理和社会责任" class="headerlink" title="高级提示词工程师| 第八部分：伦理和社会责任"></a>高级提示词工程师| 第八部分：伦理和社会责任</h1><h2 id="第一节：AI伦理原则"><a href="#第一节：AI伦理原则" class="headerlink" title="| 第一节：AI伦理原则"></a>| 第一节：AI伦理原则</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>AI伦理原则就像是航海中的指南针，为我们在开发和应用人工智能时提供了方向和约束，确保我们的旅程不偏离道德和法律的航线。</p><ul><li><strong>尊重个体</strong>：AI系统应当尊重每个人的隐私、权利和尊严。</li><li><strong>透明度</strong>：AI的决策过程应该是可解释和可理解的，用户应该知道数据如何被使用。</li><li><strong>责任归属</strong>：开发者和使用者应对AI系统的行为负责。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设我们正在开发一个用于评估信贷申请的AI模型</span><br><span class="hljs-comment"># 我们需要确保模型不会因性别、种族等因素产生偏见</span><br><br><span class="hljs-comment"># 伪代码：评估信贷申请的示例</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate_loan_application</span>(<span class="hljs-params">application</span>):<br>    <span class="hljs-comment"># 检查申请者信用记录</span><br>    credit_history = check_credit_history(application)<br>    <span class="hljs-comment"># 检查申请者收入和债务比例</span><br>    debt_to_income_ratio = calculate_debt_to_income_ratio(application)<br>    <br>    <span class="hljs-comment"># 确保模型没有使用性别等敏感特征</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;gender&#x27;</span> <span class="hljs-keyword">in</span> application:<br>        application.pop(<span class="hljs-string">&#x27;gender&#x27;</span>)  <span class="hljs-comment"># 移除性别信息</span><br><br>    <span class="hljs-comment"># 根据信用记录和收入-债务比例评估申请</span><br>    <span class="hljs-keyword">if</span> credit_history.is_clean <span class="hljs-keyword">and</span> debt_to_income_ratio.is_acceptable:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Approve&quot;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Decline&quot;</span><br><br><span class="hljs-comment"># 检查信用记录的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_credit_history</span>(<span class="hljs-params">application</span>):<br>    <span class="hljs-comment"># 逻辑来检查信用记录</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 计算收入-债务比例的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_debt_to_income_ratio</span>(<span class="hljs-params">application</span>):<br>    <span class="hljs-comment"># 逻辑来计算收入-债务比例</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在2018年，有报道指出某公司的招聘算法存在性别偏见，倾向于男性候选人。这一事件凸显了在AI应用中考虑伦理原则的重要性。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>8.伦理和社会责任</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>伦理和社会责任</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实践项目-设计跨领域AI系统的高级提示词</title>
    <link href="/2024/06/24/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE-%E8%AE%BE%E8%AE%A1%E8%B7%A8%E9%A2%86%E5%9F%9FAI%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8F%90%E7%A4%BA%E8%AF%8D/"/>
    <url>/2024/06/24/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE-%E8%AE%BE%E8%AE%A1%E8%B7%A8%E9%A2%86%E5%9F%9FAI%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8F%90%E7%A4%BA%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第七部分：高级提示词工程"><a href="#高级提示词工程师-第七部分：高级提示词工程" class="headerlink" title="高级提示词工程师| 第七部分：高级提示词工程"></a>高级提示词工程师| 第七部分：高级提示词工程</h1><h2 id="第四节：实践项目"><a href="#第四节：实践项目" class="headerlink" title="| 第四节：实践项目"></a>| 第四节：实践项目</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>在本节的实践项目中，我们将综合运用前面章节学到的知识，设计一个能够处理多种任务的跨领域AI系统，并使用高级提示词技术来提升其性能。</p><ul><li><strong>系统设计</strong>：设计一个能够理解并执行多种任务的AI系统架构。</li><li><strong>提示词集成</strong>：将高级提示词技术集成到系统中，确保系统能够根据不同的任务自动选择合适的提示词。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设我们有一个基础的AI系统框架</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AISystem</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.prompts = &#123;<br>            <span class="hljs-string">&quot;medical_diagnosis&quot;</span>: <span class="hljs-string">&quot;根据以下症状描述，请提供可能的疾病诊断。&quot;</span>,<br>            <span class="hljs-string">&quot;finance_forecast&quot;</span>: <span class="hljs-string">&quot;请根据当前市场数据预测未来的股票走势。&quot;</span>,<br>            <span class="hljs-comment"># 其他领域和任务的提示词</span><br>        &#125;<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_prompt</span>(<span class="hljs-params">self, domain, task_type</span>):<br>        <span class="hljs-comment"># 获取对应领域的任务提示词</span><br>        prompt_key = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;domain&#125;</span>_<span class="hljs-subst">&#123;task_type&#125;</span>&quot;</span><br>        <span class="hljs-keyword">return</span> self.prompts.get(prompt_key, <span class="hljs-string">&quot;这是一个默认的提示词。&quot;</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">perform_task</span>(<span class="hljs-params">self, domain, task_type, data</span>):<br>        <span class="hljs-comment"># 执行特定领域的特定任务</span><br>        prompt = self.get_prompt(domain, task_type)<br>        <span class="hljs-built_in">print</span>(prompt)  <span class="hljs-comment"># 显示提示词</span><br>        <span class="hljs-comment"># 任务执行逻辑</span><br>        <span class="hljs-comment"># ...</span><br><br><span class="hljs-comment"># 创建AI系统实例</span><br>ai_system = AISystem()<br><br><span class="hljs-comment"># 在医疗领域执行诊断任务</span><br>ai_system.perform_task(<span class="hljs-string">&quot;medical&quot;</span>, <span class="hljs-string">&quot;diagnosis&quot;</span>, <span class="hljs-string">&quot;患者症状数据&quot;</span>)<br><br><span class="hljs-comment"># 在金融领域执行预测任务</span><br>ai_system.perform_task(<span class="hljs-string">&quot;finance&quot;</span>, <span class="hljs-string">&quot;forecast&quot;</span>, <span class="hljs-string">&quot;市场数据&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个智能助手项目中，我们设计了一个能够处理医疗咨询和金融分析等任务的跨领域AI系统。通过集成高级提示词技术，系统能够根据用户的查询自动选择最合适的提示词，并提供更加精准的回答。</p><h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h3><p>选择一个您感兴趣的领域和任务，为AI系统设计一套高级提示词，并在一些示例数据上测试它们的效果。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>7.高级提示词工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨领域提示词设计</title>
    <link href="/2024/06/24/%E8%B7%A8%E9%A2%86%E5%9F%9F%E6%8F%90%E7%A4%BA%E8%AF%8D%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/06/24/%E8%B7%A8%E9%A2%86%E5%9F%9F%E6%8F%90%E7%A4%BA%E8%AF%8D%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第七部分：高级提示词工程"><a href="#高级提示词工程师-第七部分：高级提示词工程" class="headerlink" title="高级提示词工程师| 第七部分：高级提示词工程"></a>高级提示词工程师| 第七部分：高级提示词工程</h1><h2 id="第三节：跨领域提示词设计"><a href="#第三节：跨领域提示词设计" class="headerlink" title="| 第三节：跨领域提示词设计"></a>| 第三节：跨领域提示词设计</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>跨领域提示词设计就像是编写一部能够跨越不同文化和语言的通用词典，它需要我们理解不同领域间的共性和差异，以创造出能够广泛应用于多种任务的提示词。</p><ul><li><strong>共性挖掘</strong>：在不同领域之间寻找共通点，设计能够适用于多个领域的提示词。</li><li><strong>差异适应</strong>：针对每个领域的独特性调整提示词，以确保其有效性。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设计一个跨领域的提示词生成器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_prompt</span>(<span class="hljs-params">domain, task_type</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    根据领域和任务类型生成相应的提示词。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> domain == <span class="hljs-string">&quot;medical&quot;</span> <span class="hljs-keyword">and</span> task_type == <span class="hljs-string">&quot;diagnosis&quot;</span>:<br>        prompt = <span class="hljs-string">&quot;根据以下症状描述，请提供可能的疾病诊断。&quot;</span><br>    <span class="hljs-keyword">elif</span> domain == <span class="hljs-string">&quot;finance&quot;</span> <span class="hljs-keyword">and</span> task_type == <span class="hljs-string">&quot;forecast&quot;</span>:<br>        prompt = <span class="hljs-string">&quot;请根据当前市场数据预测未来的股票走势。&quot;</span><br>    <span class="hljs-keyword">else</span>:<br>        prompt = <span class="hljs-string">&quot;这是一个通用的提示词，适用于多种领域和任务。&quot;</span><br><br>    <span class="hljs-keyword">return</span> prompt<br><br><span class="hljs-comment"># 示例：生成医疗领域的诊断任务提示词</span><br>medical_prompt = generate_prompt(<span class="hljs-string">&quot;medical&quot;</span>, <span class="hljs-string">&quot;diagnosis&quot;</span>)<br><span class="hljs-built_in">print</span>(medical_prompt)<br><br><span class="hljs-comment"># 示例：生成金融领域的预测任务提示词</span><br>finance_prompt = generate_prompt(<span class="hljs-string">&quot;finance&quot;</span>, <span class="hljs-string">&quot;forecast&quot;</span>)<br><span class="hljs-built_in">print</span>(finance_prompt)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个多领域问答系统中，我们设计了一套跨领域的提示词，以帮助模型更好地理解用户的问题并提供准确的答案。这些提示词在医疗、金融、法律等多个领域都表现出了良好的适应性。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>7.高级提示词工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习中的提示词应用</title>
    <link href="/2024/06/22/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%BA%94%E7%94%A8/"/>
    <url>/2024/06/22/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第七部分：高级提示词工程"><a href="#高级提示词工程师-第七部分：高级提示词工程" class="headerlink" title="高级提示词工程师| 第七部分：高级提示词工程"></a>高级提示词工程师| 第七部分：高级提示词工程</h1><h2 id="第二节：强化学习中的提示词应用"><a href="#第二节：强化学习中的提示词应用" class="headerlink" title="| 第二节：强化学习中的提示词应用"></a>| 第二节：强化学习中的提示词应用</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>强化学习是一种让智能体通过与环境的交互来学习最优行为策略的方法。在这个过程中，提示词就像是给智能体的一张地图，帮助它在复杂的环境里找到通往目标的路径。</p><ul><li><strong>策略提示</strong>：提供给智能体关于在特定状态下应采取哪些动作的提示。</li><li><strong>奖励提示</strong>：指导智能体识别哪些行为会带来更高的回报。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> tensorflow.keras.models <span class="hljs-keyword">import</span> Sequential<br><span class="hljs-keyword">from</span> tensorflow.keras.layers <span class="hljs-keyword">import</span> Dense<br><br><span class="hljs-comment"># 假设我们正在构建一个简单的强化学习模型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Agent</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, state_size, action_size</span>):<br>        self.state_size = state_size<br>        self.action_size = action_size<br>        self.model = self._build_model()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_build_model</span>(<span class="hljs-params">self</span>):<br>        model = Sequential()<br>        model.add(Dense(<span class="hljs-number">64</span>, input_dim=self.state_size, activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>        model.add(Dense(<span class="hljs-number">32</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>        model.add(Dense(self.action_size, activation=<span class="hljs-string">&#x27;linear&#x27;</span>))<br>        <span class="hljs-keyword">return</span> model<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">act</span>(<span class="hljs-params">self, state</span>):<br>        <span class="hljs-keyword">if</span> np.random.rand() &lt;= <span class="hljs-number">0.1</span>:  <span class="hljs-comment"># 探索</span><br>            <span class="hljs-keyword">return</span> np.random.choice(self.action_size)<br>        act_values = self.model.predict(state)<br>        <span class="hljs-keyword">return</span> np.argmax(act_values[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 利用</span><br><br><span class="hljs-comment"># 环境状态和智能体</span><br>state_size = <span class="hljs-number">4</span>  <span class="hljs-comment"># 假设状态空间的大小为4</span><br>action_size = <span class="hljs-number">2</span>  <span class="hljs-comment"># 假设动作空间的大小为2</span><br>agent = Agent(state_size, action_size)<br><br><span class="hljs-comment"># 智能体与环境交互的示例</span><br>state = np.reshape([<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.4</span>], [<span class="hljs-number">1</span>, state_size])<br>action = agent.act(state)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在自动驾驶研究中，强化学习被用来训练智能体进行路径规划。通过设计合适的提示词，智能体能够学习在复杂的交通环境中做出最优决策。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>7.高级提示词工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多模态学习与提示词</title>
    <link href="/2024/06/22/%E5%A4%9A%E6%A8%A1%E6%80%81%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8F%90%E7%A4%BA%E8%AF%8D/"/>
    <url>/2024/06/22/%E5%A4%9A%E6%A8%A1%E6%80%81%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8F%90%E7%A4%BA%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第七部分：高级提示词工程"><a href="#高级提示词工程师-第七部分：高级提示词工程" class="headerlink" title="高级提示词工程师| 第七部分：高级提示词工程"></a>高级提示词工程师| 第七部分：高级提示词工程</h1><h2 id="第一节：多模态学习与提示词"><a href="#第一节：多模态学习与提示词" class="headerlink" title="| 第一节：多模态学习与提示词"></a>| 第一节：多模态学习与提示词</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>多模态学习就像是在一场音乐会中，不同的乐器协同演奏，创造出比单一乐器更加丰富和动人的音乐。在人工智能中，多模态学习结合了来自不同数据源的信息，如文本、图像、声音等，以获得更深入的理解。</p><ul><li><strong>多模态融合</strong>：将不同模态的数据融合在一起，以提供更全面的提示词，这有助于模型更好地理解复杂的场景。</li><li><strong>同步与异步融合</strong>：同步融合指的是在模型的同一阶段处理所有模态的数据；异步融合则是在不同的阶段分别处理。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tensorflow.keras.layers <span class="hljs-keyword">import</span> Input, Dense, Concatenate<br><span class="hljs-keyword">from</span> tensorflow.keras.models <span class="hljs-keyword">import</span> Model<br><br><span class="hljs-comment"># 假设我们有图像和文本两种模态的输入</span><br>image_input = Input(shape=(<span class="hljs-number">224</span>, <span class="hljs-number">224</span>, <span class="hljs-number">3</span>))<br>text_input = Input(shape=(<span class="hljs-number">100</span>,))<br><br><span class="hljs-comment"># 图像模态的处理流程</span><br>image_branch = Conv2D(<span class="hljs-number">64</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>)(image_input)<br>image_branch = MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))(image_branch)<br>image_branch = Flatten()(image_branch)<br><br><span class="hljs-comment"># 文本模态的处理流程</span><br>text_branch = Embedding(input_dim=<span class="hljs-number">10000</span>, output_dim=<span class="hljs-number">100</span>)(text_input)<br>text_branch = LSTM(<span class="hljs-number">64</span>)(text_branch)<br><br><span class="hljs-comment"># 融合两个模态的特征</span><br>combined = Concatenate()([image_branch, text_branch])<br><br><span class="hljs-comment"># 输出层</span><br>output = Dense(<span class="hljs-number">1</span>, activation=<span class="hljs-string">&#x27;sigmoid&#x27;</span>)(combined)<br><br><span class="hljs-comment"># 创建模型</span><br>model = Model(inputs=[image_input, text_input], outputs=output)<br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>, loss=<span class="hljs-string">&#x27;binary_crossentropy&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个视频内容理解的项目中，我们结合了视频的视觉信息和音频信息。通过设计能够同时处理图像和声音的提示词，我们的模型能够更准确地识别视频中的活动和事件。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>7.高级提示词工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实践项目-设计并测试特定任务的提示词</title>
    <link href="/2024/06/22/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE-%E8%AE%BE%E8%AE%A1%E5%B9%B6%E6%B5%8B%E8%AF%95%E7%89%B9%E5%AE%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%8F%90%E7%A4%BA%E8%AF%8D/"/>
    <url>/2024/06/22/%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE-%E8%AE%BE%E8%AE%A1%E5%B9%B6%E6%B5%8B%E8%AF%95%E7%89%B9%E5%AE%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%8F%90%E7%A4%BA%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第六部分：提示词工程基础"><a href="#高级提示词工程师-第六部分：提示词工程基础" class="headerlink" title="高级提示词工程师| 第六部分：提示词工程基础"></a>高级提示词工程师| 第六部分：提示词工程基础</h1><h2 id="第四节：设计并测试特定任务的提示词"><a href="#第四节：设计并测试特定任务的提示词" class="headerlink" title="| 第四节：设计并测试特定任务的提示词"></a>| 第四节：设计并测试特定任务的提示词</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>在本节的实践项目中，我们将通过设计和测试针对特定任务的提示词来应用前面章节学到的知识。</p><ul><li><strong>任务定义</strong>：明确你要解决的问题或要完成的任务，这是设计提示词的第一步。</li><li><strong>提示词设计</strong>：根据任务的需求设计提示词，考虑如何最有效地引导模型。</li><li><strong>测试与评估</strong>：在实际数据上测试提示词的效果，并根据结果进行调整和优化。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设计一个用于文本分类任务的提示词</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">design_prompt_for_classification</span>(<span class="hljs-params">task, data</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    为特定文本分类任务设计提示词。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 根据任务类型设计提示词</span><br>    <span class="hljs-keyword">if</span> task == <span class="hljs-string">&quot;spam_detection&quot;</span>:<br>        prompt = <span class="hljs-string">&quot;请判断以下文本是否为垃圾邮件：&quot;</span><br>    <span class="hljs-keyword">elif</span> task == <span class="hljs-string">&quot;sentiment_analysis&quot;</span>:<br>        prompt = <span class="hljs-string">&quot;请分析以下文本的情感倾向：&quot;</span><br>    <span class="hljs-keyword">else</span>:<br>        prompt = <span class="hljs-string">&quot;未知任务类型&quot;</span><br>    <br>    <span class="hljs-comment"># 测试提示词</span><br>    <span class="hljs-keyword">for</span> text <span class="hljs-keyword">in</span> data:<br>        <span class="hljs-built_in">print</span>(prompt, text)<br><br><span class="hljs-comment"># 假设数据集</span><br>data = [<br>    <span class="hljs-string">&quot;买一送一，限时优惠！&quot;</span>,<br>    <span class="hljs-string">&quot;今天的天气真好。&quot;</span>,<br>    <span class="hljs-string">&quot;紧急：您的账户存在安全风险，请立即查看。&quot;</span><br>]<br><br><span class="hljs-comment"># 设计并测试针对垃圾邮件检测任务的提示词</span><br>design_prompt_for_classification(<span class="hljs-string">&quot;spam_detection&quot;</span>, data)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个垃圾邮件检测项目中，我们设计了专门的提示词来引导模型识别垃圾邮件。通过在实际邮件数据上测试这些提示词，我们发现模型的识别准确率有了显著提升。</p><h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h3><p>尝试为你感兴趣的AI任务设计一套提示词，并在一些示例数据上测试它们的效果。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>6.提示词工程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>提示词工程基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>提示词在AI应用中的作用</title>
    <link href="/2024/06/22/%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%9C%A8AI%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2024/06/22/%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%9C%A8AI%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第六部分：提示词工程基础"><a href="#高级提示词工程师-第六部分：提示词工程基础" class="headerlink" title="高级提示词工程师| 第六部分：提示词工程基础"></a>高级提示词工程师| 第六部分：提示词工程基础</h1><h2 id="第三节：提示词在AI应用中的作用"><a href="#第三节：提示词在AI应用中的作用" class="headerlink" title="| 第三节：提示词在AI应用中的作用"></a>| 第三节：提示词在AI应用中的作用</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>提示词在AI应用中的作用就像是调味料在烹饪中的作用，适量的调味料可以让菜肴更加美味，而恰当的提示词可以让AI模型表现得更加出色。</p><ul><li><strong>引导模型理解</strong>：在自然语言处理任务中，提示词可以帮助模型更好地理解用户的意图和上下文。</li><li><strong>提高准确性</strong>：在分类或预测任务中，合适的提示词可以提高模型的准确性。</li><li><strong>增强交互体验</strong>：在对话系统或推荐系统中，提示词可以增强用户的交互体验。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设计针对推荐系统的提示词</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_recommendation_prompt</span>(<span class="hljs-params">user_profile, item</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    根据用户画像和推荐物品生成个性化的提示词。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    prompt = <span class="hljs-string">f&quot;根据您的兴趣<span class="hljs-subst">&#123;user_profile[<span class="hljs-string">&#x27;interests&#x27;</span>]&#125;</span>，我们为您推荐<span class="hljs-subst">&#123;item&#125;</span>。&quot;</span><br>    <span class="hljs-keyword">return</span> prompt<br><br><span class="hljs-comment"># 假设用户画像和推荐物品</span><br>user_profile = &#123;<span class="hljs-string">&quot;interests&quot;</span>: <span class="hljs-string">&quot;科幻电影&quot;</span>&#125;<br>item = <span class="hljs-string">&quot;《星际穿越》&quot;</span><br><br><span class="hljs-comment"># 生成推荐提示词</span><br><span class="hljs-built_in">print</span>(generate_recommendation_prompt(user_profile, item))<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个电影推荐系统项目中，我们利用提示词来增强推荐的相关性和吸引力。通过对用户的历史偏好和当前推荐内容的分析，系统生成了个性化的提示词，从而提高了用户对推荐内容的点击率和满意度。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>6.提示词工程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>提示词工程基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计有效的提示词</title>
    <link href="/2024/06/22/%E8%AE%BE%E8%AE%A1%E6%9C%89%E6%95%88%E7%9A%84%E6%8F%90%E7%A4%BA%E8%AF%8D/"/>
    <url>/2024/06/22/%E8%AE%BE%E8%AE%A1%E6%9C%89%E6%95%88%E7%9A%84%E6%8F%90%E7%A4%BA%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第六部分：提示词工程基础"><a href="#高级提示词工程师-第六部分：提示词工程基础" class="headerlink" title="高级提示词工程师| 第六部分：提示词工程基础"></a>高级提示词工程师| 第六部分：提示词工程基础</h1><h2 id="第二节：设计有效的提示词"><a href="#第二节：设计有效的提示词" class="headerlink" title="| 第二节：设计有效的提示词"></a>| 第二节：设计有效的提示词</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>设计有效的提示词是一门艺术，也是一门科学。它需要我们深入了解模型的能力，以及如何通过语言来激发这些能力。</p><ul><li><strong>明确性</strong>：提示词应该清晰明确，直接指向所需的任务或信息。</li><li><strong>相关性</strong>：提示词应该与任务或数据紧密相关，避免引入无关的信息。</li><li><strong>引导性</strong>：好的提示词能够引导模型沿着正确的方向思考，就像向导引领旅行者一样。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设计针对情感分析任务的提示词</span><br>prompts = &#123;<br>    <span class="hljs-string">&quot;positive&quot;</span>: <span class="hljs-string">&quot;请分析以下文本的情感倾向，并指出它是积极的。&quot;</span>,<br>    <span class="hljs-string">&quot;negative&quot;</span>: <span class="hljs-string">&quot;请分析以下文本的情感倾向，并指出它是消极的。&quot;</span>,<br>    <span class="hljs-string">&quot;neutral&quot;</span>: <span class="hljs-string">&quot;请分析以下文本的情感倾向，并指出它是中性的。&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 模拟情感分析任务</span><br>text = <span class="hljs-string">&quot;这部电影的视觉效果令人惊叹。&quot;</span><br>emotion = <span class="hljs-string">&quot;positive&quot;</span>  <span class="hljs-comment"># 假设已知的情感倾向</span><br><br><span class="hljs-comment"># 使用相应的提示词</span><br><span class="hljs-built_in">print</span>(prompts[emotion], text)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个社交媒体监控项目中，我们设计了一套提示词来帮助模型识别和分类用户的情感表达。通过精心设计的提示词，模型能够更准确地判断文本的情感倾向，从而提供更有针对性的反馈。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>6.提示词工程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>提示词工程基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>提示词的定义与分类</title>
    <link href="/2024/06/22/%E6%8F%90%E7%A4%BA%E8%AF%8D%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%86%E7%B1%BB/"/>
    <url>/2024/06/22/%E6%8F%90%E7%A4%BA%E8%AF%8D%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第六部分：提示词工程基础"><a href="#高级提示词工程师-第六部分：提示词工程基础" class="headerlink" title="高级提示词工程师| 第六部分：提示词工程基础"></a>高级提示词工程师| 第六部分：提示词工程基础</h1><h2 id="第一节：提示词的定义与分类"><a href="#第一节：提示词的定义与分类" class="headerlink" title="| 第一节：提示词的定义与分类"></a>| 第一节：提示词的定义与分类</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>在人工智能的世界里，提示词就像是一把钥匙，能够解锁模型的潜能，让它们更好地理解和执行任务。</p><ul><li><strong>提示词的定义</strong>：提示词是提供给模型的一系列信息，用以指导模型完成特定任务的输入。</li><li><strong>分类</strong>：提示词可以根据其功能和应用场景被分为不同的类型，如引导性提示词、限制性提示词和探索性提示词。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设我们正在设计一个聊天机器人的提示词</span><br>prompts = [<br>    <span class="hljs-string">&quot;你好，我可以帮助您解决什么问题？&quot;</span>,<br>    <span class="hljs-string">&quot;请告诉我您的需求，我会尽力提供帮助。&quot;</span>,<br>    <span class="hljs-string">&quot;您需要关于哪个主题的信息？&quot;</span><br>]<br><br><span class="hljs-comment"># 根据用户输入选择相应的提示词</span><br>user_input = <span class="hljs-string">&quot;我想知道关于健康饮食的信息。&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;问题&quot;</span> <span class="hljs-keyword">in</span> user_input:<br>    response = prompts[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">elif</span> <span class="hljs-string">&quot;需求&quot;</span> <span class="hljs-keyword">in</span> user_input:<br>    response = prompts[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">else</span>:<br>    response = prompts[<span class="hljs-number">2</span>]<br><br><span class="hljs-built_in">print</span>(response)  <span class="hljs-comment"># 输出选择的提示词</span><br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个客户服务机器人的项目中，我们设计了一系列的提示词来引导用户表达他们的需求。这些提示词帮助机器人更准确地理解用户的意图，并提供相应的服务。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>6.提示词工程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>提示词工程基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建和评估深度学习模型</title>
    <link href="/2024/06/22/%E6%9E%84%E5%BB%BA%E5%92%8C%E8%AF%84%E4%BC%B0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/06/22/%E6%9E%84%E5%BB%BA%E5%92%8C%E8%AF%84%E4%BC%B0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第五部分：深度学习模型构建"><a href="#高级提示词工程师-第五部分：深度学习模型构建" class="headerlink" title="高级提示词工程师| 第五部分：深度学习模型构建"></a>高级提示词工程师| 第五部分：深度学习模型构建</h1><h2 id="第四节：构建和评估深度学习模型"><a href="#第四节：构建和评估深度学习模型" class="headerlink" title="| 第四节：构建和评估深度学习模型"></a>| 第四节：构建和评估深度学习模型</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>构建深度学习模型就像是打造一把钥匙，目的是打开数据的宝库，解锁其中的知识和智慧。</p><ul><li><strong>构建模型</strong>：在深度学习中，构建模型通常意味着选择正确的架构，例如CNN、RNN或GAN，并设置适当的超参数。</li><li><strong>训练模型</strong>：训练模型是一个迭代过程，模型在训练数据上学习，并通过反向传播算法调整权重。</li><li><strong>评估模型</strong>：评估模型性能是理解模型效果的关键。通常使用验证集或测试集来评估模型的准确性、损失和其他指标。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tensorflow.keras.callbacks <span class="hljs-keyword">import</span> EarlyStopping<br><br><span class="hljs-comment"># 假设我们有一个构建好的模型实例 `model`</span><br><br><span class="hljs-comment"># 准备训练数据和标签</span><br>X_train, y_train = ...  <span class="hljs-comment"># 训练数据和标签</span><br>X_val, y_val = ...      <span class="hljs-comment"># 验证数据和标签</span><br><br><span class="hljs-comment"># 定义早期停止的回调函数，以避免过拟合</span><br>early_stopping = EarlyStopping(monitor=<span class="hljs-string">&#x27;val_loss&#x27;</span>, patience=<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 训练模型，并在每个epoch后评估验证集</span><br>history = model.fit(X_train, y_train, epochs=<span class="hljs-number">50</span>, validation_data=(X_val, y_val), callbacks=[early_stopping])<br><br><span class="hljs-comment"># 评估模型在测试集上的性能</span><br>X_test, y_test = ...  <span class="hljs-comment"># 测试数据和标签</span><br>test_loss, test_accuracy = model.evaluate(X_test, y_test)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Test Accuracy: <span class="hljs-subst">&#123;test_accuracy:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个医学图像分析项目中，我们使用深度学习来自动检测CT扫描中的肿瘤。我们构建了一个基于CNN的模型，该模型在大量医学图像上进行了预训练。</p><p>在训练过程中，我们使用了早期停止技术来监控验证集上的损失，避免模型过拟合。我们还调整了学习率和其他超参数，以优化训练过程。</p><p>最终，我们的模型在测试集上达到了90%以上的准确率，显著提高了肿瘤检测的效率和准确性。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>5.深度学习模型构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>深度学习模型构建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迁移学习和微调的力量</title>
    <link href="/2024/06/22/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%BE%AE%E8%B0%83%E7%9A%84%E5%8A%9B%E9%87%8F/"/>
    <url>/2024/06/22/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%BE%AE%E8%B0%83%E7%9A%84%E5%8A%9B%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第五部分：深度学习模型构建"><a href="#高级提示词工程师-第五部分：深度学习模型构建" class="headerlink" title="高级提示词工程师| 第五部分：深度学习模型构建"></a>高级提示词工程师| 第五部分：深度学习模型构建</h1><h2 id="第三节：迁移学习和微调的力量"><a href="#第三节：迁移学习和微调的力量" class="headerlink" title="| 第三节：迁移学习和微调的力量"></a>| 第三节：迁移学习和微调的力量</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>迁移学习就像是站在巨人的肩膀上，我们可以利用在大型数据集上预训练的模型来解决特定问题，而微调则是对这些模型进行最后的打磨，以适应我们的特定任务。</p><ul><li><strong>迁移学习</strong>：迁移学习允许我们将一个在大型数据集（如ImageNet）上训练好的模型应用到新的、相关的任务上，这可以显著减少所需的训练时间和数据量。</li><li><strong>微调</strong>：在迁移学习的基础上，微调是指对预训练模型的某些层进行进一步的训练，以更好地适应新任务。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tensorflow.keras.applications <span class="hljs-keyword">import</span> VGG16<br><span class="hljs-keyword">from</span> tensorflow.keras.layers <span class="hljs-keyword">import</span> Flatten, Dense<br><span class="hljs-keyword">from</span> tensorflow.keras.models <span class="hljs-keyword">import</span> Model<br><br><span class="hljs-comment"># 加载预训练的VGG16模型</span><br>base_model = VGG16(weights=<span class="hljs-string">&#x27;imagenet&#x27;</span>, include_top=<span class="hljs-literal">False</span>, input_shape=(<span class="hljs-number">224</span>, <span class="hljs-number">224</span>, <span class="hljs-number">3</span>))<br><br><span class="hljs-comment"># 冻结所有卷积层的权重</span><br><span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> base_model.layers:<br>    layer.trainable = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 添加新的层以适应新的任务</span><br>x = Flatten()(base_model.output)<br>x = Dense(<span class="hljs-number">256</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>)(x)<br>predictions = Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>)(x)<br><br><span class="hljs-comment"># 创建最终模型</span><br>model = Model(inputs=base_model.<span class="hljs-built_in">input</span>, outputs=predictions)<br><br><span class="hljs-comment"># 编译模型</span><br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>, loss=<span class="hljs-string">&#x27;categorical_crossentropy&#x27;</span>, metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在野生动物保护项目中，我们使用迁移学习来识别不同种类的动物。由于获取大量标记好的动物图像是困难的，我们采用了在ImageNet上预训练的VGG16模型作为起点。</p><p>通过对模型的最后几层进行微调，我们能够显著提高识别的准确性，同时减少了所需的训练时间。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>5.深度学习模型构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>深度学习模型构建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习中的正则化与优化</title>
    <link href="/2024/06/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <url>/2024/06/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第五部分：深度学习模型构建"><a href="#高级提示词工程师-第五部分：深度学习模型构建" class="headerlink" title="高级提示词工程师| 第五部分：深度学习模型构建"></a>高级提示词工程师| 第五部分：深度学习模型构建</h1><h2 id="第二节：深度学习中的正则化与优化"><a href="#第二节：深度学习中的正则化与优化" class="headerlink" title="| 第二节：深度学习中的正则化与优化"></a>| 第二节：深度学习中的正则化与优化</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>在深度学习中，正则化技术和优化算法就像是舵手和船帆，帮助我们在数据的海洋中稳定航行，避免陷入过拟合的漩涡。</p><ul><li><strong>正则化技术</strong>：为了防止模型在训练数据上过度拟合，我们引入了正则化项，如L1和L2正则化，它们惩罚模型权重的大值，促使模型学习到更加简单的表示。</li><li><strong>优化算法</strong>：优化算法，如SGD（随机梯度下降）、Adam等，是模型训练过程中用来更新权重的算法，它们决定了模型学习的方向和速度。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tensorflow.keras <span class="hljs-keyword">import</span> regularizers<br><br><span class="hljs-comment"># 添加L2正则化到模型中</span><br>model.add(layers.Dense(<span class="hljs-number">64</span>, kernel_regularizer=regularizers.l2(<span class="hljs-number">0.01</span>)))<br><br><span class="hljs-comment"># 使用Adam优化器进行模型训练</span><br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>, loss=<span class="hljs-string">&#x27;categorical_crossentropy&#x27;</span>, metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个文本分类任务中，我们使用了深度学习模型来识别新闻文章的类别。为了避免过拟合，我们在模型的隐藏层中添加了L2正则化。通过调整正则化参数，我们找到了一个平衡点，使得模型在训练集和验证集上都有良好的表现。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>5.深度学习模型构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>深度学习模型构建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习架构的探索之旅</title>
    <link href="/2024/06/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9E%B6%E6%9E%84%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B9%8B%E6%97%85/"/>
    <url>/2024/06/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9E%B6%E6%9E%84%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第五部分：深度学习模型构建"><a href="#高级提示词工程师-第五部分：深度学习模型构建" class="headerlink" title="高级提示词工程师| 第五部分：深度学习模型构建"></a>高级提示词工程师| 第五部分：深度学习模型构建</h1><h2 id="第一节：深度学习架构的探索之旅"><a href="#第一节：深度学习架构的探索之旅" class="headerlink" title="| 第一节：深度学习架构的探索之旅"></a>| 第一节：深度学习架构的探索之旅</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>深度学习架构是构建智能系统的基石，就像建筑师设计大楼的蓝图一样，我们需要选择合适的架构来解决特定的问题。</p><ul><li><strong>CNN（卷积神经网络）</strong>：CNN适用于图像识别任务，它通过卷积层捕捉图像的局部特征，然后逐层构建更为复杂和抽象的特征表示。</li><li><strong>RNN（循环神经网络）</strong>：RNN适合于处理序列数据，如时间序列分析或自然语言处理。它们能够记住之前处理的信息，并利用这些信息来预测未来的数据。</li><li><strong>GAN（生成对抗网络）</strong>：GAN由生成器和判别器组成，生成器学习生成逼真的数据，而判别器则学习区分真假数据。两者相互竞争，推动生成的数据质量不断提升。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">from</span> tensorflow.keras <span class="hljs-keyword">import</span> layers<br><br><span class="hljs-comment"># 创建一个简单的CNN模型</span><br>model = tf.keras.Sequential([<br>    layers.Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, input_shape=(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>)),<br>    layers.MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)),<br>    layers.Flatten(),<br>    layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>),<br>    layers.Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>)<br>])<br><br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>,<br>              loss=<span class="hljs-string">&#x27;sparse_categorical_crossentropy&#x27;</span>,<br>              metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在图像识别领域，CNN已经成为事实上的标准。例如，一个用于识别手写数字的CNN模型可能会从捕捉图像中的边缘开始，然后识别数字的各个部分，最终识别出整个数字。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>5.深度学习模型构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>深度学习模型构建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模型验证的科学方法</title>
    <link href="/2024/06/22/%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E7%9A%84%E7%A7%91%E5%AD%A6%E6%96%B9%E6%B3%95/"/>
    <url>/2024/06/22/%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E7%9A%84%E7%A7%91%E5%AD%A6%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第四部分：机器学习模型构建"><a href="#高级提示词工程师-第四部分：机器学习模型构建" class="headerlink" title="高级提示词工程师| 第四部分：机器学习模型构建"></a>高级提示词工程师| 第四部分：机器学习模型构建</h1><h2 id="第四节：模型验证的科学方法"><a href="#第四节：模型验证的科学方法" class="headerlink" title="| 第四节：模型验证的科学方法"></a>| 第四节：模型验证的科学方法</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>模型验证是确保我们的模型不仅仅是在训练数据上表现良好，而是能够在新的、未见过的数据上同样表现出色的关键步骤。</p><ul><li><strong>交叉验证</strong>：交叉验证是一种评估模型泛化能力的方法，它通过将数据集分成多个部分，然后让模型在多个不同的训练集和测试集上进行训练和评估。</li><li><strong>K折交叉验证</strong>：最常见的是10折交叉验证，它将数据集平均分成10份，轮流使用其中一份作为测试集，其余9份作为训练集。</li><li><strong>留一法</strong>：在留一法（Leave-One-Out Cross-Validation, LOOCV）中，每次留出一个样本作为测试集，其余所有样本作为训练集，这种方法适用于小数据集。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> cross_val_score, KFold<br><br><span class="hljs-comment"># 使用交叉验证评估模型性能</span><br>model = RandomForestClassifier(n_estimators=<span class="hljs-number">100</span>)<br>scores = cross_val_score(model, X_train, y_train, cv=<span class="hljs-number">5</span>, scoring=<span class="hljs-string">&#x27;accuracy&#x27;</span>)<br><br><span class="hljs-comment"># 计算交叉验证的平均准确率</span><br>average_accuracy = scores.mean()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Average Cross-Validated Accuracy: <span class="hljs-subst">&#123;average_accuracy:<span class="hljs-number">.2</span>f&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># 使用K折交叉验证</span><br>kf = KFold(n_splits=<span class="hljs-number">5</span>)<br><span class="hljs-keyword">for</span> train_index, test_index <span class="hljs-keyword">in</span> kf.split(X_train):<br>    X_train_fold, X_test_fold = X_train.iloc[train_index], X_train.iloc[test_index]<br>    y_train_fold, y_test_fold = y_train.iloc[train_index], y_train.iloc[test_index]<br>    <br>    model.fit(X_train_fold, y_train_fold)<br>    score = model.score(X_test_fold, y_test_fold)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Accuracy for this fold: <span class="hljs-subst">&#123;score:<span class="hljs-number">.2</span>f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个医疗诊断项目中，我们的目标是构建一个能够预测疾病发展的模型。由于数据量有限，我们采用了留一法交叉验证来评估模型的性能。</p><p>在每次迭代中，我们留出一个病人的数据作为测试集，其余所有病人的数据作为训练集。这样，每个病人的数据都有机会被用作测试，从而确保了评估的全面性。</p><p>通过这种方法，我们发现模型在不同病人的数据上表现一致，准确率稳定在85%左右。这表明我们的模型具有良好的泛化能力，能够在新的病人数据上做出准确的预测。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>4.机器学习模型构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>机器学习模型构建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模型调参的优化之旅</title>
    <link href="/2024/06/22/%E6%A8%A1%E5%9E%8B%E8%B0%83%E5%8F%82%E7%9A%84%E4%BC%98%E5%8C%96%E4%B9%8B%E6%97%85/"/>
    <url>/2024/06/22/%E6%A8%A1%E5%9E%8B%E8%B0%83%E5%8F%82%E7%9A%84%E4%BC%98%E5%8C%96%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第四部分：机器学习模型构建"><a href="#高级提示词工程师-第四部分：机器学习模型构建" class="headerlink" title="高级提示词工程师| 第四部分：机器学习模型构建"></a>高级提示词工程师| 第四部分：机器学习模型构建</h1><h2 id="第三节：模型调参的优化之旅"><a href="#第三节：模型调参的优化之旅" class="headerlink" title="| 第三节：模型调参的优化之旅"></a>| 第三节：模型调参的优化之旅</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>模型调参就像是调整乐器的音准，通过细微的调整，我们可以显著提升模型的性能。</p><ul><li><strong>超参数</strong>：超参数是模型训练前需要设置的参数，如学习率、树的深度、正则化强度等。它们对模型的性能有着决定性的影响。</li><li><strong>调参方法</strong>：包括网格搜索（Grid Search）、随机搜索（Random Search）和贝叶斯优化等。这些方法通过遍历不同的超参数组合来寻找最优解。</li><li><strong>验证方法</strong>：使用交叉验证来评估不同超参数组合的性能，确保模型的稳定性和泛化能力。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCV<br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br><br><span class="hljs-comment"># 定义超参数的候选值</span><br>param_grid = &#123;<br>    <span class="hljs-string">&#x27;n_estimators&#x27;</span>: [<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>],<br>    <span class="hljs-string">&#x27;max_depth&#x27;</span>: [<span class="hljs-literal">None</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>],<br>    <span class="hljs-string">&#x27;min_samples_split&#x27;</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>]<br>&#125;<br><br><span class="hljs-comment"># 使用网格搜索进行调参</span><br>model = RandomForestClassifier()<br>grid_search = GridSearchCV(estimator=model, param_grid=param_grid, cv=<span class="hljs-number">5</span>, scoring=<span class="hljs-string">&#x27;accuracy&#x27;</span>)<br>grid_search.fit(X_train, y_train)<br><br><span class="hljs-comment"># 输出最佳参数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Best Parameters: <span class="hljs-subst">&#123;grid_search.best_params_&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># 评估最佳模型</span><br>best_model = grid_search.best_estimator_<br>y_pred = best_model.predict(X_test)<br>accuracy = accuracy_score(y_test, y_pred)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Accuracy of Best Model: <span class="hljs-subst">&#123;accuracy:<span class="hljs-number">.2</span>f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个生物信息学项目中，我们使用机器学习模型来预测蛋白质的结构类别。起初，我们使用了一个简单的决策树模型，但是模型的性能并不理想。</p><p>为了提升模型性能，我们进行了模型调参。通过网格搜索，我们尝试了不同的树深度、分裂所需的最小样本数和树的数量。我们发现，当树的深度为20，分裂所需的最小样本数为10，树的数量为300时，模型在交叉验证中的表现最佳。</p><p>最终，我们的模型准确率提高了10%，这证明了调参在提升模型性能中的重要作用。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>4.机器学习模型构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>机器学习模型构建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>过拟合与欠拟合的平衡术</title>
    <link href="/2024/06/22/%E8%BF%87%E6%8B%9F%E5%90%88%E4%B8%8E%E6%AC%A0%E6%8B%9F%E5%90%88%E7%9A%84%E5%B9%B3%E8%A1%A1%E6%9C%AF/"/>
    <url>/2024/06/22/%E8%BF%87%E6%8B%9F%E5%90%88%E4%B8%8E%E6%AC%A0%E6%8B%9F%E5%90%88%E7%9A%84%E5%B9%B3%E8%A1%A1%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第四部分：机器学习模型构建"><a href="#高级提示词工程师-第四部分：机器学习模型构建" class="headerlink" title="高级提示词工程师| 第四部分：机器学习模型构建"></a>高级提示词工程师| 第四部分：机器学习模型构建</h1><h2 id="第二节：过拟合与欠拟合的平衡术"><a href="#第二节：过拟合与欠拟合的平衡术" class="headerlink" title="| 第二节：过拟合与欠拟合的平衡术"></a>| 第二节：过拟合与欠拟合的平衡术</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>在机器学习中，过拟合和欠拟合是两个常见的问题，它们就像烹饪时的调味问题：过拟合是调料放得太多，欠拟合则是调料放得太少。</p><ul><li><strong>过拟合</strong>：模型在训练数据上表现得很好，但在新的、未见过的数据上表现差。就像一个学生只记住了课本上的内容，却无法解决实际问题。</li><li><strong>欠拟合</strong>：模型在训练数据上表现不足，无法捕捉数据的基本趋势。就像一个学生连课本上的内容都未能掌握。</li><li><strong>解决策略</strong>：为了平衡过拟合和欠拟合，我们可以使用交叉验证、正则化、增加数据量或减少模型复杂度等方法。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> cross_val_score<br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error<br><br><span class="hljs-comment"># 使用交叉验证来评估模型</span><br>model = RandomForestClassifier(n_estimators=<span class="hljs-number">100</span>)<br>cross_val_scores = cross_val_score(model, X_train, y_train, cv=<span class="hljs-number">5</span>, scoring=<span class="hljs-string">&#x27;accuracy&#x27;</span>)<br><br><span class="hljs-comment"># 计算交叉验证的平均准确率</span><br>average_accuracy = <span class="hljs-built_in">sum</span>(cross_val_scores) / <span class="hljs-built_in">len</span>(cross_val_scores)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Average Cross-Validated Accuracy: <span class="hljs-subst">&#123;average_accuracy:<span class="hljs-number">.2</span>f&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># 使用正则化来防止过拟合</span><br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Ridge<br>model = Ridge(alpha=<span class="hljs-number">1.0</span>)  <span class="hljs-comment"># alpha是正则化参数</span><br>model.fit(X_train, y_train)<br><br><span class="hljs-comment"># 预测并评估回归模型</span><br>y_pred = model.predict(X_test)<br>rmse = mean_squared_error(y_test, y_pred, squared=<span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Root Mean Squared Error: <span class="hljs-subst">&#123;rmse:<span class="hljs-number">.2</span>f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个房价预测项目中，我们使用了线性回归模型。起初，模型在训练集上的误差很小，但在测试集上表现不佳，这表明模型过拟合了。为了解决这个问题，我们采用了L1正则化（Lasso）来减少模型复杂度，并通过交叉验证来选择最佳的正则化参数。</p><p>通过这些方法，我们提高了模型在测试集上的表现，使其更加健壮和可靠。这个案例展示了如何通过技术手段来平衡过拟合和欠拟合的问题。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>4.机器学习模型构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>机器学习模型构建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模型选择的艺术</title>
    <link href="/2024/06/22/%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <url>/2024/06/22/%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第四部分：机器学习模型构建"><a href="#高级提示词工程师-第四部分：机器学习模型构建" class="headerlink" title="高级提示词工程师| 第四部分：机器学习模型构建"></a>高级提示词工程师| 第四部分：机器学习模型构建</h1><h2 id="第一节：模型选择的艺术"><a href="#第一节：模型选择的艺术" class="headerlink" title="| 第一节：模型选择的艺术"></a>| 第一节：模型选择的艺术</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>模型选择是机器学习中的一门艺术，就像画家选择画布上的颜色一样，我们需要根据问题的性质和数据的特点来挑选合适的模型。</p><ul><li><strong>模型选择</strong>：不同的模型适用于不同类型的问题。比如，决策树适合于规则性强的数据，而神经网络则适合于复杂的非线性问题。</li><li><strong>评估指标</strong>：评估指标是我们判断模型好坏的标准。对于分类问题，我们常用准确率、召回率和F1分数；对于回归问题，则使用均方误差(MSE)或均方根误差(RMSE)。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br><br><span class="hljs-comment"># 假设我们有一个数据集data和目标变量target</span><br>X = data.drop(<span class="hljs-string">&#x27;target&#x27;</span>, axis=<span class="hljs-number">1</span>)<br>y = data[<span class="hljs-string">&#x27;target&#x27;</span>]<br><br><span class="hljs-comment"># 划分训练集和测试集</span><br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)<br><br><span class="hljs-comment"># 初始化随机森林分类器</span><br>model = RandomForestClassifier(n_estimators=<span class="hljs-number">100</span>)<br><br><span class="hljs-comment"># 训练模型</span><br>model.fit(X_train, y_train)<br><br><span class="hljs-comment"># 预测测试集</span><br>y_pred = model.predict(X_test)<br><br><span class="hljs-comment"># 评估模型</span><br>accuracy = accuracy_score(y_test, y_pred)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Model Accuracy: <span class="hljs-subst">&#123;accuracy:<span class="hljs-number">.2</span>f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个客户流失预测项目中，我们收集了客户的交易记录、服务使用情况和反馈数据。首先，我们使用随机森林分类器来训练模型，因为它不需要太多特征工程，并且对于这种具有多个特征的分类问题表现良好。</p><p>在训练过程中，我们使用了80%的数据作为训练集，剩下的20%作为测试集。模型的准确率达到了85%，这表明我们的模型在测试集上有很好的泛化能力。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>4.机器学习模型构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>机器学习模型构建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实践项目的探索之旅</title>
    <link href="/2024/06/22/%E7%AC%AC%E5%85%AD%E8%8A%82%EF%BC%9A%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B9%8B%E6%97%85/"/>
    <url>/2024/06/22/%E7%AC%AC%E5%85%AD%E8%8A%82%EF%BC%9A%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第三部分：数据处理和分析"><a href="#高级提示词工程师-第三部分：数据处理和分析" class="headerlink" title="高级提示词工程师| 第三部分：数据处理和分析"></a>高级提示词工程师| 第三部分：数据处理和分析</h1><h2 id="第六节：实践项目的探索之旅"><a href="#第六节：实践项目的探索之旅" class="headerlink" title="| 第六节：实践项目的探索之旅"></a>| 第六节：实践项目的探索之旅</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>实践项目是将所学知识综合运用的终极考验，它要求我们将数据处理和分析的各个环节融会贯通，解决实际问题。</p><ul><li><strong>项目设计</strong>：在开始之前，明确项目的目标和预期成果，就像规划一次旅行的路线图。</li><li><strong>数据探索</strong>：在项目的初期，进行深入的数据探索，了解数据的分布、异常值和潜在的关系。</li><li><strong>模型选择与训练</strong>：根据项目需求和数据特点选择合适的模型，并进行训练。</li><li><strong>结果评估与优化</strong>：评估模型的性能，并根据评估结果进行优化，以提高模型的准确性和泛化能力。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br><br><span class="hljs-comment"># 项目设计：加载数据集</span><br>data = pd.read_csv(<span class="hljs-string">&#x27;project_data.csv&#x27;</span>)<br><br><span class="hljs-comment"># 数据探索</span><br><span class="hljs-built_in">print</span>(data.describe())<br><span class="hljs-built_in">print</span>(data.isnull().<span class="hljs-built_in">sum</span>())<br><br><span class="hljs-comment"># 特征选择</span><br>selected_features = [<span class="hljs-string">&#x27;feature1&#x27;</span>, <span class="hljs-string">&#x27;feature2&#x27;</span>, <span class="hljs-string">&#x27;feature3&#x27;</span>]<br>X = data[selected_features]<br>y = data[<span class="hljs-string">&#x27;target&#x27;</span>]<br><br><span class="hljs-comment"># 划分训练集和测试集</span><br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.3</span>, random_state=<span class="hljs-number">42</span>)<br><br><span class="hljs-comment"># 模型选择与训练</span><br>model = RandomForestClassifier(n_estimators=<span class="hljs-number">100</span>, random_state=<span class="hljs-number">42</span>)<br>model.fit(X_train, y_train)<br><br><span class="hljs-comment"># 结果评估</span><br>y_pred = model.predict(X_test)<br>accuracy = accuracy_score(y_test, y_pred)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Model Accuracy: <span class="hljs-subst">&#123;accuracy:<span class="hljs-number">.2</span>f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个客户流失预测的项目中，我们收集了客户的行为数据、交易记录和个人信息。首先，我们进行了数据探索，发现了几个关键指标，如客户最近一次购买的时间和频率，与客户流失高度相关。</p><p>接着，我们选择了随机森林分类器作为我们的模型，并使用特征工程中提到的方法对数据进行了处理。在模型训练后，我们在测试集上评估了模型的准确性，并进行了参数调优，最终达到了85%的准确率。</p><p>这个案例展示了实践项目中从问题定义到解决方案的全过程，包括数据理解、模型选择、训练和评估。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>3.数据处理和分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>数据处理和分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>特征工程的创造力</title>
    <link href="/2024/06/22/%E7%AC%AC%E4%BA%94%E8%8A%82%EF%BC%9A%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    <url>/2024/06/22/%E7%AC%AC%E4%BA%94%E8%8A%82%EF%BC%9A%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%88%9B%E9%80%A0%E5%8A%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第三部分：数据处理和分析"><a href="#高级提示词工程师-第三部分：数据处理和分析" class="headerlink" title="高级提示词工程师| 第三部分：数据处理和分析"></a>高级提示词工程师| 第三部分：数据处理和分析</h1><h2 id="第五节：特征工程的创造力"><a href="#第五节：特征工程的创造力" class="headerlink" title="| 第五节：特征工程的创造力"></a>| 第五节：特征工程的创造力</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>特征工程是将原始数据转化为模型可用信息的过程，它要求我们具备洞察力和创造力，就像一位雕塑家在创作时既要展现石头的内在美，又要赋予其新的形态和意义。</p><ul><li><strong>特征提取</strong>：特征提取是从数据中识别和提取出有助于分析和模型理解的信息。这就像从一片森林中找出最直的树干，用作建筑的梁柱。</li><li><strong>特征构造</strong>：特征构造是创造性地结合现有数据生成新特征。就像将不同的食材按照特定的食谱烹饪出美味的菜肴。</li><li><strong>降维</strong>：降维是在保留数据集中最重要信息的同时减少数据的复杂性。这类似于将一幅复杂的画作简化为几笔勾勒出的轮廓，让人一眼就能看出画的主旨。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> PolynomialFeatures<br><br><span class="hljs-comment"># 特征提取：从文本数据中提取词袋模型</span><br>text_data = data[<span class="hljs-string">&#x27;text_column&#x27;</span>]<br>vectorizer = CountVectorizer()<br>X_text = vectorizer.fit_transform(text_data)<br><span class="hljs-built_in">print</span>(X_text.shape)  <span class="hljs-comment"># 查看转换后的特征数量</span><br><br><span class="hljs-comment"># 特征构造：创建交互特征</span><br>interaction_features = PolynomialFeatures(degree=<span class="hljs-number">2</span>, interaction_only=<span class="hljs-literal">True</span>)<br>X_interaction = interaction_features.fit_transform(data[[<span class="hljs-string">&#x27;numerical_feature1&#x27;</span>, <span class="hljs-string">&#x27;numerical_feature2&#x27;</span>]])<br><span class="hljs-built_in">print</span>(X_interaction.shape)  <span class="hljs-comment"># 查看交互特征的数量</span><br><br><span class="hljs-comment"># 降维：使用主成分分析（PCA）进行降维</span><br>pca = PCA(n_components=<span class="hljs-number">2</span>)  <span class="hljs-comment"># 选择降维到2个主成分</span><br>X_pca = pca.fit_transform(data[[<span class="hljs-string">&#x27;feature1&#x27;</span>, <span class="hljs-string">&#x27;feature2&#x27;</span>, <span class="hljs-string">&#x27;feature3&#x27;</span>]])<br><span class="hljs-built_in">print</span>(X_pca.shape)  <span class="hljs-comment"># 查看降维后的数据形状</span><br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个电商推荐系统项目中，我们需要从用户的浏览和购买历史中提取特征，以预测用户可能感兴趣的商品。我们首先使用CountVectorizer从商品描述中提取关键词，然后构造了用户与商品的交互特征，如浏览次数和购买频率。为了在推荐模型中使用，我们还对用户特征进行了PCA降维。</p><p>在这个案例中，我们发现构造的交互特征显著提高了推荐系统的准确性。PCA降维后的主成分与用户的购买力和品牌偏好有很强的相关性，这帮助我们更好地理解了用户行为模式。</p><p>通过特征工程，我们不仅提升了模型的性能，还深化了对数据的理解。特征工程是连接原始数据和模型预测能力之间的桥梁。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>3.数据处理和分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>数据处理和分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>统计分析的基础</title>
    <link href="/2024/06/22/%E7%AC%AC%E5%9B%9B%E8%8A%82%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/06/22/%E7%AC%AC%E5%9B%9B%E8%8A%82%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第三部分：数据处理和分析"><a href="#高级提示词工程师-第三部分：数据处理和分析" class="headerlink" title="高级提示词工程师| 第三部分：数据处理和分析"></a>高级提示词工程师| 第三部分：数据处理和分析</h1><h2 id="第四节：统计分析的基础"><a href="#第四节：统计分析的基础" class="headerlink" title="| 第四节：统计分析的基础"></a>| 第四节：统计分析的基础</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>统计分析是数据科学家的放大镜，通过它我们可以观察到数据的微观结构，理解数据的内在规律。</p><ul><li><strong>描述性统计</strong>：描述性统计就像是对数据的第一次亲密接触，我们通过均值、中位数、众数、方差等指标来了解数据的中心趋势和分散程度。</li><li><strong>推断性统计</strong>：推断性统计就像是通过水晶球预测未来，我们基于样本数据来推断总体的特征，如假设检验和置信区间。</li><li><strong>相关性分析</strong>：相关性分析帮助我们发现变量之间的联系，就像侦探通过线索寻找犯罪嫌疑人之间的关系。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scipy.stats <span class="hljs-keyword">as</span> stats<br><br><span class="hljs-comment"># 描述性统计</span><br>data.describe()  <span class="hljs-comment"># 提供数据的计数、平均值、标准差、最小值、四分位数和最大值</span><br><br><span class="hljs-comment"># 计算相关性</span><br>correlation = data[[<span class="hljs-string">&#x27;numerical_column1&#x27;</span>, <span class="hljs-string">&#x27;numerical_column2&#x27;</span>]].corr()<br><span class="hljs-built_in">print</span>(correlation)<br><br><span class="hljs-comment"># 假设检验，以t检验为例</span><br>t_stat, p_val = stats.ttest_1samp(data[<span class="hljs-string">&#x27;sample_column&#x27;</span>], popmean=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;T-statistic:&#x27;</span>, t_stat)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;P-value:&#x27;</span>, p_val)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个医疗研究项目中，我们收集了患者的血压数据，目的是分析某种新药对降低血压的效果。通过描述性统计，我们得到了血压的基本情况。进一步，我们使用t检验来比较用药前后血压的变化，以确定药物效果是否具有统计学意义。</p><p>在这个案例中，我们发现用药后患者的平均血压有显著下降，p值远小于0.05，这表明药物效果是显著的。此外，我们还进行了相关性分析，发现患者的年龄和血压之间存在微弱的正相关关系。</p><p>现在，我们即将进入特征工程的章节，这是将原始数据转化为模型可用特征的创造性过程。请回复“输出下一个章节”，我将继续为你拓展下一章的内容。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>3.数据处理和分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>数据处理和分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据可视化的窗口</title>
    <link href="/2024/06/22/%E7%AC%AC%E4%B8%89%E8%8A%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84%E7%AA%97%E5%8F%A3/"/>
    <url>/2024/06/22/%E7%AC%AC%E4%B8%89%E8%8A%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第三部分：数据处理和分析"><a href="#高级提示词工程师-第三部分：数据处理和分析" class="headerlink" title="高级提示词工程师| 第三部分：数据处理和分析"></a>高级提示词工程师| 第三部分：数据处理和分析</h1><h2 id="第三节：数据可视化的窗口"><a href="#第三节：数据可视化的窗口" class="headerlink" title="| 第三节：数据可视化的窗口"></a>| 第三节：数据可视化的窗口</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>数据可视化就像是给数据绘制地图，它帮助我们探索数据的领域，发现隐藏的宝藏和陷阱。</p><ul><li><strong>图表和图形</strong>：图表是数据的展示窗口，条形图、折线图、散点图等，每一种图表都以独特的方式讲述数据的故事。</li><li><strong>趋势分析</strong>：通过可视化，我们可以观察数据随时间变化的趋势，就像观察潮起潮落一样。</li><li><strong>分布分析</strong>：分布图可以揭示数据的分布情况，让我们了解数据是否集中在某个区域，或者是否有明显的异常值。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><br><span class="hljs-comment"># 绘制条形图展示不同类别的数量</span><br>data[<span class="hljs-string">&#x27;categorical_column&#x27;</span>].value_counts().plot(kind=<span class="hljs-string">&#x27;bar&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Bar Chart of Categories&#x27;</span>)<br>plt.show()<br><br><span class="hljs-comment"># 绘制折线图展示趋势</span><br>plt.plot(data[<span class="hljs-string">&#x27;date_column&#x27;</span>], data[<span class="hljs-string">&#x27;numerical_column&#x27;</span>])<br>plt.title(<span class="hljs-string">&#x27;Trend Over Time&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;Date&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Value&#x27;</span>)<br>plt.show()<br><br><span class="hljs-comment"># 绘制散点图探索两个数值变量的关系</span><br>sns.scatterplot(x=<span class="hljs-string">&#x27;numerical_column1&#x27;</span>, y=<span class="hljs-string">&#x27;numerical_column2&#x27;</span>, data=data)<br>plt.title(<span class="hljs-string">&#x27;Scatter Plot of Two Numerical Variables&#x27;</span>)<br>plt.show()<br><br><span class="hljs-comment"># 绘制直方图探索数值变量的分布</span><br>data[<span class="hljs-string">&#x27;numerical_column&#x27;</span>].hist()<br>plt.title(<span class="hljs-string">&#x27;Distribution of a Numerical Variable&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个关于房地产市场的数据集中，我们使用数据可视化来探索房屋价格与其他因素（如房屋大小、位置、建造年份）的关系。通过散点图矩阵，我们发现房屋价格与房屋大小成正比，而与建造年份成反比。此外，我们还使用热力图来展示不同地区房屋价格的分布情况，帮助房地产经纪人更好地理解市场趋势。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>3.数据处理和分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>数据处理和分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据转换的魔法</title>
    <link href="/2024/06/22/%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%AD%94%E6%B3%95/"/>
    <url>/2024/06/22/%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%AD%94%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第三部分：数据处理和分析"><a href="#高级提示词工程师-第三部分：数据处理和分析" class="headerlink" title="高级提示词工程师| 第三部分：数据处理和分析"></a>高级提示词工程师| 第三部分：数据处理和分析</h1><h2 id="第二节：数据转换的魔法"><a href="#第二节：数据转换的魔法" class="headerlink" title="| 第二节：数据转换的魔法"></a>| 第二节：数据转换的魔法</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>数据转换就像是将粗糙的原石打磨成璀璨的宝石。原始数据往往需要经过转换才能在模型中发挥最大的作用。这个过程包括标准化、归一化、编码分类变量等。</p><ul><li><strong>标准化</strong>：想象一下，你正在准备一篮子水果，为了让它们更易于比较，你需要将它们切成相同的大小。在数据中，标准化就是将所有的特征缩放到相同的尺度。</li><li><strong>归一化</strong>：这就像是将所有的数据压缩到一个固定大小的盒子里，无论原始数据的大小如何。</li><li><strong>编码分类变量</strong>：分类变量就像是不同颜色的蜡笔，我们需要将它们转换成模型可以理解的数字形式。独热编码和标签编码是常用的转换方法。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler, OneHotEncoder<br><br><span class="hljs-comment"># 标准化</span><br>scaler = StandardScaler()<br>data[<span class="hljs-string">&#x27;standardized_column&#x27;</span>] = scaler.fit_transform(data[[<span class="hljs-string">&#x27;numerical_column&#x27;</span>]])<br><br><span class="hljs-comment"># 归一化</span><br>data[<span class="hljs-string">&#x27;normalized_column&#x27;</span>] = data[<span class="hljs-string">&#x27;numerical_column&#x27;</span>] / data[<span class="hljs-string">&#x27;numerical_column&#x27;</span>].<span class="hljs-built_in">max</span>()<br><br><span class="hljs-comment"># 编码分类变量</span><br>encoder = OneHotEncoder(sparse=<span class="hljs-literal">False</span>)<br>data_encoded = encoder.fit_transform(data[[<span class="hljs-string">&#x27;categorical_column&#x27;</span>]])<br>data_encoded.columns = encoder.get_feature_names([<span class="hljs-string">&#x27;categorical_column&#x27;</span>])<br>data = pd.concat([data, data_encoded], axis=<span class="hljs-number">1</span>).drop([<span class="hljs-string">&#x27;categorical_column&#x27;</span>], axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>在一个关于汽车保险的数据集中，我们需要处理各种类型的数据。例如，车辆类型（轿车、SUV等）是分类变量，我们使用独热编码将其转换为模型可以理解的形式。车辆的年龄是一个数值变量，但我们发现年轻的车辆和年老的车辆维修成本更高，因此我们创建了一个新特征“车辆年龄的平方”，以捕捉这种非线性关系。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>3.数据处理和分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>数据处理和分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据清洗的艺术</title>
    <link href="/2024/06/22/%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <url>/2024/06/22/%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第三部分：数据处理和分析"><a href="#高级提示词工程师-第三部分：数据处理和分析" class="headerlink" title="高级提示词工程师| 第三部分：数据处理和分析"></a>高级提示词工程师| 第三部分：数据处理和分析</h1><h2 id="第一节：数据清洗的艺术"><a href="#第一节：数据清洗的艺术" class="headerlink" title="| 第一节：数据清洗的艺术"></a>| 第一节：数据清洗的艺术</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="| 基础知识："></a>| 基础知识：</h3><p>数据清洗是数据分析的第一步，就像园丁修剪花草一样，我们去除数据中的杂草——也就是那些不完整、不准确或无关紧要的部分。数据清洗包括处理缺失值、识别和修正错误，以及平滑数据以消除噪声。</p><ul><li><strong>处理缺失值</strong>：想象一下，你的数据集就像一张拼图，缺失值就是那些丢失的拼图块。我们需要决定是填补这些空缺（用均值、中位数或众数），还是干脆忽略它们。</li><li><strong>识别和修正错误</strong>：错误数据就像食谱中的错别字，可能会误导整个烹饪过程。我们需要检查数据集中的不一致性，并修正它们。</li><li><strong>平滑数据</strong>：有时，数据可能会因为异常值或极端波动而变得嘈杂。平滑数据就像是用滤网过滤汤，去除那些杂质。</li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 加载数据集</span><br>data = pd.read_csv(<span class="hljs-string">&#x27;data.csv&#x27;</span>)<br><br><span class="hljs-comment"># 检查缺失值</span><br><span class="hljs-built_in">print</span>(data.isnull().<span class="hljs-built_in">sum</span>())<br><br><span class="hljs-comment"># 用均值填充缺失值</span><br>data.fillna(data.mean(), inplace=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 识别和修正错误</span><br><span class="hljs-comment"># 假设我们发现&#x27;age&#x27;列中有一个异常值105，我们将其修正为正常的年龄值</span><br>data.loc[data[<span class="hljs-string">&#x27;age&#x27;</span>] == <span class="hljs-number">105</span>, <span class="hljs-string">&#x27;age&#x27;</span>] = np.mean(data[<span class="hljs-string">&#x27;age&#x27;</span>])<br><br><span class="hljs-comment"># 平滑数据，这里以简单的移动平均为例</span><br>data[<span class="hljs-string">&#x27;smoothed_value&#x27;</span>] = data[<span class="hljs-string">&#x27;value_column&#x27;</span>].rolling(window=<span class="hljs-number">3</span>).mean()<br></code></pre></td></tr></table></figure><h3 id="真实案例与分析："><a href="#真实案例与分析：" class="headerlink" title="真实案例与分析："></a>真实案例与分析：</h3><p>假设我们有一个电子商务网站的用户行为数据集。在这个案例中，我们注意到用户的会话持续时间有一例异常地高，达到了10,000分钟。经过调查，我们发现这是一个记录错误。我们决定修正这个值，并填补其他缺失的会话持续时间数据。此外，我们还平滑了用户消费金额的数据，以观察长期的消费趋势。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>3.数据处理和分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>数据处理和分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实践项目</title>
    <link href="/2024/06/22/%E5%85%B3%E5%8D%A17%EF%BC%9A%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/06/22/%E5%85%B3%E5%8D%A17%EF%BC%9A%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第二部分：编程和算法"><a href="#高级提示词工程师-第二部分：编程和算法" class="headerlink" title="高级提示词工程师| 第二部分：编程和算法"></a>高级提示词工程师| 第二部分：编程和算法</h1><h2 id="第七节：实践项目"><a href="#第七节：实践项目" class="headerlink" title="| 第七节：实践项目"></a>| 第七节：实践项目</h2><h3 id="知识点详解："><a href="#知识点详解：" class="headerlink" title="| 知识点详解："></a>| 知识点详解：</h3><ol><li><p><strong>项目选择</strong></p><ul><li>选择项目就像挑选一颗种子，它将决定你的花园（项目）将开出什么样的花朵。选择一个你感兴趣且具有挑战性的项目，这样你才能全程投入。</li></ul></li><li><p><strong>数据收集</strong></p><ul><li>数据收集就像为即将到来的冬天储备食物。你需要从不同的地方搜集数据，确保有足够的资源来滋养你的模型。</li></ul></li><li><p><strong>数据预处理</strong></p><ul><li>数据预处理就像是在烹饪前清洗和切割食材。你需要去除杂质（如处理缺失值），并确保数据以正确的形式（如特征缩放）供模型使用。</li></ul></li><li><p><strong>模型选择</strong></p><ul><li>选择模型就像是挑选一件工具。不同的工具适合不同的工作，有些任务需要精细的手术刀（如支持向量机），而有些则需要一把大锤（如决策树）。</li></ul></li><li><p><strong>特征工程</strong></p><ul><li>特征工程就像是雕刻家精心雕琢一块大理石，通过去除多余的部分，展现出数据的内在美。</li></ul></li><li><p><strong>模型训练</strong></p><ul><li>模型训练就像是在健身房锻炼肌肉，通过重复的训练（迭代），让模型变得更加强大和准确。</li></ul></li><li><p><strong>模型评估与调优</strong></p><ul><li>评估和调优模型就像是为参加比赛的赛车进行微调，以确保它在赛道上的表现达到最佳。</li></ul></li><li><p><strong>结果分析</strong></p><ul><li>结果分析就像是在一场音乐会后的观众反馈，它告诉我们哪些部分是高潮，哪些部分需要改进。</li></ul></li><li><p><strong>模型部署</strong></p><ul><li>模型部署就像是将一匹训练有素的赛马放到赛道上，让它在真实的比赛中展现实力。</li></ul></li><li><p><strong>项目文档编写</strong></p><ul><li>编写项目文档就像是为旅行写游记，记录下你沿途的风景和经历，让未能同行的人也能感受到旅程的精彩。</li></ul></li></ol><h3 id="代码示例与注释："><a href="#代码示例与注释：" class="headerlink" title="代码示例与注释："></a>代码示例与注释：</h3><ol><li><p><strong>数据预处理</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入Pandas库用于数据处理</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br><span class="hljs-comment"># 加载数据集，例如CSV文件</span><br>data = pd.read_csv(<span class="hljs-string">&#x27;data.csv&#x27;</span>)<br><br><span class="hljs-comment"># 检查数据信息，了解数据基本情况</span><br><span class="hljs-built_in">print</span>(data.info())<br><br><span class="hljs-comment"># 查看数据的前几行，确保数据加载正确</span><br><span class="hljs-built_in">print</span>(data.head())<br><br><span class="hljs-comment"># 处理缺失值，例如用均值填充</span><br><span class="hljs-comment"># 假设数据集中的数值型列可以使用均值填充</span><br><span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> data.select_dtypes(include=[<span class="hljs-string">&#x27;float64&#x27;</span>, <span class="hljs-string">&#x27;int64&#x27;</span>]).columns:<br>    data[column].fillna(data[column].mean(), inplace=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 转换分类数据，使用独热编码</span><br><span class="hljs-comment"># 假设数据集中的分类列适合使用独热编码</span><br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> OneHotEncoder<br>encoder = OneHotEncoder(sparse=<span class="hljs-literal">False</span>)<br>data_encoded = encoder.fit_transform(data[[<span class="hljs-string">&#x27;categorical_column&#x27;</span>]])<br>data_encoded.columns = encoder.get_feature_names([<span class="hljs-string">&#x27;categorical_column&#x27;</span>])<br>data = pd.concat([data, data_encoded], axis=<span class="hljs-number">1</span>).drop([<span class="hljs-string">&#x27;categorical_column&#x27;</span>], axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>模型选择与训练</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><br><span class="hljs-comment"># 划分特征和目标变量</span><br>X = data.drop(<span class="hljs-string">&#x27;target_column&#x27;</span>, axis=<span class="hljs-number">1</span>)<br>y = data[<span class="hljs-string">&#x27;target_column&#x27;</span>]<br><br><span class="hljs-comment"># 划分训练集和测试集</span><br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)<br><br><span class="hljs-comment"># 初始化随机森林分类器</span><br>model = RandomForestClassifier(n_estimators=<span class="hljs-number">100</span>, random_state=<span class="hljs-number">42</span>)<br><br><span class="hljs-comment"># 训练模型</span><br>model.fit(X_train, y_train)  <span class="hljs-comment"># 用训练集数据训练模型</span><br></code></pre></td></tr></table></figure></li><li><p><strong>模型评估</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br><br><span class="hljs-comment"># 使用模型对测试集进行预测</span><br>y_pred = model.predict(X_test)<br><br><span class="hljs-comment"># 计算准确率</span><br>accuracy = accuracy_score(y_test, y_pred)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Model Accuracy: <span class="hljs-subst">&#123;accuracy:<span class="hljs-number">.2</span>f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>模型调优</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCV<br><br><span class="hljs-comment"># 定义参数网格，尝试不同的参数组合</span><br>param_grid = &#123;<br>    <span class="hljs-string">&#x27;n_estimators&#x27;</span>: [<span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>],<br>    <span class="hljs-string">&#x27;max_depth&#x27;</span>: [<span class="hljs-literal">None</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>],<br>    <span class="hljs-string">&#x27;min_samples_split&#x27;</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>]<br>&#125;<br><br><span class="hljs-comment"># 使用网格搜索找到最佳参数</span><br>grid_search = GridSearchCV(estimator=model, param_grid=param_grid, cv=<span class="hljs-number">5</span>, scoring=<span class="hljs-string">&#x27;accuracy&#x27;</span>)<br>grid_search.fit(X_train, y_train)<br><br><span class="hljs-comment"># 输出最佳参数</span><br><span class="hljs-built_in">print</span>(grid_search.best_params_)<br></code></pre></td></tr></table></figure></li><li><p><strong>模型部署</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> joblib <span class="hljs-keyword">import</span> dump, load<br><br><span class="hljs-comment"># 保存训练好的模型到文件</span><br>dump(model, <span class="hljs-string">&#x27;trained_model.joblib&#x27;</span>)<br><br><span class="hljs-comment"># 之后可以在其他脚本或应用程序中加载模型</span><br>loaded_model = load(<span class="hljs-string">&#x27;trained_model.joblib&#x27;</span>)<br><br><span class="hljs-comment"># 使用加载的模型进行预测</span><br><span class="hljs-comment"># 假设new_data是已经预处理的新数据</span><br>prediction = loaded_model.predict(new_data)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Prediction: <span class="hljs-subst">&#123;prediction&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ol><p>通过这些代码示例和注释，你可以了解从数据预处理到模型部署的整个流程。每一步的代码都配有注释，帮助你理解代码的功能和目的。这将为你自己的实践项目提供坚实的基础。</p><pre><code class="hljs">### 关键词解释：1. **项目文档（Project Documentation）**：项目文档就像是项目的“使用手册”，详细记录了项目的每个步骤和决策，方便他人理解和使用项目。2. **自动化预测（Automated Prediction）**：自动化预测就像是给模型装上了“自动驾驶”功能，让它能够在没有人工干预的情况下进行预测。3. **生产环境（Production Environment）**：生产环境是模型部署后的“工作场所”，通常是服务器或云平台，这里模型将处理真实世界的数据。4. **性能指标（Performance Metrics）**：性能指标就像是模型的“成绩单”，告诉我们模型在哪些方面表现好，在哪些方面需要改进。5. **交叉验证（Cross-validation）**：交叉验证就像是给模型进行“全面体检”，通过在不同子集上测试模型来评估其稳定性和可靠性。6. **特征构造（Feature Engineering）**：特征构造就像是为模型“烹饪美食”，通过创造性地组合原始数据来增强模型的“口感”和“营养价值”。7. **参数调整（Parameter Tuning）**：参数调整就像是给模型“调整座椅”，找到最舒适的设置以获得最佳视野和体验。8. **模型泛化（Model Generalization）**：模型泛化能力就像是模型的“适应力”，衡量模型在新数据上的预测能力，与“水土不服”相反。通过这些生动的比喻和详细的代码示例，你可以更轻松地理解实践项目中的关键步骤和概念。每个知识点和代码示例都旨在帮助你构建直观的理解，使学习过程更加有趣和容易记忆。</code></pre>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>2.编程和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>编程和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习库熟悉</title>
    <link href="/2024/06/22/%E5%85%B3%E5%8D%A16%EF%BC%9A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BA%93%E7%86%9F%E6%82%89/"/>
    <url>/2024/06/22/%E5%85%B3%E5%8D%A16%EF%BC%9A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BA%93%E7%86%9F%E6%82%89/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第二部分：编程和算法"><a href="#高级提示词工程师-第二部分：编程和算法" class="headerlink" title="高级提示词工程师| 第二部分：编程和算法"></a>高级提示词工程师| 第二部分：编程和算法</h1><h2 id="第六节：机器学习库熟悉"><a href="#第六节：机器学习库熟悉" class="headerlink" title="| 第六节：机器学习库熟悉"></a>| 第六节：机器学习库熟悉</h2><h3 id="知识点详解："><a href="#知识点详解：" class="headerlink" title="| 知识点详解："></a>| 知识点详解：</h3><ol><li><p><strong>scikit-learn库</strong></p><ul><li>就像一个拥有所有常用工具的瑞士军刀，scikit-learn提供了大量易于使用的机器学习工具和算法。</li></ul></li><li><p><strong>TensorFlow和PyTorch</strong></p><ul><li>这两个库像是深度学习领域的两大支柱，TensorFlow像是构建复杂建筑的蓝图，而PyTorch则像是灵活多变的乐高积木。</li></ul></li><li><p><strong>数据加载与预处理</strong></p><ul><li>数据预处理就像是在烹饪前清洗和切割食材，确保它们以最佳状态进入模型的“厨房”。</li></ul></li><li><p><strong>模型训练与评估</strong></p><ul><li>模型训练就像是教育一个学生，通过不断学习和练习来提高能力；评估模型则像是进行一场考试，检验学生的学习成果。</li></ul></li><li><p><strong>模型部署</strong></p><ul><li>将训练好的模型部署到实际应用中，就像是将训练有素的运动员送上赛场，展现其真正的实力。</li></ul></li><li><p><strong>特征工程</strong></p><ul><li>特征工程就像是雕塑家挑选和打磨石头，以塑造出一件美丽的艺术品。</li></ul></li><li><p><strong>模型调优</strong></p><ul><li>模型调优就像是调整赛车的引擎和悬挂系统，以确保在各种条件下都能发挥最佳性能。</li></ul></li><li><p><strong>深度学习最佳实践</strong></p><ul><li>深度学习的最佳实践就像是老船长的航海图，指引你避开暗礁，顺利到达目的地。</li></ul></li></ol><h3 id="代码示例与注释："><a href="#代码示例与注释：" class="headerlink" title="代码示例与注释："></a>代码示例与注释：</h3><ol><li><p><strong>使用scikit-learn加载数据集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris  <span class="hljs-comment"># 导入加载数据集的函数</span><br>iris = load_iris()  <span class="hljs-comment"># 加载iris数据集</span><br>X, y = iris.data, iris.target  <span class="hljs-comment"># 分离特征和目标变量</span><br><span class="hljs-comment"># X是特征矩阵，包含了150个样本的4个特征</span><br><span class="hljs-comment"># y是目标向量，包含了150个样本的类别标签</span><br></code></pre></td></tr></table></figure></li><li><p><strong>使用TensorFlow创建神经网络</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf  <span class="hljs-comment"># 导入TensorFlow库</span><br>model = tf.keras.models.Sequential([  <span class="hljs-comment"># 创建一个序贯模型</span><br>    tf.keras.layers.Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>, input_shape=(<span class="hljs-number">4</span>,)),  <span class="hljs-comment"># 第一层有10个神经元，使用ReLU激活函数</span><br>    tf.keras.layers.Dense(<span class="hljs-number">3</span>, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>)  <span class="hljs-comment"># 输出层有3个神经元，使用Softmax激活函数进行多类分类</span><br>])<br><span class="hljs-comment"># 这个模型可以用于分类iris数据集中的三种花卉</span><br></code></pre></td></tr></table></figure></li><li><p><strong>使用PyTorch创建神经网络</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch  <span class="hljs-comment"># 导入PyTorch库</span><br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn  <span class="hljs-comment"># 导入PyTorch的神经网络模块</span><br>model = nn.Sequential(  <span class="hljs-comment"># 创建一个序列模型</span><br>    nn.Linear(<span class="hljs-number">4</span>, <span class="hljs-number">10</span>),  <span class="hljs-comment"># 第一层全连接层，从4个输入特征到10个输出特征</span><br>    nn.ReLU(),  <span class="hljs-comment"># 激活函数层，使用ReLU激活函数</span><br>    nn.Linear(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment"># 第二层全连接层，从10个输入特征到3个输出特征</span><br>)<br><span class="hljs-comment"># 这个模型的结构与TensorFlow示例中的模型相同</span><br></code></pre></td></tr></table></figure></li><li><p><strong>模型训练</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split  <span class="hljs-comment"># 导入数据分割函数</span><br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.2</span>)  <span class="hljs-comment"># 将数据集分割为80%训练集和20%测试集</span><br><br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier  <span class="hljs-comment"># 导入随机森林分类器</span><br>model = RandomForestClassifier()  <span class="hljs-comment"># 创建随机森林模型实例</span><br>model.fit(X_train, y_train)  <span class="hljs-comment"># 使用训练数据拟合模型</span><br><span class="hljs-comment"># 模型现在可以根据训练数据对新的输入做出预测</span><br></code></pre></td></tr></table></figure></li><li><p><strong>模型评估</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score  <span class="hljs-comment"># 导入准确率计算函数</span><br>y_pred = model.predict(X_test)  <span class="hljs-comment"># 使用模型对测试数据进行预测</span><br>accuracy = accuracy_score(y_test, y_pred)  <span class="hljs-comment"># 计算模型预测的准确率</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Model accuracy: <span class="hljs-subst">&#123;accuracy*<span class="hljs-number">100</span>:<span class="hljs-number">.2</span>f&#125;</span>%&quot;</span>)  <span class="hljs-comment"># 打印模型的准确率</span><br></code></pre></td></tr></table></figure></li><li><p><strong>使用scikit-learn进行特征选择</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.feature_selection <span class="hljs-keyword">import</span> SelectKBest  <span class="hljs-comment"># 导入特征选择模块</span><br>selector = SelectKBest(k=<span class="hljs-number">2</span>)  <span class="hljs-comment"># 创建一个选择最佳2个特征的选择器</span><br>X_new = selector.fit_transform(X, y)  <span class="hljs-comment"># 拟合特征选择器并转换特征数据</span><br><span class="hljs-comment"># X_new现在只包含原始数据集中最重要的两个特征</span><br></code></pre></td></tr></table></figure></li><li><p><strong>使用TensorFlow进行模型调优</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">model.<span class="hljs-built_in">compile</span>(  <span class="hljs-comment"># 配置模型的优化器、损失函数和评估指标</span><br>    optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>,  <span class="hljs-comment"># 使用Adam优化器</span><br>    loss=<span class="hljs-string">&#x27;sparse_categorical_crossentropy&#x27;</span>,  <span class="hljs-comment"># 使用稀疏分类交叉熵作为损失函数</span><br>    metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])  <span class="hljs-comment"># 监控准确率指标</span><br>model.fit(X_train, y_train, epochs=<span class="hljs-number">10</span>, validation_split=<span class="hljs-number">0.2</span>)  <span class="hljs-comment"># 训练模型10个周期，使用20%的训练数据作为验证集</span><br><span class="hljs-comment"># 这个过程中模型将不断学习和调整自身，以提高预测的准确率</span><br></code></pre></td></tr></table></figure></li><li><p><strong>使用PyTorch进行模型调优</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">criterion = nn.CrossEntropyLoss()  <span class="hljs-comment"># 创建一个交叉熵损失函数，适用于多类分类问题</span><br>optimizer = torch.optim.Adam(model.parameters(), lr=<span class="hljs-number">0.001</span>)  <span class="hljs-comment"># 创建一个Adam优化器，用于更新模型参数</span><br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):  <span class="hljs-comment"># 进行多个训练周期</span><br>    optimizer.zero_grad()  <span class="hljs-comment"># 清除之前的梯度信息</span><br>    outputs = model(X_train)  <span class="hljs-comment"># 进行前向传播，获取模型输出</span><br>    loss = criterion(outputs, y_train)  <span class="hljs-comment"># 计算损失值</span><br>    loss.backward()  <span class="hljs-comment"># 进行反向传播，计算梯度</span><br>    optimizer.step()  <span class="hljs-comment"># 更新模型参数</span><br><span class="hljs-comment"># 这个过程就像是在不断地调整汽车的各个部件，以确保它在各种路况下都能表现最佳</span><br></code></pre></td></tr></table></figure></li></ol><p>通过这些生动的比喻和详细的代码注释，你可以更轻松地理解机器学习库的概念和使用方式。每个知识点和代码示例都旨在帮助你构建直观的理解，使学习过程更加有趣和容易记忆。</p><h3 id="关键词解释："><a href="#关键词解释：" class="headerlink" title="关键词解释："></a>关键词解释：</h3><ol><li><p><strong>数据集（Dataset）</strong>: 机器学习中用于训练和测试模型的示例集合，通常包含多个特征和对应的标签。</p></li><li><p><strong>特征（Feature）</strong>: 数据集中用于进行模型训练的输入变量，可以是数值、类别或其他类型的数据。</p></li><li><p><strong>目标&#x2F;标签（Target&#x2F;Label）</strong>: 数据集中我们想要预测或分类的值，是模型训练过程中学习的目标。</p></li><li><p><strong>模型（Model）</strong>: 从数据中学习并进行预测的算法或数学结构，如线性回归、神经网络等。</p></li><li><p><strong>训练（Training）</strong>: 使用数据集来训练模型的过程，目的是让模型学习到数据中的模式和关系。</p></li><li><p><strong>测试（Testing）</strong>: 使用未参与训练过程的数据来评估模型性能的过程，以检验模型的泛化能力。</p></li><li><p><strong>准确率（Accuracy）</strong>: 衡量分类模型性能的指标，表示模型正确预测的样本数占总样本数的比例。</p></li><li><p><strong>激活函数（Activation Function）</strong>: 神经网络中用于在神经元输出上增加非线性的函数，如ReLU或Sigmoid。</p></li><li><p><strong>损失函数（Loss Function）</strong>: 衡量模型预测与实际标签差异的函数，模型训练的目标是最小化损失函数的值。</p></li><li><p><strong>优化器（Optimizer）</strong>: 用于调整模型参数以最小化损失函数的算法，如SGD、Adam等。</p></li><li><p><strong>超参数（Hyperparameter）</strong>: 模型训练前需要设置的参数，如学习率、批次大小、训练周期数等。</p></li><li><p><strong>交叉验证（Cross-validation）</strong>: 一种评估模型性能的方法，通过将数据集分成多个子集并在这些子集上循环进行训练和测试。</p></li><li><p><strong>特征选择（Feature Selection）</strong>: 从原始数据中选择对模型预测最有用的特征的过程，可以提高模型的性能和解释性。</p></li><li><p><strong>深度学习（Deep Learning）</strong>: 一种使用多层神经网络来学习数据复杂模式的机器学习方法。</p></li><li><p><strong>正则化（Regularization）</strong>: 用于防止模型过拟合的技术，通过在损失函数中添加额外的惩罚项来限制模型的复杂度。</p></li><li><p><strong>批次（Batch）</strong>: 在神经网络训练中，数据被分成多个批次进行处理，每个批次包含一定数量的样本。</p></li><li><p><strong>迭代（Iteration）</strong>: 在模型训练过程中，迭代指的是对整个数据集进行一次完整的训练过程。</p></li><li><p><strong>反向传播（Backpropagation）</strong>: 一种在神经网络中计算梯度的方法，用于训练过程中的参数更新。</p></li><li><p><strong>梯度下降（Gradient Descent）</strong>: 一种优化算法，通过迭代地调整参数以最小化损失函数。</p></li><li><p><strong>模型部署（Model Deployment）</strong>: 将训练好的模型应用到实际应用中，如在线服务、移动应用或嵌入式系统。</p></li></ol><p>通过这些关键词的解释，你可以更深入地理解机器学习库中的核心概念和术语，为你在使用这些库进行开发和研究时提供坚实的基础。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>2.编程和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>编程和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级编程技巧</title>
    <link href="/2024/06/21/%E5%85%B3%E5%8D%A15%EF%BC%9A%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/06/21/%E5%85%B3%E5%8D%A15%EF%BC%9A%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第二部分：编程和算法"><a href="#高级提示词工程师-第二部分：编程和算法" class="headerlink" title="高级提示词工程师| 第二部分：编程和算法"></a>高级提示词工程师| 第二部分：编程和算法</h1><h2 id="第五节：高级编程技巧"><a href="#第五节：高级编程技巧" class="headerlink" title="| 第五节：高级编程技巧"></a>| 第五节：高级编程技巧</h2><h3 id="知识点详解："><a href="#知识点详解：" class="headerlink" title="| 知识点详解："></a>| 知识点详解：</h3><ol><li><p><strong>列表推导式（List Comprehension）</strong></p><ul><li>用于从现有列表创建新列表的简洁方式。</li></ul></li><li><p><strong>生成器（Generator）</strong></p><ul><li>使用<code>yield</code>返回值，实现惰性计算。</li></ul></li><li><p><strong>装饰器（Decorator）</strong></p><ul><li>用于增强函数或方法的功能。</li></ul></li><li><p><strong>上下文管理器（Context Manager）</strong></p><ul><li>通过<code>with</code>语句，管理资源的生命周期。</li></ul></li><li><p><strong>异常处理</strong></p><ul><li>处理程序运行中的错误情况。</li></ul></li><li><p><strong>迭代器（Iterator）</strong></p><ul><li>实现了迭代协议的对象。</li></ul></li><li><p><strong>生成器表达式</strong></p><ul><li>创建生成器的简洁语法。</li></ul></li><li><p><strong>匿名函数（Lambda Function）</strong></p><ul><li>使用<code>lambda</code>关键字定义的小函数。</li></ul></li><li><p><strong>高阶函数（Higher-order Function）</strong></p><ul><li>接受函数作为参数或返回函数的函数。</li></ul></li><li><p><strong>并发编程</strong></p><ul><li>利用多线程或多进程实现程序的并行执行。</li></ul></li></ol><h3 id="代码示例与注释："><a href="#代码示例与注释：" class="headerlink" title="代码示例与注释："></a>代码示例与注释：</h3><ol><li><p><strong>列表推导式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">squares = [x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]  <span class="hljs-comment"># 创建0到9的平方数列表</span><br></code></pre></td></tr></table></figure></li><li><p><strong>生成器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">count_up_to</span>(<span class="hljs-params"><span class="hljs-built_in">max</span></span>):<br>    count = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> count &lt;= <span class="hljs-built_in">max</span>:<br>        <span class="hljs-keyword">yield</span> count  <span class="hljs-comment"># 逐个产生值</span><br>        count += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> count_up_to(<span class="hljs-number">5</span>):  <span class="hljs-comment"># 逐个打印生成的值</span><br>    <span class="hljs-built_in">print</span>(number)<br></code></pre></td></tr></table></figure></li><li><p><strong>装饰器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_pretty</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Something is happening before the function is called.&quot;</span>)<br>        func()  <span class="hljs-comment"># 调用原始函数</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Something is happening after the function is called.&quot;</span>)<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@make_pretty  </span><span class="hljs-comment"># 使用装饰器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello!&quot;</span>)<br><br>say_hello()  <span class="hljs-comment"># 装饰器增强了say_hello函数</span><br></code></pre></td></tr></table></figure></li><li><p><strong>上下文管理器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyResource</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 进入上下文时执行</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Acquiring resource.&quot;</span>)<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):  <span class="hljs-comment"># 退出上下文时执行</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Releasing resource.&quot;</span>)<br><br><span class="hljs-keyword">with</span> MyResource() <span class="hljs-keyword">as</span> resource:  <span class="hljs-comment"># 使用with语句管理资源</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Using resource.&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>异常处理</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">divide</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">try</span>:<br>        result = x / y  <span class="hljs-comment"># 尝试执行除法</span><br>    <span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:  <span class="hljs-comment"># 捕获除以零的错误</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Division by zero is not allowed: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;The result is <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)  <span class="hljs-comment"># 如果没有异常，打印结果</span><br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Execution of the try-block is finished.&quot;</span>)  <span class="hljs-comment"># 最后总会执行</span><br><br>divide(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 测试除以零的情况</span><br></code></pre></td></tr></table></figure></li><li><p><strong>迭代器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIterator</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data</span>):<br>        self.data = data<br>        self.index = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 返回迭代器自身</span><br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 返回下一个元素</span><br>        <span class="hljs-keyword">if</span> self.index &lt; <span class="hljs-built_in">len</span>(self.data):<br>            value = self.data[self.index]<br>            self.index += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> StopIteration  <span class="hljs-comment"># 迭代结束</span><br><br>my_iter = MyIterator([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])  <span class="hljs-comment"># 创建迭代器</span><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> my_iter:  <span class="hljs-comment"># 遍历迭代器</span><br>    <span class="hljs-built_in">print</span>(item)<br></code></pre></td></tr></table></figure></li><li><p><strong>生成器表达式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">squares = (x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>))  <span class="hljs-comment"># 创建一个生成器表达式</span><br><span class="hljs-keyword">for</span> square <span class="hljs-keyword">in</span> squares:  <span class="hljs-comment"># 遍历生成器表达式</span><br>    <span class="hljs-built_in">print</span>(square)<br></code></pre></td></tr></table></figure></li><li><p><strong>匿名函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用lambda定义匿名函数并直接调用</span><br>square = <span class="hljs-keyword">lambda</span> x: x**<span class="hljs-number">2</span>  <span class="hljs-comment"># 定义一个匿名函数计算平方</span><br><span class="hljs-built_in">print</span>(square(<span class="hljs-number">5</span>))  <span class="hljs-comment"># 输出: 25</span><br></code></pre></td></tr></table></figure></li><li><p><strong>高阶函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_multiplier</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">multiplier_by_two</span>(<span class="hljs-params">arg</span>):<br>        <span class="hljs-keyword">return</span> func(arg) * <span class="hljs-number">2</span>  <span class="hljs-comment"># 使用传入的函数并乘以2</span><br>    <span class="hljs-keyword">return</span> multiplier_by_two<br><br>double = make_multiplier(<span class="hljs-keyword">lambda</span> x: x)  <span class="hljs-comment"># 创建一个接受lambda的高阶函数</span><br><span class="hljs-built_in">print</span>(double(<span class="hljs-number">5</span>))  <span class="hljs-comment"># 输出: 10</span><br></code></pre></td></tr></table></figure></li><li><p><strong>并发编程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_numbers</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>):  <span class="hljs-comment"># 线程执行的任务</span><br>        <span class="hljs-built_in">print</span>(i)<br><br>threads = [Thread(target=print_numbers) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)]  <span class="hljs-comment"># 创建多个线程</span><br><span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> threads:<br>    thread.start()  <span class="hljs-comment"># 启动线程</span><br><span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> threads:<br>    thread.join()  <span class="hljs-comment"># 等待线程结束</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="检验问题及详细解释："><a href="#检验问题及详细解释：" class="headerlink" title="检验问题及详细解释："></a>检验问题及详细解释：</h3><ol><li><p><strong>问题一</strong>：列表推导式相比普通循环有什么优势？</p><ul><li>优势在于代码简洁性和执行效率。适用于创建基于现有列表的新列表。</li></ul></li><li><p><strong>问题二</strong>：生成器相比普通函数有什么优势？</p><ul><li>生成器惰性计算，节省内存，适用于大数据集的迭代处理。</li></ul></li><li><p><strong>问题三</strong>：装饰器如何增强函数的功能？</p><ul><li>装饰器可以在不修改原函数代码的情况下，增加额外的功能。</li></ul></li><li><p><strong>问题四</strong>：上下文管理器的作用是什么？</p><ul><li>确保资源的正确管理，如自动关闭文件或释放锁。</li></ul></li><li><p><strong>问题五</strong>：异常处理在程序中的重要性是什么？</p><ul><li>异常处理可以捕获并响应错误，防止程序因未处理的异常而崩溃。</li></ul></li><li><p><strong>问题六</strong>：迭代器和生成器在Python中的区别是什么？</p><ul><li>迭代器是可以直接迭代的对象，生成器是一种特殊的迭代器，使用<code>yield</code>产生值。</li></ul></li><li><p><strong>问题七</strong>：匿名函数通常用在什么场景？</p><ul><li>匿名函数通常用于需要短暂或一次性使用的函数，如排序操作的键函数。</li></ul></li><li><p><strong>问题八</strong>：高阶函数的应用场景有哪些？</p><ul><li>高阶函数可以用于函数式编程，如map、filter等内建函数。</li></ul></li><li><p><strong>问题九</strong>：并发编程在Python中如何实现？</p><ul><li>可以使用<code>threading</code>模块实现线程并发，或使用<code>multiprocessing</code>模块实现进程并发。</li></ul></li><li><p><strong>问题十</strong>：并发编程的优势和挑战是什么？</p><ul><li>优势在于提高程序执行效率，挑战在于线程安全、死锁等问题的处理。</li></ul></li></ol><p>通过解答这些问题和实现代码示例，你将能够检验自己对Python高级编程技巧的掌握程度，并加深对这些高级概念的理解。每个问题都旨在加深你对特定高级编程技巧的掌握。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>2.编程和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>编程和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象编程</title>
    <link href="/2024/06/21/%E5%85%B3%E5%8D%A14%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/06/21/%E5%85%B3%E5%8D%A14%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第二部分：编程和算法"><a href="#高级提示词工程师-第二部分：编程和算法" class="headerlink" title="高级提示词工程师| 第二部分：编程和算法"></a>高级提示词工程师| 第二部分：编程和算法</h1><h2 id="第四节：面向对象编程"><a href="#第四节：面向对象编程" class="headerlink" title="| 第四节：面向对象编程"></a>| 第四节：面向对象编程</h2><h3 id="知识点详解："><a href="#知识点详解：" class="headerlink" title="| 知识点详解："></a>| 知识点详解：</h3><ol><li><p><strong>面向对象编程（OOP）概念</strong></p><ul><li><strong>对象</strong>：包含数据和行为的实体。</li><li><strong>类</strong>：对象的结构定义，可以创建多个对象实例。</li></ul></li><li><p><strong>类的定义和对象的创建</strong></p><ul><li>使用<code>class</code>关键字定义类，使用构造器<code>__init__</code>初始化对象。</li></ul></li><li><p><strong>属性和方法</strong></p><ul><li><strong>实例属性</strong>：对象特有的数据。</li><li><strong>类属性</strong>：类的所有实例共享的数据。</li><li><strong>实例方法</strong>：作用于实例属性的方法。</li><li><strong>类方法</strong>：使用<code>@classmethod</code>，作用于类属性。</li></ul></li><li><p><strong>继承</strong></p><ul><li>子类继承父类的属性和方法，使用<code>super()</code>调用父类方法。</li></ul></li><li><p><strong>多态</strong></p><ul><li>接口的多种不同实现。</li></ul></li><li><p><strong>封装</strong></p><ul><li>隐藏对象的状态和实现细节，只暴露操作接口。</li></ul></li><li><p><strong>抽象</strong></p><ul><li>抽象类不能实例化，用于规范子类的接口。</li></ul></li><li><p><strong>特殊方法</strong></p><ul><li>允许类实例表现得像内置类型，如<code>__str__()</code>、<code>__init__()</code>。</li></ul></li></ol><h3 id="代码示例与注释："><a href="#代码示例与注释：" class="headerlink" title="代码示例与注释："></a>代码示例与注释：</h3><ol><li><p><strong>定义一个类并创建对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):  <span class="hljs-comment"># 构造器，初始化对象属性</span><br>        self.name = name  <span class="hljs-comment"># 实例属性</span><br><br><span class="hljs-comment"># 创建Dog类的对象</span><br>my_dog = Dog(<span class="hljs-string">&quot;Buddy&quot;</span>)<br><span class="hljs-comment"># 使用对象的属性</span><br><span class="hljs-built_in">print</span>(my_dog.name)  <span class="hljs-comment"># 输出: Buddy</span><br></code></pre></td></tr></table></figure></li><li><p><strong>定义类属性和实例方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    species = <span class="hljs-string">&quot;Canine&quot;</span>  <span class="hljs-comment"># 类属性，所有Dog实例共享</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name  <span class="hljs-comment"># 实例属性，每个Dog实例的值不同</span><br>        self.age = age<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 实例方法，定义狗的行为</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Woof!&quot;</span><br><br><span class="hljs-comment"># 创建Dog实例并调用实例方法</span><br>my_dog = Dog(<span class="hljs-string">&quot;Buddy&quot;</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(Dog.species)  <span class="hljs-comment"># 输出: Canine</span><br><span class="hljs-built_in">print</span>(my_dog.bark())  <span class="hljs-comment"># 输出: Woof!</span><br></code></pre></td></tr></table></figure></li><li><p><strong>继承和<code>super()</code>的使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):  <span class="hljs-comment"># Dog类继承自Animal类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, breed</span>):<br>        <span class="hljs-built_in">super</span>().__init__(name)  <span class="hljs-comment"># 调用父类的构造器</span><br>        self.breed = breed  <span class="hljs-comment"># Dog特有的属性</span><br><br><span class="hljs-comment"># 创建Dog实例</span><br>my_dog = Dog(<span class="hljs-string">&quot;Buddy&quot;</span>, <span class="hljs-string">&quot;Golden Retriever&quot;</span>)<br><span class="hljs-built_in">print</span>(my_dog.name)  <span class="hljs-comment"># 输出: Buddy</span><br><span class="hljs-built_in">print</span>(my_dog.breed)  <span class="hljs-comment"># 输出: Golden Retriever</span><br></code></pre></td></tr></table></figure></li><li><p><strong>多态的示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Some generic sound&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 重写父类方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Woof!&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 重写父类方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Meow!&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">animal_sound</span>(<span class="hljs-params">animal</span>):<br>    <span class="hljs-comment"># 多态性，animal_sound可以接受Animal类的任何子类实例</span><br>    <span class="hljs-built_in">print</span>(animal.speak())<br><br><span class="hljs-comment"># 创建Animal子类实例</span><br>my_dog = Dog()<br>my_cat = Cat()<br>animal_sound(my_dog)  <span class="hljs-comment"># 输出: Woof!</span><br>animal_sound(my_cat)  <span class="hljs-comment"># 输出: Meow!</span><br></code></pre></td></tr></table></figure></li><li><p><strong>封装的示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, balance=<span class="hljs-number">0</span></span>):<br>        self.__balance = balance  <span class="hljs-comment"># 私有属性，外部无法直接访问</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deposit</span>(<span class="hljs-params">self, amount</span>):<br>        <span class="hljs-comment"># 存款方法，向账户增加金额</span><br>        <span class="hljs-keyword">if</span> amount &gt; <span class="hljs-number">0</span>:<br>            self.__balance += amount<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">withdraw</span>(<span class="hljs-params">self, amount</span>):<br>        <span class="hljs-comment"># 取款方法，从账户扣除金额</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt; amount &lt;= self.__balance:<br>            self.__balance -= amount<br>            <span class="hljs-keyword">return</span> amount<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_balance</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 公开方法，允许外部获取账户余额</span><br>        <span class="hljs-keyword">return</span> self.__balance<br><br><span class="hljs-comment"># 创建银行账户对象并操作</span><br>account = BankAccount()<br>account.deposit(<span class="hljs-number">100</span>)<br><span class="hljs-built_in">print</span>(account.get_balance())  <span class="hljs-comment"># 输出: 100</span><br></code></pre></td></tr></table></figure></li><li><p><strong>特殊方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        self.value = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 特殊方法，定义对象的字符串表示</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;MyClass(<span class="hljs-subst">&#123;self.value&#125;</span>)&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 特殊方法，定义对象的官方字符串表示</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;MyClass(<span class="hljs-subst">&#123;self.value&#125;</span>)&quot;</span><br><br><span class="hljs-comment"># 创建MyClass实例并打印</span><br>my_obj = MyClass(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(my_obj)  <span class="hljs-comment"># 输出: MyClass(10)</span><br><span class="hljs-comment"># repr()函数调用__repr__方法</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">repr</span>(my_obj))  <span class="hljs-comment"># 输出: MyClass(10)</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="检验问题及详细解释："><a href="#检验问题及详细解释：" class="headerlink" title="检验问题及详细解释："></a>检验问题及详细解释：</h3><ol><li><p><strong>问题一</strong>：解释面向对象编程中的“类”和“对象”的区别和联系。</p><ul><li>类似于模具和铸造出来的产品。类是定义产品（对象）形状和特性的模具。</li></ul></li><li><p><strong>问题二</strong>：如何在Python中定义类和创建对象？</p><ul><li>使用<code>class</code>关键字定义类，然后通过类名调用构造器创建对象。</li></ul></li><li><p><strong>问题三</strong>：解释类属性和实例属性的区别。</p><ul><li>类属性是所有实例共享的，实例属性是每个实例独有的。</li></ul></li><li><p><strong>问题四</strong>：什么是继承，如何在Python中实现？</p><ul><li>继承是创建一个新类（子类）来扩展或修改一个现有类（父类）的能力。在类定义时通过括号指定父类。</li></ul></li><li><p><strong>问题五</strong>：什么是多态，它在面向对象编程中的作用是什么？</p><ul><li>多态允许同一个接口接受不同的数据类型，使得代码更加灵活和可扩展。</li></ul></li><li><p><strong>问题六</strong>：封装的好处是什么？</p><ul><li>封装可以隐藏内部状态和实现细节，只暴露出一个可以被外界访问和操作的接口，提高代码的安全性和可维护性。</li></ul></li><li><p><strong>问题七</strong>：如何在Python中实现抽象类？</p><ul><li>使用<code>abc</code>模块中的<code>ABC</code>类和<code>abstractmethod</code>装饰器来定义抽象方法和抽象类。</li></ul></li><li><p><strong>问题八</strong>：特殊方法在Python中的作用是什么？</p><ul><li>特殊方法允许类的实例表现得像内置类型，例如<code>__str__()</code>和<code>__repr__()</code>定义对象的字符串表示。</li></ul></li><li><p><strong>问题九</strong>：如何在Python中使用类方法和静态方法？</p><ul><li>类方法使用<code>@classmethod</code>装饰器，静态方法使用<code>@staticmethod</code>装饰器，类方法可以访问类属性，静态方法不自动传递类或实例的引用。</li></ul></li><li><p><strong>问题十</strong>：使用私有属性和公共属性在Python中实现封装的方法是什么？</p><ul><li>在属性名前加双下划线（<code>__</code>）使其成为私有属性，通过公共方法（如getter和setter）来访问和修改私有属性。公共属性可以直接访问。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>2.编程和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>编程和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法基础</title>
    <link href="/2024/06/21/%E5%85%B3%E5%8D%A13%EF%BC%9A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/06/21/%E5%85%B3%E5%8D%A13%EF%BC%9A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第二部分：编程和算法"><a href="#高级提示词工程师-第二部分：编程和算法" class="headerlink" title="高级提示词工程师| 第二部分：编程和算法"></a>高级提示词工程师| 第二部分：编程和算法</h1><h2 id="第三节：算法基础"><a href="#第三节：算法基础" class="headerlink" title="| 第三节：算法基础"></a>| 第三节：算法基础</h2><h3 id="知识点详解："><a href="#知识点详解：" class="headerlink" title="| 知识点详解："></a>| 知识点详解：</h3><ol><li><p><strong>算法复杂度</strong></p><ul><li><strong>时间复杂度</strong>：衡量算法执行时间的指标，通常与输入数据的规模有关。</li><li><strong>空间复杂度</strong>：衡量算法在执行过程中占用存储空间的指标。</li><li><strong>大O表示法</strong>：一种描述算法复杂度的符号，如O(n)表示线性时间复杂度。</li></ul></li><li><p><strong>排序算法</strong></p><ul><li>排序算法的目的是将一组数据按照特定顺序重新排列。</li></ul></li><li><p><strong>搜索算法</strong></p><ul><li>搜索算法用于在数据结构中查找特定元素。</li></ul></li><li><p><strong>递归</strong></p><ul><li>递归是一种通过函数自我调用实现问题分解的编程技巧。</li></ul></li><li><p><strong>图算法</strong></p><ul><li>图算法用于在图数据结构中遍历和搜索。</li></ul></li><li><p><strong>动态规划</strong></p><ul><li>动态规划是一种解决多阶段决策问题的方法，通过存储中间结果避免重复计算。</li></ul></li><li><p><strong>贪心算法</strong></p><ul><li>贪心算法在每一步选择局部最优解，以期望获得全局最优解。</li></ul></li></ol><h3 id="代码示例与注释："><a href="#代码示例与注释：" class="headerlink" title="代码示例与注释："></a>代码示例与注释：</h3><ol><li><p><strong>冒泡排序</strong><br><img src="/img/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序" title="冒泡排序"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs code">function bubbleSort(arr) &#123;<br>    var len = arr.length;<br>    for (var i = 0; i &lt; len - 1; i++) &#123;<br>        for (var j = 0; j &lt; len - 1 - i; j++) &#123;<br>            if (arr[j] &gt; arr[j + 1]) &#123; // 相邻元素两两对比<br>                var temp = arr[j + 1]; // 元素交换<br>                arr[j + 1] = arr[j];<br>                arr[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    return arr;<br>&#125;<br>var arr = [6, 5, 4, 3, 2, 1];<br>console.log(arr); // [6, 5, 4, 3, 2, 1]<br>bubbleSort(arr);<br>console.log(arr); // [1, 2, 3, 4, 5, 6]<br></code></pre></td></tr></table></figure></li><li><p><strong>选择排序</strong><br><img src="/img/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%A4%BA%E4%BE%8B.gif" alt="选择排序示例" title="选择排序示例"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs code">function selectionSort(arr) &#123;<br>     if (arr == null || arr.length &lt; 2) &#123;<br>         return arr;<br>     &#125;<br>     for (var i = 0; i &lt; (arr.length - 1); i++) &#123;<br>         let minIndex = i;<br>             for (let j = i + 1; j &lt; arr.length; j++) &#123;<br>                 minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;<br>             &#125;<br>         let temp = arr[i];<br>         arr[i] = arr[minIndex];<br>         arr[minIndex] = temp;<br>       &#125;<br>     return arr;<br>  &#125;<br> var arr = [1, 3, 2, 8, 9, 1, 5];<br> console.log(arr); // [1, 3, 2, 8, 9, 1, 5]<br> selectionSort(arr);<br> console.log(arr); // [1, 1, 2, 3, 5, 8, 9]<br></code></pre></td></tr></table></figure></li><li><p><strong>插入排序</strong></p></li></ol><p><img src="/img/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%A4%BA%E4%BE%8B.gif" alt="插入排序示例" title="插入排序示例"><br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs code">function insertionSort(arr) &#123;<br>     if (arr == null || arr.length &lt; 2) &#123;<br>         return arr;<br>     &#125;<br>     for (let i = 1; i &lt; arr.length; i++) &#123;<br>         for (let j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123;<br>             let temp = arr[j];<br>             arr[j] = arr[j + 1];<br>             arr[j + 1] = temp;<br>         &#125;<br>     &#125;<br>     return arr;<br> &#125;<br> var arr = [3, 4, 2, 1, 6, 7, 8, 4];<br> console.log(arr); // [3, 4, 2, 1, 6, 7, 8, 4]<br> insertionSort(arr);<br> console.log(arr); // [1, 2, 3, 4, 4, 6, 7, 8]<br></code></pre></td></tr></table></figure></p><ol start="4"><li><p><strong>快速排序</strong><br><img src="/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%A4%BA%E4%BE%8B.gif" alt="快速排序示例" title="快速排序示例"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs code">const quickSort = (array) =&gt; &#123;<br>    const sort = (arr, left = 0, right = arr.length - 1) =&gt; &#123;<br>        if (left &gt;= right) &#123; //如果左边的索引大于等于右边的索引说明整理完毕<br>            return<br>        &#125;<br>        let i = left<br>        let j = right<br>        const baseVal = arr[j] // 取无序数组最后一个数为基准值<br>        while (i &lt; j) &#123; //把所有比基准值小的数放在左边大的数放在右边<br>            while (i &lt; j &amp;&amp; arr[i] &lt;= baseVal) &#123; //找到一个比基准值大的数交换<br>                i++<br>            &#125;<br>        arr[j] = arr[i] // 将较大的值放在右边如果没有比基准值大的数就是将自己赋值给自己（i 等于 j）<br>            while (j &gt; i &amp;&amp; arr[j] &gt;= baseVal) &#123; //找到一个比基准值小的数交换<br>                j--<br>            &#125;<br>        arr[i] = arr[j] // 将较小的值放在左边如果没有找到比基准值小的数就是将自己赋值给自己（i 等于 j）<br>      &#125;<br>    arr[j] = baseVal // 将基准值放至中央位置完成一次循环（这时候 j 等于 i ）<br>    sort(arr, left, j - 1) // 将左边的无序数组重复上面的操作<br>    sort(arr, j + 1, right) // 将右边的无序数组重复上面的操作<br>    &#125;<br>    const newArr = array.concat() // 为了保证这个函数是纯函数拷贝一次数组<br>    sort(newArr)<br>    return newArr<br>&#125;<br>var arr = [6,5,4,5,3,4,1];<br>console.log(arr); // [6, 5, 4, 5, 3, 4, 1]<br>console.log(quickSort(arr)); // [1, 3, 4, 4, 5, 5, 6]<br></code></pre></td></tr></table></figure></li><li><p><strong>线性搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_search</span>(<span class="hljs-params">arr, x</span>):<br>    <span class="hljs-comment"># 遍历数组，查找目标值</span><br>    <span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(arr):<br>        <span class="hljs-comment"># 如果找到目标值，返回当前索引</span><br>        <span class="hljs-keyword">if</span> item == x:<br>            <span class="hljs-keyword">return</span> i<br>    <span class="hljs-comment"># 如果未找到，返回-1</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p><strong>二分搜索</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">binary_search</span>(<span class="hljs-params">arr, x</span>):<br>    <span class="hljs-comment"># 初始化搜索区间的左右端点</span><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left &lt;= right:<br>        <span class="hljs-comment"># 计算中间位置</span><br>        mid = (left + right) // <span class="hljs-number">2</span><br>        <span class="hljs-comment"># 如果中间元素正好是目标值，返回中间位置</span><br>        <span class="hljs-keyword">if</span> arr[mid] == x:<br>            <span class="hljs-keyword">return</span> mid<br>        <span class="hljs-comment"># 如果中间元素小于目标值，调整左边界</span><br>        <span class="hljs-keyword">elif</span> arr[mid] &lt; x:<br>            left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 如果中间元素大于目标值，调整右边界</span><br>        <span class="hljs-keyword">else</span>:<br>            right = mid - <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 如果搜索范围不存在目标值，返回-1</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p><strong>递归示例：计算阶乘</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-comment"># 递归的终止条件，0的阶乘是1</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 递归调用，返回n乘以(n-1)的阶乘</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> n * factorial(n-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>深度优先搜索（DFS）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">graph, start, visited=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-comment"># 如果没有定义访问集合，则创建一个新的</span><br>    <span class="hljs-keyword">if</span> visited <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        visited = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-comment"># 标记起始顶点为已访问</span><br>    visited.add(start)<br>    <span class="hljs-comment"># 打印当前访问的顶点</span><br>    <span class="hljs-built_in">print</span>(start)<br>    <span class="hljs-comment"># 递归访问当前顶点的所有未访问邻居</span><br>    <span class="hljs-keyword">for</span> neighbour <span class="hljs-keyword">in</span> graph[start] - visited:<br>        dfs(graph, neighbour, visited)<br></code></pre></td></tr></table></figure></li><li><p><strong>广度优先搜索（BFS）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">graph, start</span>):<br>    <span class="hljs-comment"># 创建一个队列用于BFS</span><br>    queue = deque([start])<br>    <span class="hljs-comment"># 创建一个集合用于记录已访问的顶点</span><br>    visited = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">while</span> queue:<br>        <span class="hljs-comment"># 从队列中取出一个顶点</span><br>        vertex = queue.popleft()<br>        <span class="hljs-comment"># 如果该顶点还未访问，则访问并打印</span><br>        <span class="hljs-keyword">if</span> vertex <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>            visited.add(vertex)<br>            <span class="hljs-built_in">print</span>(vertex)<br>            <span class="hljs-comment"># 将该顶点的所有未访问邻居加入队列</span><br>            queue.extend(graph[vertex] - visited)<br></code></pre></td></tr></table></figure></li></ol><h3 id="检验问题及详细解释："><a href="#检验问题及详细解释：" class="headerlink" title="检验问题及详细解释："></a>检验问题及详细解释：</h3><ol><li><p><strong>问题一</strong>：编写冒泡排序算法的Python实现，并解释其工作原理和时间复杂度。</p><ul><li><strong>解答</strong>：冒泡排序通过重复遍历要排序的数列，比较每对相邻元素的大小，并在必要时交换它们的位置。这个过程重复进行，直到没有需要交换的元素为止，即数组已经排序完成。</li><li><strong>时间复杂度</strong>：最坏情况下，冒泡排序的时间复杂度为O(n^2)，发生在每次比较都需要交换时。最佳情况下，如果数组已经排序，时间复杂度为O(n)。</li></ul></li><li><p><strong>问题二</strong>：实现快速排序算法，并解释其分治策略及时间复杂度。</p><ul><li><strong>解答</strong>：快速排序通过选取一个元素作为“基准”（pivot），然后将数组分为两个子数组，一个包含所有小于基准的元素，另一个包含所有大于基准的元素。这个过程称为分区（partitioning）。之后，递归地对这两个子数组进行快速排序。</li><li><strong>时间复杂度</strong>：平均情况下，快速排序的时间复杂度为O(n log n)。最坏情况下，当选择的基准值是最小或最大元素时，时间复杂度为O(n^2)。</li></ul></li><li><p><strong>问题三</strong>：编写线性搜索算法的Python代码，并解释其适用场景。</p><ul><li><strong>解答</strong>：线性搜索通过遍历数组中的每个元素来查找特定值。如果找到匹配的元素，则返回该元素的索引；如果遍历完成后未找到，则返回-1或类似的表示未找到的值。</li><li><strong>适用场景</strong>：线性搜索适用于小型数据集或无序数据集，且实现简单。</li></ul></li><li><p><strong>问题四</strong>：实现二分搜索算法，并解释为什么它要求数组是有序的，以及它的效率如何。</p><ul><li><strong>解答</strong>：二分搜索通过将目标值与数组中间元素进行比较，根据比较结果缩小搜索范围。如果目标值等于中间元素，则搜索成功；如果目标值小于中间元素，则在左半部分继续搜索；如果目标值大于中间元素，则在右半部分继续搜索。这个过程重复进行，直到找到目标值或搜索范围为空。</li><li><strong>效率</strong>：二分搜索要求数组是有序的，这样每次比较后都能将搜索范围减半。二分搜索的时间复杂度为O(log n)，非常高效。</li></ul></li><li><p><strong>问题五</strong>：编写一个使用递归的算法，如阶乘或斐波那契数列，并解释递归的工作原理。</p><ul><li><strong>解答</strong>：递归算法通过函数自我调用来解决问题。例如，阶乘函数可以定义为<code>n! = n * (n-1)!</code>，当<code>n</code>为0时，<code>0!</code>定义为1。斐波那契数列可以定义为<code>F(n) = F(n-1) + F(n-2)</code>，其中<code>F(0) = 0</code>，<code>F(1) = 1</code>。</li><li><strong>工作原理</strong>：递归算法将问题分解为更小的子问题，并使用相同的方法解决这些子问题。递归通常有一个或多个终止条件，以避免无限递归。</li></ul></li><li><p><strong>问题六</strong>：描述DFS和BFS算法的工作原理，并比较它们的不同及适用场景。</p><ul><li><strong>解答</strong>：DFS使用栈（可以是显式的栈或隐式的函数调用栈）来遍历图或树的深度，尽可能深地搜索分支。BFS使用队列来遍历图或树的广度，一层一层地访问节点。</li><li><strong>不同</strong>：DFS适用于寻找路径或连通性问题，而BFS适用于寻找最短路径问题。</li></ul></li><li><p><strong>问题七</strong>：实现一个动态规划算法解决实际问题，如背包问题或最长公共子序列，并解释动态规划的优势。</p><ul><li><strong>解答</strong>：动态规划通过将问题分解为重叠子问题，并存储这些子问题的解（通常是在表格中），避免重复计算。例如，背包问题可以通过动态规划来解决，其中每个子问题表示在不超过背包容量的前提下，选择物品的组合方式。</li><li><strong>优势</strong>：动态规划避免了递归算法中的重复计算，通常能显著提高问题求解的效率。</li></ul></li><li><p><strong>问题八</strong>：解释贪心算法的工作原理，并给出一个使用贪心算法解决的问题示例，如硬币找零或任务调度。</p><ul><li><strong>解答</strong>：贪心算法在每一步选择当前看起来最优的选择，以期望这样的选择能导致全局最优解。例如，在硬币找零问题中，贪心算法会优先使用最大面额的硬币来减少硬币的总数。</li><li><strong>工作原理</strong>：贪心算法不保证总能得到全局最优解，但在某些问题上，如单源最短路径问题，贪心选择能产生最优解。</li></ul></li><li><p><strong>问题九</strong>：讨论算法复杂度分析的重要性，并给出一个分析示例，说明如何评估算法的效率。</p><ul><li><strong>解答</strong>：算法复杂度分析是评估算法效率的重要工具。它帮助我们理解和比较不同算法在不同输入规模下的性能。例如，对于排序算法，我们可以通过比较它们的时间复杂度来评估效率。</li></ul></li><li><p><strong>问题十</strong>：实现一个你认为比冒泡排序更高效的排序算法，并证明其时间复杂度更低。</p><ul><li><strong>解答</strong>：快速排序、归并排序或堆排序通常比冒泡排序更高效。例如，归并排序通过分治法将数组分成两半，递归排序后再合并，其时间复杂度为O(n log n)，比冒泡排序的O(n^2)要低。</li></ul></li></ol><p>通过详细解答这些问题，你将能够检验自己对算法基础知识的掌握程度，并加深对不同算法性能和适用性的理解。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>2.编程和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>编程和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构基础</title>
    <link href="/2024/06/21/%E5%85%B3%E5%8D%A12%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/06/21/%E5%85%B3%E5%8D%A12%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第二部分：编程和算法"><a href="#高级提示词工程师-第二部分：编程和算法" class="headerlink" title="高级提示词工程师| 第二部分：编程和算法"></a>高级提示词工程师| 第二部分：编程和算法</h1><h2 id="第二节：数据结构基础"><a href="#第二节：数据结构基础" class="headerlink" title="| 第二节：数据结构基础"></a>| 第二节：数据结构基础</h2><h3 id="知识点详解："><a href="#知识点详解：" class="headerlink" title="| 知识点详解："></a>| 知识点详解：</h3><ol><li><p><strong>列表（List）</strong></p><ul><li>列表可以存储任意类型的数据，包括数字、字符串、甚至其他列表。</li><li>列表是可变的，可以进行增加、删除、修改等操作。</li><li>列表索引从0开始。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 列表创建和基本操作</span><br>numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]  <span class="hljs-comment"># 创建列表</span><br>numbers.append(<span class="hljs-number">6</span>)          <span class="hljs-comment"># 添加元素到列表末尾</span><br>num = numbers.pop(<span class="hljs-number">0</span>)       <span class="hljs-comment"># 删除并返回列表首个元素</span><br>numbers.extend([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>])     <span class="hljs-comment"># 将一个列表添加到当前列表末尾</span><br><span class="hljs-built_in">print</span>(numbers)              <span class="hljs-comment"># [2, 3, 4, 5, 6, 7, 8]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>元组（Tuple）</strong></p><ul><li>元组与列表类似，但是一旦创建就不能修改。</li><li>元组通常用于保护数据不被改变。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 元组创建和不可变性质</span><br>coordinates = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)  <span class="hljs-comment"># 创建元组</span><br><span class="hljs-built_in">print</span>(coordinates)            <span class="hljs-comment"># (10, 20, 30)</span><br><span class="hljs-comment"># coordinates[0] = 15  # 这会抛出TypeError，元组是不可变的</span><br></code></pre></td></tr></table></figure></li><li><p><strong>字典（Dictionary）</strong></p><ul><li>字典以键值对的形式存储数据，其中键是唯一的。</li><li>字典是可变的，可以添加、删除或修改键值对。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 字典创建和操作</span><br>person = &#123;<br>    <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>    <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">25</span>,<br>    <span class="hljs-string">&#x27;job&#x27;</span>: <span class="hljs-string">&#x27;Engineer&#x27;</span><br>&#125;  <span class="hljs-comment"># 创建字典</span><br>person[<span class="hljs-string">&#x27;age&#x27;</span>] = <span class="hljs-number">26</span>  <span class="hljs-comment"># 修改键值对</span><br><span class="hljs-keyword">del</span> person[<span class="hljs-string">&#x27;job&#x27;</span>]  <span class="hljs-comment"># 删除键值对</span><br><span class="hljs-built_in">print</span>(person.get(<span class="hljs-string">&#x27;name&#x27;</span>))  <span class="hljs-comment"># &#x27;Alice&#x27;, 使用get方法访问键值</span><br></code></pre></td></tr></table></figure></li><li><p><strong>集合（Set）</strong></p><ul><li>集合是一个无序的不重复元素集。</li><li>集合可以进行数学上的集合操作，如并集、交集、差集。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 集合创建和基本操作</span><br>set1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>set2 = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>union_set = set1.union(set2)  <span class="hljs-comment"># &#123;1, 2, 3, 4, 5&#125;</span><br>intersection_set = set1.intersection(set2)  <span class="hljs-comment"># &#123;3&#125;</span><br>difference_set = set1.difference(set2)  <span class="hljs-comment"># &#123;1, 2&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>栈（Stack）</strong></p><ul><li>栈是一种后进先出（LIFO）的数据结构。</li><li>可以使用列表来实现栈。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 栈的实现</span><br>stack = []<br>stack.append(<span class="hljs-string">&#x27;a&#x27;</span>)  <span class="hljs-comment"># push(&#x27;a&#x27;)</span><br>stack.append(<span class="hljs-string">&#x27;b&#x27;</span>)  <span class="hljs-comment"># push(&#x27;b&#x27;)</span><br><span class="hljs-built_in">print</span>(stack.pop())  <span class="hljs-comment"># pop() -&gt; &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>队列（Queue）</strong></p><ul><li>队列是一种先进先出（FIFO）的数据结构。</li><li>可以使用<code>collections.deque</code>来高效实现队列。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br>queue = deque()<br>queue.append(<span class="hljs-string">&#x27;item1&#x27;</span>)  <span class="hljs-comment"># enqueue(&#x27;item1&#x27;)</span><br>queue.appendleft(<span class="hljs-string">&#x27;item0&#x27;</span>)  <span class="hljs-comment"># enqueue to the beginning</span><br><span class="hljs-built_in">print</span>(queue.pop())  <span class="hljs-comment"># dequeue() -&gt; &#x27;item1&#x27;</span><br><span class="hljs-built_in">print</span>(queue.popleft())  <span class="hljs-comment"># dequeue from the beginning -&gt; &#x27;item0&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="检验问题："><a href="#检验问题：" class="headerlink" title="检验问题："></a>检验问题：</h3><ol><li><p><strong>问题一</strong>：创建一个包含前10个自然数的平方的列表，并打印出来。</p></li><li><p><strong>问题二</strong>：给定一个包含重复元素的列表，如何使用集合去除重复元素？</p></li><li><p><strong>问题三</strong>：如何遍历字典，并打印出所有的键和值？</p></li><li><p><strong>问题四</strong>：如何检查一个元素是否存在于列表或字典中？</p></li><li><p><strong>问题五</strong>：如何实现一个栈的基本操作，包括压栈（push）、弹栈（pop），并打印栈顶元素？</p></li><li><p><strong>问题六</strong>：如何使用队列来实现一个打印任务的顺序执行，任务按照先来先服务的原则进行？</p></li><li><p><strong>问题七</strong>：如何使用字典来存储班级中学生的姓名和成绩，并打印出每个学生的姓名和对应的成绩？</p></li><li><p><strong>问题八</strong>：如何反转一个列表或元组？</p></li><li><p><strong>问题九</strong>：如何对列表中的元素进行排序？</p></li><li><p><strong>问题十</strong>：如何合并两个列表或字典，并处理键的冲突？</p></li></ol><p>通过解答这些问题，你将能够检验自己对Python数据结构的理解和应用能力。每个问题都设计有针对性，帮助你掌握不同数据结构的特点和适用场景。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>2.编程和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>编程和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程语言基础</title>
    <link href="/2024/06/21/%E5%85%B3%E5%8D%A11%EF%BC%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/06/21/%E5%85%B3%E5%8D%A11%EF%BC%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第二部分：编程和算法"><a href="#高级提示词工程师-第二部分：编程和算法" class="headerlink" title="高级提示词工程师| 第二部分：编程和算法"></a>高级提示词工程师| 第二部分：编程和算法</h1><h2 id="第一节：编程语言基础"><a href="#第一节：编程语言基础" class="headerlink" title="| 第一节：编程语言基础"></a>| 第一节：编程语言基础</h2><h3 id="知识点详解："><a href="#知识点详解：" class="headerlink" title="| 知识点详解："></a>| 知识点详解：</h3><ol><li><p><strong>Python语法基础</strong></p><ul><li>变量声明与使用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">10</span><br>b = <span class="hljs-number">20.5</span><br>name = <span class="hljs-string">&quot;Alice&quot;</span><br>is_valid = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure></li><li>基本数据类型：整数（int）、浮点数（float）、字符串（str）、布尔值（bool）</li></ul></li><li><p><strong>控制流</strong></p><ul><li>条件语句：if、elif、else<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">5</span><br><span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">10</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x is greater than 10&quot;</span>)<br><span class="hljs-keyword">elif</span> x &gt; <span class="hljs-number">5</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x is greater than 5 but not more than 10&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x is 5 or less&quot;</span>)<br></code></pre></td></tr></table></figure></li><li>循环语句：for循环、while循环<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(i)<br><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> condition:<br>    <span class="hljs-comment"># 循环体</span><br></code></pre></td></tr></table></figure></li><li>循环控制语句：break、continue</li></ul></li><li><p><strong>函数</strong></p><ul><li>函数定义：def关键字<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_function</span>(<span class="hljs-params">param1, param2</span>):<br>    <span class="hljs-comment"># 函数体</span><br></code></pre></td></tr></table></figure></li><li>参数传递</li><li>返回值：return语句<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>模块和包</strong></p><ul><li>导入模块：import语句<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>基本输入输出</strong></p><ul><li>输入函数：input()<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Enter your name: &quot;</span>)<br></code></pre></td></tr></table></figure></li><li>输出函数：print()<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, &quot;</span> + name)<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>注释</strong></p><ul><li>单行注释<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># This is a single-line comment</span><br></code></pre></td></tr></table></figure></li><li>多行注释<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;This is a</span><br><span class="hljs-string">multi-line comment&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>异常处理</strong></p><ul><li>异常捕获：try…except块<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 尝试执行的代码</span><br><span class="hljs-keyword">except</span> SomeException:<br>    <span class="hljs-comment"># 异常处理代码</span><br></code></pre></td></tr></table></figure></li><li>异常抛出：raise关键字</li></ul></li></ol><h3 id="检验问题："><a href="#检验问题：" class="headerlink" title="检验问题："></a>检验问题：</h3><ol><li><p><strong>问题一</strong>：请写出一个Python函数，该函数接收两个参数，分别是整数a和b，返回它们的和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-comment"># 测试函数</span><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 应该输出 8</span><br></code></pre></td></tr></table></figure></li><li><p><strong>问题二</strong>：如何使用for循环遍历一个字符串中的每个字符，并打印出来？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;Hello&quot;</span><br><span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:<br>    <span class="hljs-built_in">print</span>(char)<br></code></pre></td></tr></table></figure></li><li><p><strong>问题三</strong>：编写一个Python函数，该函数接收一个字符串作为参数，检查这个字符串是否是回文，如果是，则返回True，否则返回False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_palindrome</span>(<span class="hljs-params">s</span>):<br>    s = s.lower()  <span class="hljs-comment"># 转换为小写</span><br>    <span class="hljs-keyword">return</span> s == s[::-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 比较字符串和它的反转</span><br><br><span class="hljs-comment"># 测试函数</span><br><span class="hljs-built_in">print</span>(is_palindrome(<span class="hljs-string">&quot;Racecar&quot;</span>))  <span class="hljs-comment"># 应该输出 True</span><br></code></pre></td></tr></table></figure></li><li><p><strong>问题四</strong>：使用while循环实现一个猜数字游戏，程序随机生成一个1到10之间的整数，用户输入猜测的数字，程序提示用户猜得太高或太低，直到猜中为止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br>number = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>guess = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">while</span> guess != number:<br>    guess = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">f&quot;Guess the number between 1 and 10: &quot;</span>))<br>    <span class="hljs-keyword">if</span> guess &lt; number:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Too low, try again.&quot;</span>)<br>    <span class="hljs-keyword">elif</span> guess &gt; number:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Too high, try again.&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Congratulations! You guessed it right.&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>问题五</strong>：解释以下Python代码的功能，并指出它可能遇到的错误类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">divide</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x / y<br><br>result = divide(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 这里会抛出异常</span><br></code></pre></td></tr></table></figure><ul><li>功能：尝试将x除以y并返回结果。</li><li>可能的错误类型：<code>ZeroDivisionError</code>，因为除数为0。</li></ul></li><li><p><strong>问题六</strong>：如何导入Python的math模块，并使用它来计算一个数的平方根？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><br>number = <span class="hljs-number">16</span><br>square_root = math.sqrt(number)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;The square root of <span class="hljs-subst">&#123;number&#125;</span> is <span class="hljs-subst">&#123;square_root&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>问题七</strong>：在Python中，如何写一个注释来解释你的代码块的功能？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># This code block is responsible for calculating the factorial of a number.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> n * factorial(n-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li></ol><p>通过完成这些具体的代码案例和检验问题，你将能够巩固和检验你对Python编程基础的掌握程度。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>2.编程和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>编程和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程和算法总览</title>
    <link href="/2024/06/21/%E7%BC%96%E7%A8%8B%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <url>/2024/06/21/%E7%BC%96%E7%A8%8B%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第二部分：编程和算法"><a href="#高级提示词工程师-第二部分：编程和算法" class="headerlink" title="高级提示词工程师| 第二部分：编程和算法"></a>高级提示词工程师| 第二部分：编程和算法</h1><h2 id="编程和算法总览"><a href="#编程和算法总览" class="headerlink" title="| 编程和算法总览"></a>| 编程和算法总览</h2><h3 id="第一节：编程语言基础"><a href="#第一节：编程语言基础" class="headerlink" title="| 第一节：编程语言基础"></a>| 第一节：编程语言基础</h3><ul><li><strong>知识点</strong>：<ul><li>Python语法：变量、数据类型、控制流（if语句、循环）。</li><li>函数定义和调用。</li><li>基本输入输出操作。</li></ul></li><li><strong>检验问题</strong>：<ul><li>如何在Python中定义一个函数，并且给出一个交换两个变量值的函数示例？</li></ul></li></ul><h3 id="第二节：数据结构基础"><a href="#第二节：数据结构基础" class="headerlink" title="第二节：数据结构基础"></a>第二节：数据结构基础</h3><ul><li><strong>知识点</strong>：<ul><li>列表（List）、元组（Tuple）、字典（Dictionary）的操作。</li><li>集合（Set）的使用场景和操作。</li><li>栈（Stack）和队列（Queue）的概念。</li></ul></li><li><strong>检验问题</strong>：<ul><li>解释列表和元组的区别，并给出一个使用字典存储学生信息的例子。</li></ul></li></ul><h3 id="第三节：算法基础"><a href="#第三节：算法基础" class="headerlink" title="第三节：算法基础"></a>第三节：算法基础</h3><ul><li><strong>知识点</strong>：<ul><li>排序算法：冒泡排序、快速排序、归并排序。</li><li>搜索算法：线性搜索、二分搜索。</li><li>递归和迭代的概念。</li></ul></li><li><strong>检验问题</strong>：<ul><li>描述快速排序算法的逻辑，并说明它的时间复杂度。</li></ul></li></ul><h3 id="第四节：面向对象编程"><a href="#第四节：面向对象编程" class="headerlink" title="第四节：面向对象编程"></a>第四节：面向对象编程</h3><ul><li><strong>知识点</strong>：<ul><li>类（Class）和对象（Object）的概念。</li><li>构造函数和析构函数的使用。</li><li>继承（Inheritance）和多态（Polymorphism）。</li></ul></li><li><strong>检验问题</strong>：<ul><li>如何在Python中实现一个简单的类，并说明继承是如何工作的。</li></ul></li></ul><h3 id="第五节：高级编程技巧"><a href="#第五节：高级编程技巧" class="headerlink" title="第五节：高级编程技巧"></a>第五节：高级编程技巧</h3><ul><li><strong>知识点</strong>：<ul><li>异常处理机制。</li><li>列表推导式（List Comprehension）。</li><li>匿名函数（Lambda Function）和高阶函数。</li></ul></li><li><strong>检验问题</strong>：<ul><li>编写一个使用异常处理来捕获并处理除以零错误的代码示例。</li></ul></li></ul><h3 id="第六节：机器学习库熟悉"><a href="#第六节：机器学习库熟悉" class="headerlink" title="第六节：机器学习库熟悉"></a>第六节：机器学习库熟悉</h3><ul><li><strong>知识点</strong>：<ul><li>scikit-learn库的基本使用：数据集加载、模型训练、预测。</li><li>TensorFlow或PyTorch的基本操作：构建神经网络、前向传播、损失函数计算。</li></ul></li><li><strong>检验问题</strong>：<ul><li>如何使用scikit-learn库加载鸢尾花（Iris）数据集，并训练一个简单的分类器？</li></ul></li></ul><h3 id="第七节：实践项目"><a href="#第七节：实践项目" class="headerlink" title="第七节：实践项目"></a>第七节：实践项目</h3><ul><li><strong>项目任务</strong>：<ul><li>编写一个Python程序，实现一个推荐系统，使用协同过滤算法为用户推荐商品。</li><li>构建一个简单的神经网络，使用TensorFlow或PyTorch识别手写数字（MNIST数据集）。</li></ul></li><li><strong>检验问题</strong>：<ul><li>描述协同过滤算法的基本原理，并解释如何在你的推荐系统中实现它。</li><li>解释构建神经网络时，你如何选择层数和每层的神经元数量。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>2.编程和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>编程和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习方案和框架总览</title>
    <link href="/2024/06/21/%E6%88%90%E4%B8%BA%E9%AB%98%E7%BA%A7%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E5%92%8C%E6%A1%86%E6%9E%B6/"/>
    <url>/2024/06/21/%E6%88%90%E4%B8%BA%E9%AB%98%E7%BA%A7%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%E5%92%8C%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师"><a href="#高级提示词工程师" class="headerlink" title="高级提示词工程师"></a>高级提示词工程师</h1><h2 id="学习方案和框架"><a href="#学习方案和框架" class="headerlink" title="| 学习方案和框架"></a>| 学习方案和框架</h2><h3 id="1-基础理论学习"><a href="#1-基础理论学习" class="headerlink" title="| 1. 基础理论学习"></a>| 1. 基础理论学习</h3><ul><li><strong>目标</strong>：了解人工智能的基本概念、原理和应用。</li><li><strong>内容</strong>：<ul><li>人工智能历史和主要里程碑。</li><li>机器学习基础，包括监督学习、无监督学习、强化学习等。</li><li>深度学习基础，包括神经网络、卷积神经网络、循环神经网络等。</li></ul></li><li><strong>实践项目</strong>：完成在线课程或教程中的练习题和项目。</li></ul><h3 id="2-编程和算法"><a href="#2-编程和算法" class="headerlink" title="2. 编程和算法"></a>2. 编程和算法</h3><ul><li><strong>目标</strong>：掌握编程语言和算法实现，为构建AI模型打下基础。</li><li><strong>内容</strong>：<ul><li>学习Python或R等编程语言。</li><li>学习数据结构和算法。</li><li>熟悉机器学习库，如scikit-learn、TensorFlow、PyTorch。</li></ul></li><li><strong>实践项目</strong>：编写简单的机器学习模型，如线性回归、决策树。</li></ul><h3 id="3-数据处理和分析"><a href="#3-数据处理和分析" class="headerlink" title="3. 数据处理和分析"></a>3. 数据处理和分析</h3><ul><li><strong>目标</strong>：学会处理和分析数据，为模型训练准备数据集。</li><li><strong>内容</strong>：<ul><li>数据清洗、转换和特征工程。</li><li>数据可视化技术。</li><li>统计分析基础。</li></ul></li><li><strong>实践项目</strong>：使用真实数据集进行探索性数据分析和特征选择。</li></ul><h3 id="4-机器学习模型构建"><a href="#4-机器学习模型构建" class="headerlink" title="4. 机器学习模型构建"></a>4. 机器学习模型构建</h3><ul><li><strong>目标</strong>：学习构建和优化机器学习模型。</li><li><strong>内容</strong>：<ul><li>模型选择和评估。</li><li>过拟合和欠拟合问题。</li><li>模型调参和验证方法。</li></ul></li><li><strong>实践项目</strong>：构建一个分类或回归模型，并在数据集上进行训练和评估。</li></ul><h3 id="5-深度学习模型构建"><a href="#5-深度学习模型构建" class="headerlink" title="5. 深度学习模型构建"></a>5. 深度学习模型构建</h3><ul><li><strong>目标</strong>：深入学习深度学习模型的构建和优化。</li><li><strong>内容</strong>：<ul><li>深度学习架构，如CNN、RNN、GAN等。</li><li>深度学习中的正则化技术和优化算法。</li><li>迁移学习和微调。</li></ul></li><li><strong>实践项目</strong>：使用深度学习框架构建一个图像识别或自然语言处理模型。</li></ul><h3 id="6-提示词工程基础"><a href="#6-提示词工程基础" class="headerlink" title="6. 提示词工程基础"></a>6. 提示词工程基础</h3><ul><li><strong>目标</strong>：理解提示词在AI中的作用和重要性。</li><li><strong>内容</strong>：<ul><li>提示词的定义和分类。</li><li>如何设计有效的提示词。</li><li>提示词在不同AI应用中的作用。</li></ul></li><li><strong>实践项目</strong>：设计并测试针对特定任务的提示词。</li></ul><h3 id="7-高级提示词工程"><a href="#7-高级提示词工程" class="headerlink" title="7. 高级提示词工程"></a>7. 高级提示词工程</h3><ul><li><strong>目标</strong>：掌握高级提示词工程技巧，提升AI模型性能。</li><li><strong>内容</strong>：<ul><li>多模态学习与提示词。</li><li>强化学习中的提示词应用。</li><li>跨领域提示词设计。</li></ul></li><li><strong>实践项目</strong>：设计一个跨领域的AI系统，使用高级提示词技术提升性能。</li></ul><h3 id="8-伦理和社会责任"><a href="#8-伦理和社会责任" class="headerlink" title="8. 伦理和社会责任"></a>8. 伦理和社会责任</h3><ul><li><strong>目标</strong>：了解AI的伦理问题和社会责任。</li><li><strong>内容</strong>：<ul><li>AI伦理原则。</li><li>数据隐私和安全。</li><li>算法偏见和公平性。</li></ul></li><li><strong>实践项目</strong>：评估一个AI模型的伦理影响，并提出改进方案。</li></ul><h3 id="9-持续学习和社区参与"><a href="#9-持续学习和社区参与" class="headerlink" title="9. 持续学习和社区参与"></a>9. 持续学习和社区参与</h3><ul><li><strong>目标</strong>：保持对最新AI技术和趋势的了解。</li><li><strong>内容</strong>：<ul><li>阅读学术论文和行业报告。</li><li>参与开源项目和社区讨论。</li><li>参加相关的研讨会和会议。</li></ul></li><li><strong>实践项目</strong>：在GitHub上贡献代码或撰写技术博客。</li></ul><h3 id="10-专业发展和职业规划"><a href="#10-专业发展和职业规划" class="headerlink" title="10. 专业发展和职业规划"></a>10. 专业发展和职业规划</h3><ul><li><strong>目标</strong>：规划个人职业发展路径，成为领域专家。</li><li><strong>内容</strong>：<ul><li>了解行业需求和职业机会。</li><li>建立专业网络。</li><li>准备简历和面试技巧。</li></ul></li><li><strong>实践项目</strong>：创建个人品牌，如LinkedIn个人页面，参与行业竞赛。</li></ul><p>这个学习方案是一个持续的过程，需要你不断地实践、学习和反思。每个阶段的实践项目可以帮助你检验自己的学习成果，并为下一步的学习提供方向。记住，成为一个高级的提示词工程师不仅仅是学习技术，更重要的是理解如何将技术应用于解决实际问题。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>学习方案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础理论</title>
    <link href="/2024/06/21/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%95%85%E4%BA%8B%E7%89%88%EF%BC%89/"/>
    <url>/2024/06/21/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%95%85%E4%BA%8B%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第一部分：基础理论"><a href="#高级提示词工程师-第一部分：基础理论" class="headerlink" title="高级提示词工程师| 第一部分：基础理论"></a>高级提示词工程师| 第一部分：基础理论</h1><h2 id="基础理论总览"><a href="#基础理论总览" class="headerlink" title="| 基础理论总览"></a>| 基础理论总览</h2><h3 id="第一节：人工智能的起源"><a href="#第一节：人工智能的起源" class="headerlink" title="| 第一节：人工智能的起源"></a>| 第一节：人工智能的起源</h3><p>1943年，第二次世界大战的硝烟弥漫，世界正处于动荡之中。然而，在战争的阴影下，一场关于未来智能的革命正在悄然酝酿。艾伦·图灵，这位年轻的数学家和逻辑学家，正在英国布莱切利公园破解德国的恩尼格玛密码。他的工作不仅帮助盟军赢得了战争，也为他后来在人工智能领域的探索埋下了种子。</p><p>战争结束后，图灵回到学术界，开始思考机器能否具有智能的问题。他提出了著名的图灵测试，这是一个关于机器智能的哲学思考，也是对人工智能可能性的一种探索。图灵认为，如果一台机器能够与人类进行对话，并且在对话过程中让人类无法区分它是人类还是机器，那么这台机器就可以说具有智能。</p><p>1950年，图灵发表了一篇题为《计算机器与智能》的论文，提出了“机器能思考吗？”这个问题，并首次提出了“人工智能”这个概念。他的这些思想吸引了一批志同道合的科学家，包括后来的人工智能先驱马文·闵斯基和约翰·麦卡锡。</p><p>1956年夏天，麦卡锡在达特茅斯会议上首次正式使用了“人工智能”这个术语，并召集了一群对机器智能感兴趣的科学家。这次会议聚集了多位领域的先驱，包括图灵、闵斯基、纳撒尼尔·罗切斯特和克劳德·香农等。他们共同探讨了如何让机器模拟人类的学习和其他智能行为。</p><p>这次会议不仅是人工智能历史上的一个里程碑，也为后来的研究者提供了一个共同的出发点。尽管当时的技术条件有限，但他们的讨论和设想为人工智能的发展奠定了坚实的基础。</p><h3 id="第二节：机器学习的启蒙"><a href="#第二节：机器学习的启蒙" class="headerlink" title="第二节：机器学习的启蒙"></a>第二节：机器学习的启蒙</h3><p>随着20世纪中叶的到来，人工智能的种子开始在学术界的土壤中生根发芽。科学家们开始探索如何让机器模拟人类的学习过程，这是机器学习启蒙的开始。</p><p>在这个时代，监督学习成为了研究的焦点。监督学习是一种训练机器的方法，通过给定输入数据和对应的正确输出，让机器学习如何预测未知数据的输出。这个过程就像是教一个孩子识别苹果和橙子。你给孩子看许多苹果和橙子的图片，并告诉他们每张图片是什么，孩子通过这些例子学习如何区分两者。</p><p>科学家们利用这种方法训练机器识别图像、翻译语言、甚至预测天气。然而，这些早期的模型通常是基于简单的算法，比如线性回归或决策树，它们在处理复杂问题时能力有限。</p><p>在20世纪60年代和70年代，尽管计算机的计算能力有限，但机器学习的研究仍在持续进行。科学家们开始尝试更复杂的模型，如感知机（一种早期的神经网络模型），它们能够处理简单的图像识别任务。</p><p>然而，这些早期的尝试面临着许多挑战。数据集通常很小，计算资源昂贵，而且算法的复杂性限制了它们的应用范围。尽管如此，这些初步的探索为后来的突破奠定了基础。</p><p>到了20世纪80年代，随着计算机技术的进步和数据量的增加，机器学习开始进入一个新的阶段。科学家们开始使用更复杂的算法，如支持向量机（SVM）和随机森林，这些算法在某些任务上取得了显著的性能提升。</p><p>这一时期，机器学习的研究逐渐从理论走向实践，开始在实际问题中发挥作用。从医疗诊断到股市分析，机器学习的应用范围不断扩大，为人工智能的发展注入了新的活力。</p><h3 id="第三节：深度学习的觉醒"><a href="#第三节：深度学习的觉醒" class="headerlink" title="第三节：深度学习的觉醒"></a>第三节：深度学习的觉醒</h3><p>21世纪的曙光照耀在人工智能的田野上，唤醒了沉睡的巨人——深度学习。它不仅仅是技术的一次飞跃，更是对智能本质的一次深刻探索。</p><p>案例事件1：深度学习在视觉识别的突破<br>2012年，一个名为AlexNet的深度神经网络在ImageNet竞赛中一战成名。这个由多伦多大学的研究者们开发的模型，以其前所未有的准确率震惊了世界。它不仅在图像分类任务上超越了所有其他参赛者，更开启了深度学习在计算机视觉领域的新纪元。</p><p>案例事件2：深度学习在自然语言处理的应用<br>2013年，谷歌的研究人员开发了一种名为Word2Vec的模型，它能够将单词转换为向量，从而让计算机“理解”单词的含义。这一技术不仅推动了机器翻译和情感分析的发展，更在自然语言处理领域掀起了一场革命。</p><p>案例事件3：深度学习在艺术创作中的尝试<br>2015年，Google DeepMind的研究人员开发了一种名为DeepDream的算法，它能够将深度学习模型的内部表示可视化，创造出梦幻般的图像。这一技术不仅展示了深度学习模型的工作原理，更引发了艺术与科技结合的新思考。</p><p>案例事件4：深度学习在医疗领域的应用<br>2018年，斯坦福大学的研究团队开发了一种深度学习算法，它能够从皮肤病变的图像中诊断出皮肤癌，准确率高达91%。这一成果不仅提高了皮肤癌的早期诊断率，更为深度学习在医疗领域的应用开辟了新的道路。</p><p>深度学习的核心——人工神经网络，是由许多层次的神经元构成的复杂系统。这些网络能够自动学习数据中的模式，从而实现从图像识别到语言理解的多种智能任务。</p><p>随着计算能力的增强，尤其是GPU的广泛应用，深度学习模型变得更加强大。它们不仅能够识别图像中的物体，还能够理解自然语言、生成艺术作品，甚至在复杂的策略游戏中击败人类顶尖选手。</p><p>深度学习的兴起，不仅推动了大数据和算法的结合，也使得人工智能的应用范围不断扩大。从自动驾驶汽车到智能助手，从医疗诊断到股市分析，深度学习正在推动人工智能技术的快速发展和广泛应用。</p><p>现在，深度学习的故事仍在继续。它不仅仅是技术的革新，更是对智能本质的探索。随着技术的不断进步，深度学习将继续在各个领域创造新的奇迹。</p><h3 id="第四节：卷积神经网络的崛起"><a href="#第四节：卷积神经网络的崛起" class="headerlink" title="第四节：卷积神经网络的崛起"></a>第四节：卷积神经网络的崛起</h3><p>在深度学习的浪潮中，一种特殊类型的神经网络——卷积神经网络（CNN）——以其在图像和视频分析领域的卓越性能脱颖而出，成为了视觉计算的主力军。</p><p>案例事件1：自动驾驶的视觉感知<br>特斯拉公司在自动驾驶技术上的突破，部分归功于卷积神经网络的应用。这些网络能够识别道路标志、行人、其他车辆，甚至理解交通信号，为自动驾驶汽车提供了“视觉”。</p><p>案例事件2：社交媒体的图像过滤<br>Instagram和Facebook等社交媒体平台使用CNN来改善用户的图像体验。从自动标记图像中的人物到图像搜索功能，CNN在背后发挥着关键作用。</p><p>案例事件3：医学影像分析的进步<br>在医疗领域，卷积神经网络帮助医生分析X光片、CT扫描和MRI图像。例如，2017年的一项研究中，CNN被训练来检测和分类脑肿瘤，提高了诊断的准确性和效率。</p><p>案例事件4：视频监控的智能化<br>安全监控系统通过使用CNN来识别异常行为，如入侵者或火灾。这些系统能够实时分析视频流，及时警报潜在的安全威胁。</p><p>卷积神经网络之所以强大，是因为它们的结构能够有效地捕捉图像的局部特征并逐层构建更为复杂和抽象的特征表示。这种层次化的特征学习使得CNN在图像分类、目标检测和图像分割等任务上表现出色。</p><p>随着研究的深入和技术的发展，CNN已经成为许多视觉任务的首选模型。它们的成功应用不仅证明了深度学习在处理高维数据上的巨大潜力，也为未来的技术创新和应用开辟了新的道路。</p><p>深度学习的故事仍在继续，而卷积神经网络作为其中的关键角色，将继续在人工智能的舞台上发挥重要作用。随着技术的不断进步，我们可以期待CNN将在更多领域展现其强大的能力。</p><h3 id="第五节：循环神经网络的律动"><a href="#第五节：循环神经网络的律动" class="headerlink" title="第五节：循环神经网络的律动"></a>第五节：循环神经网络的律动</h3><p>在深度学习的宏伟交响乐中，循环神经网络（RNN）以其独特的节奏和韵律，为处理序列数据提供了和谐的旋律。RNN的核心在于其循环结构，这使得网络能够记住之前处理的信息，并利用这些信息来预测未来的数据。</p><p>案例事件1：语言模型的革新<br>在2010年代初，RNN及其变体，如长短期记忆网络（LSTM），开始在自然语言处理（NLP）领域取得显著进展。谷歌的研究人员使用RNN构建了更加准确的语言模型，这些模型能够预测文本序列中的下一个词，为机器翻译和文本生成打下了基础。</p><p>案例事件2：股市预测的尝试<br>金融市场的波动充满了不确定性，但RNN在捕捉时间序列数据中的模式方面显示出潜力。一些金融机构开始尝试使用RNN来分析历史数据，预测股票价格的走势。</p><p>案例事件3：音乐和艺术创作<br>RNN不仅能够处理语言，还能够创作音乐和艺术。2016年，DeepMind的研究人员开发了一种名为WaveNet的RNN模型，它能够生成逼真的自然声音和语音。此外，RNN也被用于生成抽象艺术作品，展现了人工智能在创意领域的潜力。</p><p>案例事件4：生物信息学的应用<br>在生物信息学领域，RNN被用来分析基因序列。通过识别DNA或蛋白质序列中的模式，RNN有助于预测基因的功能和蛋白质的结构，这对于疾病研究和药物设计具有重要意义。</p><p>循环神经网络之所以在序列数据上表现出色，是因为它们能够捕捉时间上的依赖关系。无论是在语言的连续性还是在股市的波动中，RNN都能够学习到数据随时间变化的内在规律。</p><p>随着深度学习技术的不断进步，RNN在各个领域的应用也在不断扩展。从文本分析到音乐创作，从生物信息学到金融市场预测，RNN正在以其独特的方式，为人工智能的世界增添更多的可能性。</p><h3 id="第六节：强化学习的冒险"><a href="#第六节：强化学习的冒险" class="headerlink" title="第六节：强化学习的冒险"></a>第六节：强化学习的冒险</h3><p>在人工智能的广袤领域中，强化学习以其独特的探索精神，引领着机器向着自主决策和问题解决的未知领域勇敢前行。</p><p>案例事件1：电子游戏的征服者<br>2013年，深度Q网络（Deep Q-Network, DQN）的诞生标志着强化学习在复杂任务上的重大突破。这个由DeepMind开发的算法首次成功地训练了一个人工智能体，在多种雅达利2600电子游戏中达到了超人的表现。</p><p>案例事件2：物流优化的革新<br>在物流行业，强化学习被用来优化复杂的调度和路径规划问题。通过模拟和奖励机制，强化学习算法能够学习如何在不断变化的环境中做出最优决策，从而提高物流效率和降低成本。</p><p>案例事件3：电网管理的智能<br>电力公司开始探索使用强化学习来管理电网，优化电力的生成、分配和消耗。这种算法能够预测需求变化，实时调整电力供应，以应对可再生能源的波动性和需求的不确定性。</p><p>案例事件4：自动驾驶的决策<br>在自动驾驶汽车的研发中，强化学习为车辆提供了在复杂交通环境中做出决策的能力。通过与环境的交互，自动驾驶系统能够学习如何在遵守交通规则的同时，安全高效地导航。</p><p>强化学习的核心在于智能体通过与环境的交互来学习最佳策略。智能体通过尝试不同的行动，并根据环境给予的奖励或惩罚来调整自己的行为，从而实现目标。</p><p>随着技术的发展，强化学习已经在游戏、机器人控制、资源管理等多个领域展现出其强大的潜力。它不仅能够处理简单的任务，还能够解决那些需要长期规划和复杂决策的问题。</p><p>强化学习的故事是关于探索、学习和适应的故事。随着算法的不断进步，我们可以期待它将在更多领域展现其独特的能力，为人工智能的发展开辟新的道路。</p><h3 id="第七节：人工智能的现代应用"><a href="#第七节：人工智能的现代应用" class="headerlink" title="第七节：人工智能的现代应用"></a>第七节：人工智能的现代应用</h3><p>随着深度学习、卷积神经网络、循环神经网络和强化学习等技术的成熟，人工智能已经从实验室的理论研究走向了现实世界，渗透到我们生活的每一个角落。</p><p>案例事件1：智能家居的兴起<br>亚马逊的Echo和谷歌的Nest等智能家居设备，利用人工智能进行语音识别和环境感知，让用户能够通过简单的语音命令控制家中的灯光、温度甚至安全系统。</p><p>案例事件2：个性化医疗的突破<br>IBM的Watson等人工智能系统通过分析大量的医疗记录和研究文献，辅助医生进行疾病诊断和治疗计划的制定，推动了个性化医疗的发展。</p><p>案例事件3：金融服务的变革<br>在金融领域，人工智能被用于风险管理、欺诈检测和算法交易。它能够分析复杂的市场数据，预测市场趋势，为投资者提供决策支持。</p><p>案例事件4：客户服务的自动化<br>许多公司开始使用聊天机器人来提供24&#x2F;7的客户服务。这些机器人能够理解客户的问题，并提供即时的反馈和解决方案，提高了服务效率和客户满意度。</p><p>人工智能的现代应用不仅限于提高效率和便利性，它还在帮助我们解决一些最紧迫的全球性问题，如气候变化、疾病流行和资源短缺。</p><p>案例事件5：环境监测与保护<br>使用卫星图像和人工智能算法，科学家们能够监测森林砍伐、野生动物种群和气候变化的影响，为环境保护提供数据支持。</p><p>案例事件6：教育个性化<br>在教育领域，人工智能技术被用来分析学生的学习习惯和表现，提供个性化的学习资源和教学计划，以适应每个学生的需求。</p><p>随着技术的不断进步，人工智能的应用范围还在不断扩大。它正在成为我们生活中不可或缺的一部分，帮助我们以前所未有的方式理解和改造世界。</p>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>1.基础理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>AI基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础理论知识题</title>
    <link href="/2024/06/21/%E9%AB%98%E7%BA%A7%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E9%A2%98/"/>
    <url>/2024/06/21/%E9%AB%98%E7%BA%A7%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="高级提示词工程师-第一部分：基础理论"><a href="#高级提示词工程师-第一部分：基础理论" class="headerlink" title="高级提示词工程师| 第一部分：基础理论"></a>高级提示词工程师| 第一部分：基础理论</h1><h2 id="基础理论知识题（10个）"><a href="#基础理论知识题（10个）" class="headerlink" title="| 基础理论知识题（10个）"></a>| 基础理论知识题（10个）</h2><h3 id="1-人工智能（AI）的概念最早是在-年的达特茅斯会议上提出的。"><a href="#1-人工智能（AI）的概念最早是在-年的达特茅斯会议上提出的。" class="headerlink" title="| 1. 人工智能（AI）的概念最早是在________年的达特茅斯会议上提出的。"></a>| 1. 人工智能（AI）的概念最早是在________年的达特茅斯会议上提出的。</h3><ul><li><strong>答案</strong>：1956  </li><li><strong>解释</strong>：1956年的达特茅斯会议上，人工智能作为一门新兴学科被正式提出，标志着人工智能领域的诞生。</li></ul><h3 id="2-在机器学习中，如果模型在训练集上表现很好，但在测试集上表现不佳，这通常被称为-。"><a href="#2-在机器学习中，如果模型在训练集上表现很好，但在测试集上表现不佳，这通常被称为-。" class="headerlink" title="2. 在机器学习中，如果模型在训练集上表现很好，但在测试集上表现不佳，这通常被称为________。"></a>2. 在机器学习中，如果模型在训练集上表现很好，但在测试集上表现不佳，这通常被称为________。</h3><ul><li><strong>答案</strong>：过拟合（overfitting）  </li><li><strong>解释</strong>：过拟合是指模型对训练数据学得太好，以至于失去了泛化能力，无法很好地处理新的、未见过的数据。</li></ul><h3 id="3-以下哪个选项是深度学习中常用的激活函数？"><a href="#3-以下哪个选项是深度学习中常用的激活函数？" class="headerlink" title="3. 以下哪个选项是深度学习中常用的激活函数？"></a>3. 以下哪个选项是深度学习中常用的激活函数？</h3><ul><li>A. Sigmoid</li><li>B. ReLU</li><li>C. Tanh</li><li>D. 所有上述选项</li><li><strong>答案</strong>：D. 所有上述选项  </li><li><strong>解释</strong>：Sigmoid、ReLU和Tanh都是深度学习中常用的激活函数，用于在神经网络中引入非线性，使模型能够学习和模拟更复杂的函数映射。</li></ul><h3 id="4-在监督学习中，我们通常使用-来评估模型的性能。"><a href="#4-在监督学习中，我们通常使用-来评估模型的性能。" class="headerlink" title="4. 在监督学习中，我们通常使用________来评估模型的性能。"></a>4. 在监督学习中，我们通常使用________来评估模型的性能。</h3><ul><li><strong>答案</strong>：准确率、精确度、召回率、F1分数、AUC-ROC等指标  </li><li><strong>解释</strong>：这些指标可以帮助我们了解模型在分类或回归任务上的表现，评估模型的准确性和泛化能力。</li></ul><h3 id="5-以下哪种类型的神经网络特别适合处理图像数据？"><a href="#5-以下哪种类型的神经网络特别适合处理图像数据？" class="headerlink" title="5. 以下哪种类型的神经网络特别适合处理图像数据？"></a>5. 以下哪种类型的神经网络特别适合处理图像数据？</h3><ul><li>A. 循环神经网络（RNN）</li><li>B. 卷积神经网络（CNN）</li><li>C. 深度信念网络（DBN）</li><li>D. 随机森林（Random Forest）</li><li><strong>答案</strong>：B. 卷积神经网络（CNN）  </li><li><strong>解释</strong>：卷积神经网络（CNN）通过卷积层自动提取图像中的关键特征，特别适合处理图像数据。</li></ul><h3 id="6-在深度学习中，-是一种用于防止过拟合的技术。"><a href="#6-在深度学习中，-是一种用于防止过拟合的技术。" class="headerlink" title="6. 在深度学习中，________是一种用于防止过拟合的技术。"></a>6. 在深度学习中，________是一种用于防止过拟合的技术。</h3><ul><li><strong>答案</strong>：正则化  </li><li><strong>解释</strong>：正则化通过在损失函数中添加一个额外的项，通常是模型参数的L1或L2范数，来惩罚模型的复杂度，从而避免模型对训练数据过度拟合。</li></ul><h3 id="7-以下哪个是深度学习框架之一？"><a href="#7-以下哪个是深度学习框架之一？" class="headerlink" title="7. 以下哪个是深度学习框架之一？"></a>7. 以下哪个是深度学习框架之一？</h3><ul><li>A. TensorFlow</li><li>B. PyTorch</li><li>C. Scikit-learn</li><li>D. NumPy</li><li><strong>答案</strong>：A. TensorFlow 和 B. PyTorch  </li><li><strong>解释</strong>：TensorFlow和PyTorch是两个流行的深度学习框架，提供了构建、训练和部署深度学习模型的工具和库。</li></ul><h3 id="8-在机器学习中，-是一种评估模型性能的方法，它将数据集分成训练集和测试集。"><a href="#8-在机器学习中，-是一种评估模型性能的方法，它将数据集分成训练集和测试集。" class="headerlink" title="8. 在机器学习中，________是一种评估模型性能的方法，它将数据集分成训练集和测试集。"></a>8. 在机器学习中，________是一种评估模型性能的方法，它将数据集分成训练集和测试集。</h3><ul><li><strong>答案</strong>：交叉验证  </li><li><strong>解释</strong>：交叉验证是一种评估模型泛化能力的方法，通过将数据集分成多个部分，然后使用其中的一部分作为测试集，其余部分作为训练集，来评估模型的性能。</li></ul><h3 id="9-以下哪个是自然语言处理（NLP）中的一个任务？"><a href="#9-以下哪个是自然语言处理（NLP）中的一个任务？" class="headerlink" title="9. 以下哪个是自然语言处理（NLP）中的一个任务？"></a>9. 以下哪个是自然语言处理（NLP）中的一个任务？</h3><ul><li>A. 图像分类</li><li>B. 文本分类</li><li>C. 语音识别</li><li>D. 所有上述选项</li><li><strong>答案</strong>：D. 所有上述选项  </li><li><strong>解释</strong>：图像分类属于计算机视觉领域，文本分类和语音识别是NLP的常见任务，语音识别可以将语音转换为文本，它们都可以视为NLP的交叉领域任务。</li></ul><h3 id="10-在深度学习中，-是一种优化算法，用于调整模型的权重以最小化损失函数。"><a href="#10-在深度学习中，-是一种优化算法，用于调整模型的权重以最小化损失函数。" class="headerlink" title="10. 在深度学习中，________是一种优化算法，用于调整模型的权重以最小化损失函数。"></a>10. 在深度学习中，________是一种优化算法，用于调整模型的权重以最小化损失函数。</h3><ul><li><strong>答案</strong>：梯度下降  </li><li><strong>解释</strong>：梯度下降通过计算损失函数对每个参数的梯度（即导数），然后更新参数以减少损失，这个过程在训练过程中不断重复，直到找到损失函数的最小值。</li></ul>]]></content>
    
    
    <categories>
      
      <category>高级提示词工程师</category>
      
      <category>学习方案</category>
      
      <category>1.基础理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级提示词工程师</tag>
      
      <tag>基础理论知识题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络调试知识点（20个）</title>
    <link href="/2024/06/14/20%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2024/06/14/20%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="常用网络调试命令"><a href="#常用网络调试命令" class="headerlink" title="常用网络调试命令"></a>常用网络调试命令</h1><h2 id="ping-用于测试主机之间的网络连通性。"><a href="#ping-用于测试主机之间的网络连通性。" class="headerlink" title="ping 用于测试主机之间的网络连通性。"></a>ping 用于测试主机之间的网络连通性。</h2><h3 id="1-ping"><a href="#1-ping" class="headerlink" title="1.ping"></a>1.ping</h3><pre><code class="hljs">    使用场景: 测试主机之间的网络连通性。    操作步骤: 打开命令行，输入 ping &lt;目标IP或域名&gt;。    例子: ping www.google.com    优点: 简单快速，能够快速检测网络连通性。    缺点: 无法提供网络延迟和丢包率的详细信息。</code></pre><h3 id="2-traceroute"><a href="#2-traceroute" class="headerlink" title="2.traceroute"></a>2.traceroute</h3><pre><code class="hljs">    使用场景: 追踪数据包到达目的地的路径。    操作步骤: 打开命令行，输入 traceroute &lt;目标IP或域名&gt;。    例子: traceroute www.google.com    优点: 显示经过的每个路由器和每个跳转的延迟。    缺点: 在某些网络中可能被防火墙阻止。</code></pre><h3 id="3-nslookup"><a href="#3-nslookup" class="headerlink" title="3.nslookup"></a>3.nslookup</h3><pre><code class="hljs">    使用场景: 查询DNS解析过程和结果。    操作步骤: 打开命令行，输入 nslookup &lt;域名&gt;。    例子: nslookup www.google.com    优点: 能够诊断DNS问题，查看IP地址和DNS服务器信息。    缺点: 需要用户了解DNS的工作原理。</code></pre><h3 id="4-netstat"><a href="#4-netstat" class="headerlink" title="4.netstat"></a>4.netstat</h3><pre><code class="hljs">    使用场景: 显示网络连接、端口使用情况和路由表。    操作步骤: 打开命令行，输入 netstat -an。    例子: netstat -an | findstr &quot;LISTENING&quot;    优点: 提供当前网络活动和端口使用情况的快照。    缺点: 输出信息可能非常多，需要过滤。</code></pre><h3 id="5-ipconfig-ifconfig"><a href="#5-ipconfig-ifconfig" class="headerlink" title="5.ipconfig &#x2F; ifconfig"></a>5.ipconfig &#x2F; ifconfig</h3><pre><code class="hljs">    使用场景: 显示或修改本地网络接口的配置。    操作步骤: 打开命令行，输入 ipconfig /all (Windows) 或 ifconfig (Linux)。    例子: ipconfig /all    优点: 显示所有网络接口的详细信息。    缺点: Windows和Linux命令不同，输出格式不同。</code></pre><h3 id="6-ssh"><a href="#6-ssh" class="headerlink" title="6.ssh"></a>6.ssh</h3><pre><code class="hljs">    使用场景: 安全地访问远程服务器。    操作步骤: 打开命令行，输入 ssh &lt;用户名&gt;@&lt;远程主机IP&gt;。    例子: ssh user@example.com    优点: 加密连接，安全访问远程服务器。    缺点: 需要远程服务器配置SSH服务。</code></pre><h3 id="7-curl"><a href="#7-curl" class="headerlink" title="7.curl"></a>7.curl</h3><pre><code class="hljs">    使用场景: 传输数据，测试HTTP请求。    操作步骤: 打开命令行，输入 curl &lt;URL&gt;。    例子: curl -I http://example.com    优点: 支持多种协议，能够发送复杂的HTTP请求。    缺点: 需要一定的命令行选项知识。</code></pre><h3 id="8-scp"><a href="#8-scp" class="headerlink" title="8.scp"></a>8.scp</h3><pre><code class="hljs">    使用场景: 安全地在本地和远程服务器之间复制文件。    操作步骤: 打开命令行，输入 scp &lt;本地文件路径&gt; &lt;用户名&gt;@&lt;远程主机IP&gt;:&lt;远程路径&gt;。    例子: scp /local/file.txt user@example.com:/remote/directory    优点: 使用SSH加密文件传输。    缺点: 需要远程服务器配置SSH服务。</code></pre><h3 id="9-nmap"><a href="#9-nmap" class="headerlink" title="9.nmap"></a>9.nmap</h3><pre><code class="hljs">    使用场景: 网络发现和安全审计。    操作步骤: 打开命令行，输入 nmap &lt;目标IP或网络范围&gt;。    例子: nmap -sP 192.168.1.0/24    优点: 强大的网络扫描工具，能够发现活跃主机和开放端口。    缺点: 扫描可能被网络防火墙或入侵检测系统检测到。</code></pre><h3 id="10-telnet"><a href="#10-telnet" class="headerlink" title="10.telnet"></a>10.telnet</h3><pre><code class="hljs">    使用场景: 测试远程系统的端口是否开放。    操作步骤: 打开命令行，输入 telnet &lt;目标IP&gt; &lt;端口号&gt;。    例子: telnet example.com 80    优点: 简单快速地测试端口连通性。    缺点: 不加密，不安全，已被SSH和更现代的工具取代。</code></pre><h3 id="11-arp"><a href="#11-arp" class="headerlink" title="11.arp"></a>11.arp</h3><pre><code class="hljs">    使用场景: 查看和操作ARP缓存表。    操作步骤: 打开命令行，输入 arp -a。    例子: arp -a    优点: 能够查看IP地址与MAC地址的映射。    缺点: 无法修改ARP表，只读。</code></pre><h3 id="12-route-ip-route"><a href="#12-route-ip-route" class="headerlink" title="12.route &#x2F; ip route"></a>12.route &#x2F; ip route</h3><pre><code class="hljs">    使用场景: 显示或修改网络路由表。    操作步骤: 打开命令行，输入 route print (Windows) 或 ip route show (Linux)。    例子: route print    优点: 显示当前网络路由信息。    缺点: 命令在不同操作系统中有所不同。</code></pre><h3 id="13-host"><a href="#13-host" class="headerlink" title="13..host"></a>13..host</h3><pre><code class="hljs">    使用场景: 查询DNS记录。    操作步骤: 打开命令行，输入 host &lt;域名&gt;。    例子: host www.google.com    优点: 简单易用，能够查询多种类型的DNS记录。    缺点: 功能没有 nslookup 和 dig 强大。</code></pre><h3 id="14-whois"><a href="#14-whois" class="headerlink" title="14..whois"></a>14..whois</h3><pre><code class="hljs">    使用场景: 查询域名或IP地址的注册信息。    操作步骤: 打开命令行，输入 whois &lt;域名或IP&gt;。    例子: whois google.com    优点: 提供域名注册和IP分配的详细信息。    缺点: 输出信息可能非常长。</code></pre><h3 id="15-tcpdump"><a href="#15-tcpdump" class="headerlink" title="15..tcpdump"></a>15..tcpdump</h3><pre><code class="hljs">    使用场景: 捕获和分析网络流量。    操作步骤: 打开命令行，输入 tcpdump -i &lt;接口&gt;。    例子: tcpdump -i eth0    优点: 强大的包分析工具，能够捕获和过滤网络流量。    缺点: 输出信息复杂，需要专业知识来分析。</code></pre><h3 id="16-wireshark"><a href="#16-wireshark" class="headerlink" title="16.wireshark"></a>16.wireshark</h3><pre><code class="hljs">    使用场景: 可视化地捕获和分析网络流量。    操作步骤: 打开Wireshark程序，选择网络接口，开始捕获。    例子: 捕获所有通过eth0接口的流量。    优点: 图形界面，易于使用和分析。    缺点: 需要安装软件，可能对新手来说学习曲线陡峭。</code></pre><h3 id="17-mtr"><a href="#17-mtr" class="headerlink" title="17.mtr"></a>17.mtr</h3><pre><code class="hljs">    使用场景: 综合了traceroute和ping的功能，持续监控网络延迟。    操作步骤: 打开命令行，输入 mtr &lt;目标IP或域名&gt;。    例子: mtr -r www.google.com    优点: 实时显示网络延迟和丢包情况。    缺点: 需要安装mtr工具。</code></pre><h3 id="18-ssh-keygen"><a href="#18-ssh-keygen" class="headerlink" title="18.ssh-keygen"></a>18.ssh-keygen</h3><pre><code class="hljs">    使用场景: 生成SSH密钥对，用于无密码SSH登录。    操作步骤: 打开命令行，输入 ssh-keygen -t rsa。    例子: ssh-keygen -t rsa -b 4096    优点: 生成的密钥可以用于安全地无密码登录SSH服务器。    缺点: 需要配置公钥和私钥。</code></pre><h3 id="19-iptables"><a href="#19-iptables" class="headerlink" title="19.iptables"></a>19.iptables</h3><pre><code class="hljs">    使用场景: Linux防火墙规则设置。    操作步骤: 打开命令行，输入 iptables -L 查看规则。    例子: iptables -A INPUT -p tcp --dport 22 -j ACCEPT    优点: 功能强大，可以定制复杂的防火墙规则。    缺点: 配置复杂，错误配置可能导致网络不可用。</code></pre><h3 id="20-nbtstat"><a href="#20-nbtstat" class="headerlink" title="20.nbtstat"></a>20.nbtstat</h3><pre><code class="hljs">    使用场景: 显示基于NetBIOS的TCP/IP 统计信息，常用于Windows网络调试。    操作步骤: 打开命令行，输入 nbtstat -n。    例子: nbtstat -n    优点: 显示本地NetBIOS名称表和远程机器的NetBIOS名称。    缺点: 主要用于Windows环境，Linux用户可能不常用。</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程技能</category>
      
      <category>网络调试命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络调试命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows10常用操作（20个）</title>
    <link href="/2024/06/14/20%E4%B8%AA%E5%B8%B8%E7%94%A8windows10%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2024/06/14/20%E4%B8%AA%E5%B8%B8%E7%94%A8windows10%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="Windows10-常用cmd命令"><a href="#Windows10-常用cmd命令" class="headerlink" title="Windows10 常用cmd命令"></a>Windows10 常用cmd命令</h2><h3 id="1-命令提示符（CMD）"><a href="#1-命令提示符（CMD）" class="headerlink" title="1.命令提示符（CMD）"></a>1.命令提示符（CMD）</h3><p>命令提示: cmd<br>例子: 查看当前路径<br>操作步骤: 打开命令提示符，输入cd，然后按回车键。</p><h3 id="2-PowerShell"><a href="#2-PowerShell" class="headerlink" title="2.PowerShell"></a>2.PowerShell</h3><p>命令提示: powershell<br>例子: 列出当前目录下的所有文件和文件夹<br>操作步骤: 打开PowerShell，输入Get-ChildItem，然后按回车键。</p><h3 id="3-注册表编辑器"><a href="#3-注册表编辑器" class="headerlink" title="3.注册表编辑器"></a>3.注册表编辑器</h3><p>命令提示: regedit<br>例子: 修改默认的浏览器<br>操作步骤: 打开注册表编辑器，导航到HKEY_CLASSES_ROOT\http\shell\open\command，修改默认浏览器的路径。</p><h3 id="4-任务管理器"><a href="#4-任务管理器" class="headerlink" title="4.任务管理器"></a>4.任务管理器</h3><p>命令提示: taskmgr<br>例子: 结束一个正在运行的进程<br>操作步骤: 打开任务管理器，找到要结束的进程，右键点击选择“结束任务”。</p><h3 id="5-系统配置"><a href="#5-系统配置" class="headerlink" title="5.系统配置"></a>5.系统配置</h3><p>命令提示: msconfig<br>例子: 禁用系统启动时的某些服务<br>操作步骤: 打开系统配置，切换到“服务”标签页，选中要禁用的服务，点击“禁用”按钮。</p><h3 id="6-设备管理器"><a href="#6-设备管理器" class="headerlink" title="6.设备管理器"></a>6.设备管理器</h3><p>命令提示: devmgmt.msc<br>例子: 更新网络适配器的驱动程序<br>操作步骤: 打开设备管理器，找到网络适配器，右键点击选择“更新驱动程序”。</p><h3 id="7-磁盘管理"><a href="#7-磁盘管理" class="headerlink" title="7.磁盘管理"></a>7.磁盘管理</h3><p>命令提示: diskmgmt.msc<br>例子: 创建新的分区<br>操作步骤: 打开磁盘管理，右键点击未分配的空间，选择“新建简单卷”，按照向导完成分区创建。</p><h3 id="8-服务"><a href="#8-服务" class="headerlink" title="8.服务"></a>8.服务</h3><p>命令提示: services.msc<br>例子: 启动或停止Windows更新服务<br>操作步骤: 打开服务，找到“Windows Update”，右键点击选择“启动”或“停止”。</p><h3 id="9-本地组策略编辑器"><a href="#9-本地组策略编辑器" class="headerlink" title="9.本地组策略编辑器"></a>9.本地组策略编辑器</h3><p>命令提示: gpedit.msc<br>例子: 禁止用户安装软件<br>操作步骤: 打开本地组策略编辑器，导航到用户配置\管理模板\系统，找到“只运行许可的Windows应用程序”，启用此策略并添加不允许的应用程序。</p><h3 id="10-事件查看器"><a href="#10-事件查看器" class="headerlink" title="10.事件查看器"></a>10.事件查看器</h3><p>命令提示: eventvwr.msc<br>例子: 查看系统日志<br>操作步骤: 打开事件查看器，展开“Windows 日志”，点击“系统”，查看系统相关事件。</p><h3 id="11-性能监视器"><a href="#11-性能监视器" class="headerlink" title="11.性能监视器"></a>11.性能监视器</h3><p>命令提示: perfmon.msc<br>例子: 监控CPU使用率<br>操作步骤: 打开性能监视器，点击“添加计数器”，选择“CPU”，添加“%处理器时间”计数器。</p><h3 id="12-资源监视器"><a href="#12-资源监视器" class="headerlink" title="12.资源监视器"></a>12.资源监视器</h3><p>命令提示: resmon.exe<br>例子: 查看磁盘活动<br>操作步骤: 打开资源监视器，切换到“磁盘”标签页，查看当前磁盘读写活动。</p><h3 id="13-网络连接"><a href="#13-网络连接" class="headerlink" title="13.网络连接"></a>13.网络连接</h3><p>命令提示: ncpa.cpl<br>例子: 配置网络适配器的IP地址<br>操作步骤: 打开网络连接，右键点击网络适配器，选择“属性”，双击“Internet 协议版本 4 (TCP&#x2F;IPv4)”，手动设置IP地址。</p><h3 id="14-系统信息"><a href="#14-系统信息" class="headerlink" title="14.系统信息"></a>14.系统信息</h3><p>命令提示: msinfo32<br>例子: 查看系统启动日志<br>操作步骤: 打开系统信息，点击“系统摘要”，在“启动程序”中查看启动日志。</p><h3 id="15-控制面板"><a href="#15-控制面板" class="headerlink" title="15.控制面板"></a>15.控制面板</h3><p>命令提示: 无特定命令提示，可通过搜索或control<br>例子: 更改系统语言设置<br>操作步骤: 打开控制面板，选择“时钟、语言和区域”，点击“更改语言偏好设置”，添加或更改系统语言。</p><h3 id="16-系统文件检查器"><a href="#16-系统文件检查器" class="headerlink" title="16.系统文件检查器"></a>16.系统文件检查器</h3><p>命令提示: sfc &#x2F;scannow<br>例子: 扫描并修复系统文件<br>操作步骤: 打开命令提示符（以管理员身份），输入sfc &#x2F;scannow，等待扫描和修复完成。</p><h3 id="17-磁盘清理工具"><a href="#17-磁盘清理工具" class="headerlink" title="17.磁盘清理工具"></a>17.磁盘清理工具</h3><p>命令提示: cleanmgr<br>例子: 清理系统临时文件<br>操作步骤: 打开磁盘清理工具，选择驱动器，点击“清理系统文件”，选择要删除的文件类型。</p><h3 id="18-系统还原"><a href="#18-系统还原" class="headerlink" title="18.系统还原"></a>18.系统还原</h3><p>命令提示: rstrui<br>例子: 还原系统到之前的状态<br>操作步骤: 打开控制面板，选择“系统和安全”，点击“系统”，选择“系统还原”，选择还原点，然后按照向导操作。</p><h3 id="19-远程桌面连接"><a href="#19-远程桌面连接" class="headerlink" title="19.远程桌面连接"></a>19.远程桌面连接</h3><p>命令提示: mstsc<br>例子: 连接到远程计算机<br>操作步骤: 打开远程桌面连接，输入远程计算机的IP地址，点击“连接”，输入凭据后登录。</p><h3 id="20-Windows安全中心"><a href="#20-Windows安全中心" class="headerlink" title="20.Windows安全中心"></a>20.Windows安全中心</h3><p>命令提示: 无特定命令提示，可通过搜索或wsappx.exe<br>例子: 检查Windows更新<br>操作步骤: 打开Windows安全中心，点击“病毒和威胁防护”，点击“检查更新”，确保防病毒定义是最新的。</p>]]></content>
    
    
    <categories>
      
      <category>windows10常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows10常用操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>问题解决模型（12个）</title>
    <link href="/2024/06/14/%E4%B8%96%E7%95%8C%E4%B8%8A%E5%B9%BF%E6%B3%9B%E8%AE%A4%E5%8F%AF%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/06/14/%E4%B8%96%E7%95%8C%E4%B8%8A%E5%B9%BF%E6%B3%9B%E8%AE%A4%E5%8F%AF%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="问题解决模型"><a href="#问题解决模型" class="headerlink" title="问题解决模型"></a>问题解决模型</h2><h2 id="1-杜威问题解决模式-Dewey’s-Problem-Solving-Model"><a href="#1-杜威问题解决模式-Dewey’s-Problem-Solving-Model" class="headerlink" title="1. 杜威问题解决模式 (Dewey’s Problem Solving Model)"></a>1. 杜威问题解决模式 (Dewey’s Problem Solving Model)</h2><ul><li><strong>What</strong>: 一种系统性的问题解决方法</li><li><strong>Who</strong>: 适用于个人和团队</li><li><strong>When</strong>: 面对需要逐步解决的复杂问题</li><li><strong>Where</strong>: 教育、商业、日常生活等</li><li><strong>Why</strong>: 促进深入分析和逐步解决方案的形成</li><li><strong>How</strong>: 通过五个阶段：发现问题、明确问题、提出假设、推理、验证</li></ul><h2 id="2-思维模型-Thinking-Models"><a href="#2-思维模型-Thinking-Models" class="headerlink" title="2. 思维模型 (Thinking Models)"></a>2. 思维模型 (Thinking Models)</h2><ul><li><strong>What</strong>: 多种促进创新和多角度思考的模型</li><li><strong>Who</strong>: 适用于需要创新思维的个人和团队</li><li><strong>When</strong>: 解决需要新观点和方法的问题</li><li><strong>Where</strong>: 商业策略、产品设计、日常生活决策</li><li><strong>Why</strong>: 激发创新思维和全面分析</li><li><strong>How</strong>: 应用不同的思维框架，如能力圈、思想实验等</li></ul><h2 id="3-麦肯锡问题解决模型-McKinsey-Problem-Solving-Model"><a href="#3-麦肯锡问题解决模型-McKinsey-Problem-Solving-Model" class="headerlink" title="3. 麦肯锡问题解决模型 (McKinsey Problem Solving Model)"></a>3. 麦肯锡问题解决模型 (McKinsey Problem Solving Model)</h2><ul><li><strong>What</strong>: 一种快速识别问题核心的模型</li><li><strong>Who</strong>: 主要用于管理咨询</li><li><strong>When</strong>: 需要迅速找到问题解决方案</li><li><strong>Where</strong>: 商业环境、战略规划</li><li><strong>Why</strong>: 提高解决问题的效率</li><li><strong>How</strong>: 通过结构化的方法快速定位问题并制定策略</li></ul><h2 id="4-批判性思维模型-Critical-Thinking-Models"><a href="#4-批判性思维模型-Critical-Thinking-Models" class="headerlink" title="4. 批判性思维模型 (Critical Thinking Models)"></a>4. 批判性思维模型 (Critical Thinking Models)</h2><ul><li><strong>What</strong>: 促进深入分析和评估的思维模型</li><li><strong>Who</strong>: 适用于学术研究、教育和个人发展</li><li><strong>When</strong>: 面对需要深度分析的信息或论点</li><li><strong>Where</strong>: 学术讨论、辩论、研究</li><li><strong>Why</strong>: 培养深入理解和评估的能力</li><li><strong>How</strong>: 通过苏格拉底方法和反省性思维进行分析</li></ul><h2 id="5-系统思维模型-Systems-Thinking-Model"><a href="#5-系统思维模型-Systems-Thinking-Model" class="headerlink" title="5. 系统思维模型 (Systems Thinking Model)"></a>5. 系统思维模型 (Systems Thinking Model)</h2><ul><li><strong>What</strong>: 考虑问题所有方面的相互关系</li><li><strong>Who</strong>: 适用于需要系统视角的决策者</li><li><strong>When</strong>: 解决涉及多个组成部分的复杂问题</li><li><strong>Where</strong>: 环境科学、商业管理、城市规划</li><li><strong>Why</strong>: 理解各部分如何相互作用影响整体</li><li><strong>How</strong>: 通过分析系统内各元素的相互作用</li></ul><h2 id="6-六顶思考帽-Six-Thinking-Hats"><a href="#6-六顶思考帽-Six-Thinking-Hats" class="headerlink" title="6. 六顶思考帽 (Six Thinking Hats)"></a>6. 六顶思考帽 (Six Thinking Hats)</h2><ul><li><strong>What</strong>: 多角度思考问题的方法</li><li><strong>Who</strong>: 团队成员或个人</li><li><strong>When</strong>: 需要全面分析问题时</li><li><strong>Where</strong>: 会议、创意发想、决策制定</li><li><strong>Why</strong>: 促进全面和平衡的讨论</li><li><strong>How</strong>: 通过不同角度的”帽子”来探索问题</li></ul><h2 id="7-SWOT分析-SWOT-Analysis"><a href="#7-SWOT分析-SWOT-Analysis" class="headerlink" title="7. SWOT分析 (SWOT Analysis)"></a>7. SWOT分析 (SWOT Analysis)</h2><ul><li><strong>What</strong>: 评估内部优势、劣势和外部机会、威胁</li><li><strong>Who</strong>: 适用于组织和个人的战略规划</li><li><strong>When</strong>: 制定策略或评估项目</li><li><strong>Where</strong>: 商业、教育、个人发展</li><li><strong>Why</strong>: 识别关键因素以制定有效策略</li><li><strong>How</strong>: 分析Strengths、Weaknesses、Opportunities、Threats</li></ul><h2 id="8-PDCA-Plan-Do-Check-Act"><a href="#8-PDCA-Plan-Do-Check-Act" class="headerlink" title="8. PDCA (Plan-Do-Check-Act)"></a>8. PDCA (Plan-Do-Check-Act)</h2><ul><li><strong>What</strong>: 迭代的持续改进循环</li><li><strong>Who</strong>: 适用于需要持续改进的组织和个人</li><li><strong>When</strong>: 任何需要改进流程或产品的情况</li><li><strong>Where</strong>: 质量管理、生产、服务</li><li><strong>Why</strong>: 实现持续改进和适应变化</li><li><strong>How</strong>: 通过计划、执行、检查、行动的循环</li></ul><h2 id="9-5W1H分析法"><a href="#9-5W1H分析法" class="headerlink" title="9. 5W1H分析法"></a>9. 5W1H分析法</h2><ul><li><strong>What</strong>: 基本问题的澄清方法</li><li><strong>Who</strong>: 适用于需要初步问题识别的任何人</li><li><strong>When</strong>: 问题定义和信息收集阶段</li><li><strong>Where</strong>: 调查、研究、初步规划</li><li><strong>Why</strong>: 确保全面理解问题</li><li><strong>How</strong>: 回答What、Who、When、Where、Why、How</li></ul><h2 id="10-鱼骨图-Cause-and-Effect-Diagram-Ishikawa-Diagram"><a href="#10-鱼骨图-Cause-and-Effect-Diagram-Ishikawa-Diagram" class="headerlink" title="10. 鱼骨图 (Cause and Effect Diagram, Ishikawa Diagram)"></a>10. 鱼骨图 (Cause and Effect Diagram, Ishikawa Diagram)</h2><ul><li><strong>What</strong>: 识别问题原因并分类的图形工具</li><li><strong>Who</strong>: 质量控制团队、问题解决小组</li><li><strong>When</strong>: 需要识别问题根本原因</li><li><strong>Where</strong>: 制造业、服务行业、项目管理</li><li><strong>Why</strong>: 帮助系统性地识别和解决问题原因</li><li><strong>How</strong>: 通过图形化表示原因和效果的关系</li></ul><h2 id="11-SMART原则"><a href="#11-SMART原则" class="headerlink" title="11. SMART原则"></a>11. SMART原则</h2><ul><li><strong>What</strong>: 设定具体、可测量、可达成、相关、时限的目标</li><li><strong>Who</strong>: 适用于需要目标导向的个人和团队</li><li><strong>When</strong>: 目标设定和项目管理</li><li><strong>Where</strong>: 工作场所、教育、个人生活</li><li><strong>Why</strong>: 提高目标的可实现性和追踪性</li><li><strong>How</strong>: 确保目标满足SMART标准</li></ul><h2 id="12-七步问题解决法-Seven-Steps-Problem-Solving"><a href="#12-七步问题解决法-Seven-Steps-Problem-Solving" class="headerlink" title="12. 七步问题解决法 (Seven Steps Problem Solving)"></a>12. 七步问题解决法 (Seven Steps Problem Solving)</h2><ul><li><strong>What</strong>: 结构化的问题解决过程</li><li><strong>Who</strong>: 适用于需要系统性解决方案的个人和团队</li><li><strong>When</strong>: 面对需要深入分析和解决的问题</li><li><strong>Where</strong>: 工作场所、学术研究、日常生活</li><li><strong>Why</strong>: 提供清晰的解决问题的步骤</li><li><strong>How</strong>: 通过定义、分析、生成方案、选择、计划、执行、评估的步骤</li></ul>]]></content>
    
    
    <categories>
      
      <category>问题解决模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题解决模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用工具链接</title>
    <link href="/2024/06/14/%E5%B7%A5%E4%BD%9C%E7%BD%91%E5%9D%80%E6%94%B6%E8%97%8F%E5%A4%B9/"/>
    <url>/2024/06/14/%E5%B7%A5%E4%BD%9C%E7%BD%91%E5%9D%80%E6%94%B6%E8%97%8F%E5%A4%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="常用工具链接"><a href="#常用工具链接" class="headerlink" title="常用工具链接"></a>常用工具链接</h2><ol><li><p><a href="https://www.drawio.com/">在线画流程图</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://www.drawio.com/<br></code></pre></td></tr></table></figure></li><li><p><a href="https://www.testdatagen.com/loginSelectType.html">SQL数据在线生成</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://www.testdatagen.com/loginSelectType.html<br></code></pre></td></tr></table></figure></li><li><p><a href="https://www.bandwidthplace.com/">网络在线测速</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://www.bandwidthplace.com/<br></code></pre></td></tr></table></figure></li><li><p><a href="https://sspai.com/post/88863">用Twinkle Tray，为你的台式机显示器调节亮度</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://sspai.com/post/88863<br></code></pre></td></tr></table></figure></li><li><p><a href="https://kimi.moonshot.cn/chat/">国内文本类AI</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://kimi.moonshot.cn/chat/<br></code></pre></td></tr></table></figure></li><li><p><a href="https://manual.winmerge.org/en/">WinMerge文件对比工具使用手册</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://manual.winmerge.org/en/<br></code></pre></td></tr></table></figure></li><li><p><a href="https://blog.csdn.net/billycoder/article/details/88987010">组装电脑详细图文步骤</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://blog.csdn.net/billycoder/article/details/88987010<br></code></pre></td></tr></table></figure></li><li><p><a href="https://www.zhihu.com/tardis/zm/art/92590262?source_id=1005">SQL 在线练习平台</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://www.zhihu.com/tardis/zm/art/92590262?source_id=1005<br></code></pre></td></tr></table></figure></li><li><p><a href="https://github.com/chengaopan/AutoMergePublicNodes?tab=readme-ov-file">节点配置文件会更新</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://github.com/chengaopan/AutoMergePublicNodes?tab=readme-ov-file<br>https://github.com/barry-far/V2ray-Configs?tab=readme-ov-file<br>https://github.com/mahdibland/V2RayAggregator?tab=readme-ov-file<br></code></pre></td></tr></table></figure></li><li><p><a href="https://www.fast-report.com/public_download/docs/FRNet/online/en/UserManual/en-US/DataBand/DynamicLayout/DynamicLayout_GrowToBottom.html">fastreport使用手册</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://www.fast-report.com/public_download/docs/FRNet/online/en/UserManual/en-US/DataBand/DynamicLayout/DynamicLayout_GrowToBottom.html<br></code></pre></td></tr></table></figure></li><li><p><a href="https://fliphtml5.com/dlbeq/qywp/basic">在线阅读或导出电子书</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://fliphtml5.com/dlbeq/qywp/basic<br></code></pre></td></tr></table></figure></li><li><p><a href="https://blog.csdn.net/chilemao/article/details/135594981">Windows Server 2016 安装图解</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://blog.csdn.net/chilemao/article/details/135594981<br></code></pre></td></tr></table></figure></li><li><p><a href="https://support.hp.com/cn-zh/product/setup-user-guides/hp-laser-100-printer-series/24494339">HP 100 激光打印机系列</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://support.hp.com/cn-zh/product/setup-user-guides/hp-laser-100-printer-series/24494339<br></code></pre></td></tr></table></figure></li><li><p><a href="extension://bfdogplmndidlpjfhoijckpakkdjkkil/pdf/viewer.html?file=https%3A%2F%2Fwww.zebra.cn%2Fcontent%2Fdam%2Fzebra_new_ia%2Fen-us%2Fmanuals%2Fprinters%2Fdesktop%2Fgt800%2Fgt800-ug-zh-cn.pdf">ZBREA GT800 热转印打印机教程</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">extension://bfdogplmndidlpjfhoijckpakkdjkkil/pdf/viewer.html?file=https%3A%2F%2Fwww.zebra.cn%2Fcontent%2Fdam%2Fzebra_new_ia%2Fen-us%2Fmanuals%2Fprinters%2Fdesktop%2Fgt800%2Fgt800-ug-zh-cn.pdf<br></code></pre></td></tr></table></figure></li><li><p><a href="https://resource.tp-link.com.cn/pc/docCenter/showDoc?productId=681&type=711&id=1681716022875096">全千兆以太网交换机 16GE+2SFP TL-SG1218</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://resource.tp-link.com.cn/pc/docCenter/showDoc?productId=681&amp;type=711&amp;id=1681716022875096<br></code></pre></td></tr></table></figure></li><li><p><a href="https://blog.csdn.net/zlbdmm/article/details/106807588#:~:text=1%E3%80%81%E5%8F%8C%E5%87%BB%E4%B8%8B%E8%BD%BD%E7%9A%84cn_sql_server_2016_enterprise_x64_dvd_8699450.iso%E6%96%87%E4%BB%B6%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%A3%85%E8%BD%BD%E5%A6%82%E8%99%9A%E6%8B%9F%E5%85%89%E9%A9%B1%EF%BC%8C%E6%89%93%E5%BC%80%E8%99%9A%E6%8B%9F%E5%85%89%E9%A9%B1%E4%BC%9A%E7%9C%8B%E5%88%B0%E5%AE%89%E8%A3%85%E5%8C%85%E7%9A%84%E5%86%85%E5%AE%B9%E5%A6%82%E4%B8%8B%EF%BC%9A%202%E3%80%81%E5%8F%8C%E5%87%BBsetup.exe%E8%BF%9B%E5%85%A5%E5%AE%89%E8%A3%85%E5%90%91%E5%AF%BC%E7%95%8C%E9%9D%A2%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A%203%E3%80%81%E9%80%89%E6%8B%A9%E5%B7%A6%E4%BE%A7%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E7%9A%84,%5B%E5%AE%89%E8%A3%85%5D%EF%BC%8C%E5%87%BA%E7%8E%B0%E4%B8%8B%E5%9B%BE%EF%BC%9A%204%E3%80%81%E9%80%89%E6%8B%A9%E5%8F%B3%E4%BE%A7%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%80%89%E9%A1%B9%20%5B%E5%85%A8%E6%96%B0SQL%20Server%E7%8B%AC%E7%AB%8B%E5%AE%89%E8%A3%85%E6%88%96%E5%90%91%E7%8E%B0%E6%9C%89%E5%AE%89%E8%A3%85%E6%B7%BB%E5%8A%A0%E5%8A%9F%E8%83%BD%5D%EF%BC%8C%E8%BF%9B%E5%85%A5%E8%BE%93%E5%85%A5%E4%BA%A7%E5%93%81%E5%AF%86%E9%92%A5%E7%95%8C%E9%9D%A2%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">Microsoft SQL Server 2016安装教程</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://blog.csdn.net/zlbdmm/article/details/106807588#:~:text=1%E3%80%81%E5%8F%8C%E5%87%BB%E4%B8%8B%E8%BD%BD%E7%9A%84cn_sql_server_2016_enterprise_x64_dvd_8699450.iso%E6%96%87%E4%BB%B6%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%A3%85%E8%BD%BD%E5%A6%82%E8%99%9A%E6%8B%9F%E5%85%89%E9%A9%B1%EF%BC%8C%E6%89%93%E5%BC%80%E8%99%9A%E6%8B%9F%E5%85%89%E9%A9%B1%E4%BC%9A%E7%9C%8B%E5%88%B0%E5%AE%89%E8%A3%85%E5%8C%85%E7%9A%84%E5%86%85%E5%AE%B9%E5%A6%82%E4%B8%8B%EF%BC%9A%202%E3%80%81%E5%8F%8C%E5%87%BBsetup.exe%E8%BF%9B%E5%85%A5%E5%AE%89%E8%A3%85%E5%90%91%E5%AF%BC%E7%95%8C%E9%9D%A2%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A%203%E3%80%81%E9%80%89%E6%8B%A9%E5%B7%A6%E4%BE%A7%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E7%9A%84,%5B%E5%AE%89%E8%A3%85%5D%EF%BC%8C%E5%87%BA%E7%8E%B0%E4%B8%8B%E5%9B%BE%EF%BC%9A%204%E3%80%81%E9%80%89%E6%8B%A9%E5%8F%B3%E4%BE%A7%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%80%89%E9%A1%B9%20%5B%E5%85%A8%E6%96%B0SQL%20Server%E7%8B%AC%E7%AB%8B%E5%AE%89%E8%A3%85%E6%88%96%E5%90%91%E7%8E%B0%E6%9C%89%E5%AE%89%E8%A3%85%E6%B7%BB%E5%8A%A0%E5%8A%9F%E8%83%BD%5D%EF%BC%8C%E8%BF%9B%E5%85%A5%E8%BE%93%E5%85%A5%E4%BA%A7%E5%93%81%E5%AF%86%E9%92%A5%E7%95%8C%E9%9D%A2%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A<br></code></pre></td></tr></table></figure></li><li><p><a href="http://www.symbol-barcode.cn/supports/Symbol-Setting.html">讯宝SYMBOL扫描枪常用设置方法</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">http://www.symbol-barcode.cn/supports/Symbol-Setting.html<br></code></pre></td></tr></table></figure></li><li><p><a href="https://www.docin.com/p-2467503555.html">山特UPS-说明书-c3ks说明书</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://www.docin.com/p-2467503555.html<br></code></pre></td></tr></table></figure><p> 19.<a href="https://honeypdf.com/download-5807ccefe0883c1b0ee2bde6954c6148.html">电子书之家-非盈利</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://honeypdf.com/download-5807ccefe0883c1b0ee2bde6954c6148.html<br></code></pre></td></tr></table></figure><p> 20.<a href="https://www.freedidi.com/12747.html">windows10 电脑安装安卓模拟器</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://www.freedidi.com/12747.html<br></code></pre></td></tr></table></figure></li><li><p>Excel 转换为 sql - 在线表格转换工具<br><a href="https://tableconvert.com/zh-cn/">转换工具1，表格中int和bit类型的字段为空值时会被转转为0</a><br><a href="https://www.beautifyconverter.com/excel-to-sql-converter.php">转换工具2，表格中int和bit类型的字段为空值时会被转转为0,并且转换后的数据中会有几行是错误的</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs copy">https://tableconvert.com/zh-cn/<br>https://www.beautifyconverter.com/excel-to-sql-converter.php<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>常用工具链接</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网址收藏夹</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络调试知识点（12个）</title>
    <link href="/2024/06/13/%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2024/06/13/%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="12常用网络调试命令"><a href="#12常用网络调试命令" class="headerlink" title="12常用网络调试命令"></a>12常用网络调试命令</h1><h2 id="ping-用于测试主机之间的网络连通性。"><a href="#ping-用于测试主机之间的网络连通性。" class="headerlink" title="ping 用于测试主机之间的网络连通性。"></a>ping 用于测试主机之间的网络连通性。</h2><h3 id="1-ping"><a href="#1-ping" class="headerlink" title="1.ping"></a>1.ping</h3><pre><code class="hljs">    使用场景: 检测目标主机是否可达。    操作步骤: 打开命令行，输入 ping &lt;目标主机&gt;。    例子: ping google.com    优点: 简单快速检测网络连通性。    缺点: 不提供有关网络延迟或路由的信息。</code></pre><h3 id="2-tracert-traceroute"><a href="#2-tracert-traceroute" class="headerlink" title="2.tracert &#x2F; traceroute"></a>2.tracert &#x2F; traceroute</h3><pre><code class="hljs">    使用场景: 追踪数据包到目标主机的完整路径。    操作步骤: 打开命令行，输入 tracert &lt;目标主机&gt; (Windows) 或 traceroute &lt;目标主机&gt; (Unix/Linux)。    例子: tracert google.com    优点: 显示经过的每个路由器和延迟。    缺点: 在某些网络可能被阻止。</code></pre><h3 id="3-nslookup"><a href="#3-nslookup" class="headerlink" title="3.nslookup"></a>3.nslookup</h3><pre><code class="hljs">    使用场景: 查询DNS解析，诊断域名解析问题。    操作步骤: 打开命令行，输入 nslookup &lt;域名或IP地址&gt;。    例子: nslookup www.google.com    优点: 提供DNS解析的详细信息。    缺点: 命令行界面，输出信息可能较复杂。</code></pre><h3 id="4-ipconfig-ifconfig"><a href="#4-ipconfig-ifconfig" class="headerlink" title="4.ipconfig &#x2F; ifconfig"></a>4.ipconfig &#x2F; ifconfig</h3><pre><code class="hljs">    使用场景: 显示网络接口的IP配置信息。    操作步骤: 打开命令行，输入 ipconfig /all (Windows) 或 ifconfig (Unix/Linux)。    例子: ipconfig /all    优点: 显示所有网络接口的详细信息。    缺点: Windows和Unix/Linux命令不同。</code></pre><h3 id="5-netstat"><a href="#5-netstat" class="headerlink" title="5.netstat"></a>5.netstat</h3><pre><code class="hljs">    使用场景: 显示网络连接状态、端口使用情况。    操作步骤: 打开命令行，输入 netstat -an。    例子: netstat -an | findstr &quot;特定端口号&quot;    优点: 提供当前网络活动的快照。    缺点: 输出可能很多，需要过滤。</code></pre><h3 id="6-arp"><a href="#6-arp" class="headerlink" title="6.arp"></a>6.arp</h3><pre><code class="hljs">    使用场景: 查看和清除ARP缓存表。    操作步骤: 打开命令行，输入 arp -a (查看) 或 arp -d &lt;IP地址&gt; (清除)。    例子: arp -a    优点: 显示IP与MAC地址的映射。    缺点: 只能查看和清除，不能修改。</code></pre><h3 id="7-route-ip-route"><a href="#7-route-ip-route" class="headerlink" title="7.route &#x2F; ip route"></a>7.route &#x2F; ip route</h3><pre><code class="hljs">    使用场景: 显示或修改IP路由表。    操作步骤: 打开命令行，输入 route print (Windows) 或 ip route show (Unix/Linux)。    例子: route add 目标网络 网关地址    优点: 显示和管理路由表。    缺点: 命令在不同操作系统中有所不同。</code></pre><h3 id="8-telnet"><a href="#8-telnet" class="headerlink" title="8.telnet"></a>8.telnet</h3><pre><code class="hljs">    使用场景: 测试网络服务的连通性。    操作步骤: 打开命令行，输入 telnet &lt;目标主机&gt; &lt;端口号&gt;。    例子: telnet google.com 80    优点: 简单测试服务连通性。    缺点: 不安全，已被更安全的SSH等工具取代。</code></pre><h3 id="9-curl"><a href="#9-curl" class="headerlink" title="9.curl"></a>9.curl</h3><pre><code class="hljs">    使用场景: 从服务器传输数据，常用于API调试。    操作步骤: 打开命令行，输入 curl -X &lt;请求方法&gt; &lt;URL&gt;。    例子: curl -X GET https://api.example.com/data    优点: 支持多种协议和详细的请求定制。    缺点: 输出格式为纯文本，可能需要进一步处理。</code></pre><h3 id="10-traceroute"><a href="#10-traceroute" class="headerlink" title="10.traceroute"></a>10.traceroute</h3><pre><code class="hljs">    使用场景: 显示数据包到目标主机的路径。    操作步骤: 打开命令行，输入 traceroute &lt;目标主机&gt;。    例子: traceroute google.com    优点: 类似于 tracert，显示路由路径。    缺点: 在某些网络可能被阻止。</code></pre><h3 id="11-nslookup"><a href="#11-nslookup" class="headerlink" title="11.nslookup"></a>11.nslookup</h3><pre><code class="hljs">    使用场景: 查询DNS记录，诊断域名解析问题。    操作步骤: 打开命令行，输入 nslookup &lt;域名&gt;。    例子: nslookup www.example.com    优点: 提供DNS解析的详细信息。    缺点: 输出信息可能较复杂。</code></pre><h3 id="12-dig"><a href="#12-dig" class="headerlink" title="12.dig"></a>12.dig</h3><pre><code class="hljs">    使用场景: DNS查找工具，Unix/Linux系统上常用。    操作步骤: 打开命令行，输入 dig &lt;域名&gt;。    例子: dig www.example.com    优点: 功能强大，输出信息丰富。    缺点: 命令行界面，需要一定的DNS知识。</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程技能</category>
      
      <category>网络调试命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络调试命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL Server 2014 常用 SQL 语句</title>
    <link href="/2024/06/13/SQL%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2024/06/13/SQL%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL-Server-2014-常用-SQL-语句知识点"><a href="#SQL-Server-2014-常用-SQL-语句知识点" class="headerlink" title="SQL Server 2014 常用 SQL 语句知识点"></a>SQL Server 2014 常用 SQL 语句知识点</h1><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><h3 id="查询所有列"><a href="#查询所有列" class="headerlink" title="查询所有列"></a>查询所有列</h3><p>SELECT * FROM 表名;</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">### 查询特定列<br>```SQL<br>SELECT 列<span class="hljs-number">1</span>, 列<span class="hljs-number">2</span> FROM 表名;<br></code></pre></td></tr></table></figure><h3 id="查询前-N-行"><a href="#查询前-N-行" class="headerlink" title="查询前 N 行"></a>查询前 N 行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> TOP N <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><p>条件查询</p><h3 id="条件筛选"><a href="#条件筛选" class="headerlink" title="条件筛选"></a>条件筛选</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件;<br></code></pre></td></tr></table></figure><p>排序</p><h3 id="升序排序"><a href="#升序排序" class="headerlink" title="升序排序"></a>升序排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 列<span class="hljs-number">1</span> <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure><h3 id="降序排序"><a href="#降序排序" class="headerlink" title="降序排序"></a>降序排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 列<span class="hljs-number">1</span> <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><p>分组</p><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> 列<span class="hljs-number">1</span>, <span class="hljs-built_in">COUNT</span>(列<span class="hljs-number">2</span>) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 列<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>聚合函数</p><h3 id="COUNT-SUM-AVG-MAX-MIN"><a href="#COUNT-SUM-AVG-MAX-MIN" class="headerlink" title="COUNT, SUM, AVG, MAX, MIN"></a>COUNT, SUM, AVG, MAX, MIN</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>), <span class="hljs-built_in">SUM</span>(列名), <span class="hljs-built_in">AVG</span>(列名), <span class="hljs-built_in">MAX</span>(列名), <span class="hljs-built_in">MIN</span>(列名) <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><p>连接查询</p><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> a.<span class="hljs-operator">*</span>, b.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表A a <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> 表B b <span class="hljs-keyword">ON</span> a.列名 <span class="hljs-operator">=</span> b.列名;<br></code></pre></td></tr></table></figure><h3 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> a.<span class="hljs-operator">*</span>, b.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表A a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> 表B b <span class="hljs-keyword">ON</span> a.列名 <span class="hljs-operator">=</span> b.列名;<br></code></pre></td></tr></table></figure><h3 id="右连接"><a href="#右连接" class="headerlink" title="右连接"></a>右连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> a.<span class="hljs-operator">*</span>, b.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表A a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> 表B b <span class="hljs-keyword">ON</span> a.列名 <span class="hljs-operator">=</span> b.列名;<br></code></pre></td></tr></table></figure><p>子查询</p><h3 id="在-WHERE-子句中使用子查询"><a href="#在-WHERE-子句中使用子查询" class="headerlink" title="在 WHERE 子句中使用子查询"></a>在 WHERE 子句中使用子查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 列名 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> 列名 <span class="hljs-keyword">FROM</span> 子查询表);<br></code></pre></td></tr></table></figure><h3 id="在-FROM-子句中使用子查询"><a href="#在-FROM-子句中使用子查询" class="headerlink" title="在 FROM 子句中使用子查询"></a>在 FROM 子句中使用子查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 子查询表) <span class="hljs-keyword">AS</span> 别名;<br></code></pre></td></tr></table></figure><p>创建表</p><h3 id="创建新表"><a href="#创建新表" class="headerlink" title="创建新表"></a>创建新表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 新表名 (<br>    列<span class="hljs-number">1</span> 数据类型,<br>    列<span class="hljs-number">2</span> 数据类型<br>);<br></code></pre></td></tr></table></figure><h3 id="创建表并指定主键"><a href="#创建表并指定主键" class="headerlink" title="创建表并指定主键"></a>创建表并指定主键</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 新表名 (<br>    列<span class="hljs-number">1</span> 数据类型 <span class="hljs-keyword">PRIMARY</span> KEY,<br>    列<span class="hljs-number">2</span> 数据类型<br>);<br></code></pre></td></tr></table></figure><p>修改表结构</p><h3 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> 新列名 数据类型;<br></code></pre></td></tr></table></figure><h3 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> 列名;<br></code></pre></td></tr></table></figure><h3 id="修改列的数据类型"><a href="#修改列的数据类型" class="headerlink" title="修改列的数据类型"></a>修改列的数据类型</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> 列名 新数据类型;<br></code></pre></td></tr></table></figure><p>插入数据</p><h3 id="插入完整行"><a href="#插入完整行" class="headerlink" title="插入完整行"></a>插入完整行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 (列<span class="hljs-number">1</span>, 列<span class="hljs-number">2</span>) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="插入多行"><a href="#插入多行" class="headerlink" title="插入多行"></a>插入多行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 (列<span class="hljs-number">1</span>, 列<span class="hljs-number">2</span>) <span class="hljs-keyword">VALUES</span> <br>(值<span class="hljs-number">1</span>a, 值<span class="hljs-number">2</span>a),<br>(值<span class="hljs-number">1</span>b, 值<span class="hljs-number">2</span>b),<br>(值<span class="hljs-number">1</span>c, 值<span class="hljs-number">2</span>c);<br></code></pre></td></tr></table></figure><p>更新数据</p><h3 id="更新符合条件的数据"><a href="#更新符合条件的数据" class="headerlink" title="更新符合条件的数据"></a>更新符合条件的数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">UPDATE</span> 表名 <span class="hljs-keyword">SET</span> 列名 <span class="hljs-operator">=</span> 新值 <span class="hljs-keyword">WHERE</span> 条件;<br></code></pre></td></tr></table></figure><p>删除数据</p><h3 id="删除符合条件的数据"><a href="#删除符合条件的数据" class="headerlink" title="删除符合条件的数据"></a>删除符合条件的数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件;<br></code></pre></td></tr></table></figure><p>存储过程</p><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名<br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">BEGIN</span><br>    ### <span class="hljs-keyword">SQL</span> 语句<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><h3 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">EXEC</span> 存储过程名;<br></code></pre></td></tr></table></figure><p>事务控制</p><h3 id="开始事务"><a href="#开始事务" class="headerlink" title="开始事务"></a>开始事务</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">BEGIN</span> TRANSACTION;<br></code></pre></td></tr></table></figure><h3 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">COMMIT</span> TRANSACTION;<br></code></pre></td></tr></table></figure><h3 id="回滚事务"><a href="#回滚事务" class="headerlink" title="回滚事务"></a>回滚事务</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ROLLBACK</span> TRANSACTION;<br></code></pre></td></tr></table></figure><h3 id="查询某张sql表的所有字段信息"><a href="#查询某张sql表的所有字段信息" class="headerlink" title="查询某张sql表的所有字段信息"></a>查询某张sql表的所有字段信息</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <br>    COLUMN_NAME, <br>    DATA_TYPE, <br>    IS_NULLABLE <br><span class="hljs-keyword">FROM</span> <br>    INFORMATION_SCHEMA.COLUMNS <br><span class="hljs-keyword">WHERE</span> <br>    TABLE_NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;你的表名&#x27;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程技能</category>
      
      <category>SQL 知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL Server</tag>
      
      <tag>SQL查询</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
